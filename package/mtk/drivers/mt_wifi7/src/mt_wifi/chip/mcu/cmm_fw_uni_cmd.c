/*
 ***************************************************************************
 * MediaTek Inc.
 *
 * All rights reserved. source code is an unpublished work and the
 * use of a copyright notice does not imply otherwise. This source code
 * contains confidential trade secret material of MediaTek. Any attempt
 * or participation in deciphering, decoding, reverse engineering or in any
 * way altering the source code is stricitly prohibited, unless the prior
 * written consent of MediaTek, Inc. is obtained.
 ***************************************************************************

	Module Name:
	cmm_fw_uni_cmd.c
*/

#ifdef WIFI_UNIFIED_COMMAND
#include "rt_config.h"
#include "hdev/hdev.h"
#include "bss_mngr.h"
#include "epcs_cmm.h"

BOOLEAN UniCmdCheckInitReady(struct _RTMP_ADAPTER *pAd)
{
#ifdef HWIFI_SUPPORT
	return TRUE;
#else /* HWIFI_SUPPORT */
	struct MCU_CTRL *Ctrl = PD_GET_MCU_CTRL_PTR(pAd->physical_dev);

	if (Ctrl && OS_TEST_BIT(MCU_INIT, &Ctrl->flags))
		return TRUE;
	else
		return FALSE;
#endif /* !HWIFI_SUPPORT */
}

struct wifi_dev *uni_cmd_wdev_band_by_ad(struct _RTMP_ADAPTER *pad)
{
	POS_COOKIE pObj = NULL;
	struct wifi_dev *wdev = NULL;

	if (!pad)
		return wdev;

	pObj = (POS_COOKIE) pad->OS_Cookie;
	if (!pObj)
		return wdev;

	wdev = get_wdev_by_ioctl_idx_and_iftype(pad, pObj->ioctl_if, pObj->ioctl_if_type);

	return wdev;
}

struct cmd_msg *AndesAllocUniCmdMsg(struct _RTMP_ADAPTER *pAd, unsigned int length)
{
	return hif_mcu_alloc_msg(pAd, length, FALSE);
}

static INT32 UniCmdDevInfoActive(struct _RTMP_ADAPTER *pAd, UINT8 Active, UINT8 *OwnMacAddr, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_DEVINFO_ACTIVE_T pDevInfoActive = (P_UNI_CMD_DEVINFO_ACTIVE_T)pHandle;

	/* Fill TLV format */
	pDevInfoActive->u2Tag = UNI_CMD_DEVINFO_ACTIVE;
	pDevInfoActive->u2Length = sizeof(UNI_CMD_DEVINFO_ACTIVE_T);
#ifdef CFG_BIG_ENDIAN
	pDevInfoActive->u2Tag = cpu2le16(pDevInfoActive->u2Tag);
	pDevInfoActive->u2Length = cpu2le16(pDevInfoActive->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pDevInfoActive->ucActive = Active;
	os_move_mem(pDevInfoActive->aucOwnMacAddr, OwnMacAddr, MAC_ADDR_LEN);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_INFO,
			"aucOwnMacAddr("MACSTR"), ucActive=0x%x\n",
			MAC2STR(pDevInfoActive->aucOwnMacAddr), pDevInfoActive->ucActive);
	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdDevInfoTab[] = {
	{
		.u8CmdFeature = DEVINFO_ACTIVE_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_DEVINFO_ACTIVE_T),
		.pfHandler = UniCmdDevInfoActive
	},
};

INT32 UniCmdDevInfoUpdate(
	struct _RTMP_ADAPTER *pAd,
	UINT8 OwnMacIdx,
	UINT8 *OwnMacAddr,
	UINT8 BandIdx,
	UINT8 Active,
	UINT64 u8EnableFeature)
{
	struct cmd_msg			*msg = NULL;
	INT32					Ret = NDIS_STATUS_SUCCESS;
	UINT8					i = 0;
	UINT16					u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_DEVINFO_T		pCmdDeviceInfoUpdate = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);
	UINT32 					DevInfoTabSize = (sizeof(UniCmdDevInfoTab) / sizeof(UniCmdDevInfoTab[0]));

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_DEVINFO_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < DevInfoTabSize; i++) {
		if (u8EnableFeature & UniCmdDevInfoTab[i].u8CmdFeature) {
			u4CmdNeedMaxBufSize += UniCmdDevInfoTab[i].u4StructSize;
		}
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdDeviceInfoUpdate = (P_UNI_CMD_DEVINFO_T)pNextHeadBuf;
	pCmdDeviceInfoUpdate->ucOwnMacIdx = OwnMacIdx;
	pCmdDeviceInfoUpdate->ucDbdcIdx = BandIdx;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < DevInfoTabSize; i++) {
		switch (u8EnableFeature & UniCmdDevInfoTab[i].u8CmdFeature) {
		case DEVINFO_ACTIVE_FEATURE:
			if (UniCmdDevInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_DEVINFO_ACTIVE_HANDLE)(UniCmdDevInfoTab[i].pfHandler))(pAd, Active, OwnMacAddr, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdDevInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_SUCCESS;
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_DEBUG,
				"The hanlder of tag (0x%llx) not support!\n",
				u8EnableFeature);
			break;
		}

		if (Ret != NDIS_STATUS_SUCCESS)
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_INFO,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdDevInfoTab[i].u8CmdFeature);
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_INFO,
		"Active = %d, OwnMacIdx = %d, band = %d (%02x-%02x-%02x-%02x-%02x-%02x), TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		Active, OwnMacIdx, BandIdx, PRINT_MAC(OwnMacAddr), u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_DEVINFO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if ((!bNeedFrag) || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			call_fw_cmd_notifieriers(WO_CMD_DEV_INFO, pAd, msg->net_pkt);
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdBssInfoBasic(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BASIC_T pBssInfoBasic = (P_UNI_CMD_BSSINFO_BASIC_T)pHandle;

	/* Fill TLV format */
	pBssInfoBasic->u2Tag = UNI_CMD_BSSINFO_BASIC;
	pBssInfoBasic->u2Length = sizeof(UNI_CMD_BSSINFO_BASIC_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBasic->u2Tag = cpu2le16(pBssInfoBasic->u2Tag);
	pBssInfoBasic->u2Length = cpu2le16(pBssInfoBasic->u2Length);
#endif /* CFG_BIG_ENDIAN */
	if (bss_info->bss_state >= BSS_ACTIVE)
		pBssInfoBasic->ucActive = TRUE;
	else
		pBssInfoBasic->ucActive = FALSE;
	pBssInfoBasic->ucOwnMacIdx = bss_info->OwnMacIdx;
	pBssInfoBasic->ucHwBSSIndex = (bss_info->OwnMacIdx > HW_BSSID_MAX) ? HW_BSSID_0 : bss_info->OwnMacIdx;
	pBssInfoBasic->ucDbdcIdx = bss_info->ucBandIdx;
	pBssInfoBasic->u4ConnectionType = cpu2le32(bss_info->u4ConnectionType);
	pBssInfoBasic->ucConnectionState = (bss_info->bss_state < BSS_ACTIVE) ? MEDIA_STATE_DISCONNECTED : MEDIA_STATE_CONNECTED;
	pBssInfoBasic->ucWmmIdx = bss_info->WmmIdx;
	os_move_mem(pBssInfoBasic->aucBSSID, bss_info->Bssid, MAC_ADDR_LEN);
	pBssInfoBasic->u2BcMcWlanidx = cpu2le16(bss_info->bmc_wlan_idx);
	pBssInfoBasic->u2BcnInterval = cpu2le16(bss_info->bcn_period);
	pBssInfoBasic->ucDtimPeriod = bss_info->dtim_period;
	pBssInfoBasic->ucPhyMode = bss_info->ucPhyMode;
	pBssInfoBasic->u2StaRecIdxOfAP = (bss_info->u4ConnectionType == CONNECTION_INFRA_STA) ? \
										cpu2le16(bss_info->peer_wlan_idx) : 0;
	pBssInfoBasic->u2NonHTBasicPhyType = 0;
	pBssInfoBasic->ucPhyModeExt = bss_info->ucPhyModeExt;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			"BSSID:%pM,DbdcIdx=%d,ConnectionType=%d,Active=%d,BcnInterval=%d\n",
			bss_info->Bssid,
			pBssInfoBasic->ucDbdcIdx,
			pBssInfoBasic->u4ConnectionType,
			pBssInfoBasic->ucActive,
			pBssInfoBasic->u2BcnInterval);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			"ucWmmIdx=%d,DtimPeriod=%d,BcMcWlanidx = %d,PhyMode=%x,BSSID="MACSTR"\n",
			pBssInfoBasic->ucWmmIdx,
			pBssInfoBasic->ucDtimPeriod,
			le2cpu16(pBssInfoBasic->u2BcMcWlanidx),
			pBssInfoBasic->ucPhyMode,
			MAC2STR(pBssInfoBasic->aucBSSID));

	return Ret;
}

static INT32 UniCmdBssInfoRate(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
#ifdef CONFIG_RA_PHY_RATE_SUPPORT
	UCHAR i;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
#endif
	P_UNI_CMD_BSSINFO_RATE_T pBssInfoRate = (P_UNI_CMD_BSSINFO_RATE_T)pHandle;

	if (bss_info->bss_state >= BSS_ACTIVE) {
		/* Fill TLV format */
		pBssInfoRate->u2Tag = UNI_CMD_BSSINFO_RATE;
		pBssInfoRate->u2Length = sizeof(UNI_CMD_BSSINFO_RATE_T);
#ifdef CFG_BIG_ENDIAN
		pBssInfoRate->u2Tag = cpu2le16(pBssInfoRate->u2Tag);
		pBssInfoRate->u2Length = cpu2le16(pBssInfoRate->u2Length);
#endif /* CFG_BIG_ENDIAN */

		pBssInfoRate->u2BcRate = cpu2le16((UINT16)(bss_info->BcTransmit.word));
		pBssInfoRate->u2McRate = cpu2le16((UINT16)(bss_info->McTransmit.word));
		pBssInfoRate->ucPreambleMode = OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);

		pBssInfoRate->ucBcFixedRateIdx = transmit_to_fr_idx(bss_info->BcTransmit.word);
		pBssInfoRate->ucMcFixedRateIdx = transmit_to_fr_idx(bss_info->McTransmit.word);
		pBssInfoRate->ucMloCPFixedRateIdx = bss_info->mloFixedRateIdx;

#ifdef CONFIG_RA_PHY_RATE_SUPPORT
		if (wdev) {
			pBssInfoRate->ucHighPriFalg = wdev->eap.eap_hprirate_en;
			for (i = HIGHPRI_ARP; i < HIGHPRI_MAX_TYPE; i++) {
				if (pBssInfoRate->ucHighPriFalg & (1 << i))
					pBssInfoRate->ucHighPriFRIdx[i] = transmit_to_fr_idx(wdev->eap.hpriphymode[i].word);
			}
		}
#endif
	} else {
		Ret = NDIS_STATUS_FAILURE;
	}

#ifdef TXRX_STAT_SUPPORT
	{
		ULONG Multicast_Tx_Rate;

		pAd->ApCfg.MBSSID[bss_info->ucBssIndex].stat_bss.LastMulticastTxRate.word = bss_info->McTransmit.word;
		getRate(bss_info->McTransmit, &Multicast_Tx_Rate);
	}
#endif
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_NOTICE,
		"Bssid:("MACSTR"),BcRate=%d,McRate=%d,ucPreamMode=%d,BcFRateIdx=%d,McFRateIdx=%d\n",
		MAC2STR(bss_info->Bssid), pBssInfoRate->u2BcRate, pBssInfoRate->u2McRate,
		pBssInfoRate->ucPreambleMode, pBssInfoRate->ucBcFixedRateIdx, pBssInfoRate->ucMcFixedRateIdx);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_NOTICE,
		"ucMloCPFixedRateIdx=%d\n", pBssInfoRate->ucMloCPFixedRateIdx);

	return Ret;
}

static INT32 UniCmdBssInfoSec(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_SEC_T pBssInfoSec = (P_UNI_CMD_BSSINFO_SEC_T)pHandle;

	/* Fill TLV format */
	pBssInfoSec->u2Tag = UNI_CMD_BSSINFO_SEC;
	pBssInfoSec->u2Length = sizeof(UNI_CMD_BSSINFO_SEC_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoSec->u2Tag = cpu2le16(pBssInfoSec->u2Tag);
	pBssInfoSec->u2Length = cpu2le16(pBssInfoSec->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoSec->ucAuthMode = 0; /* for mobile */
	pBssInfoSec->ucEncStatus = 0; /* for mobile */
	pBssInfoSec->ucCipherSuit = bss_info->CipherSuit;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
				"Bssid("MACSTR")pBssInfoSec->ucCipherSuit=%d\n",
				MAC2STR(bss_info->Bssid), pBssInfoSec->ucCipherSuit);

	return Ret;
}

static INT32 UniCmdBssInfoTxCmd(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_TXCMD_T pBssInfoTxCmd = (P_UNI_CMD_BSSINFO_TXCMD_T)pHandle;
	struct _WIFI_SYS_INFO *wsys = pAd->WifiSysInfo;
  #ifdef CONFIG_WLAN_SERVICE
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	UINT8 fgUseTxCMD = hc_get_txcmd_mode(pAd->hdev_ctrl);

	if ((wdev != NULL) && (wdev->wdev_type == WDEV_TYPE_SERVICE_TXD))
		fgUseTxCMD = HOBJ_TX_MODE_TXD;
#endif

	/* only the last one intf going down will switch the tx mode */
	if (bss_info->bss_state >= BSS_ACTIVE || wsys->BssInfo.Num > 1) {
		/* Fill TLV format */
		pBssInfoTxCmd->u2Tag = UNI_CMD_BSSINFO_TXCMD;
		pBssInfoTxCmd->u2Length = sizeof(UNI_CMD_BSSINFO_TXCMD_T);
#ifdef CFG_BIG_ENDIAN
		pBssInfoTxCmd->u2Tag = cpu2le16(pBssInfoTxCmd->u2Tag);
		pBssInfoTxCmd->u2Length = cpu2le16(pBssInfoTxCmd->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pBssInfoTxCmd->fgUseTxCMD = hc_get_txcmd_mode(pAd->hdev_ctrl);
#ifdef CONFIG_WLAN_SERVICE
		pBssInfoTxCmd->fgUseTxCMD = fgUseTxCMD;
		if (wdev != NULL)
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
				"wdev_idx:%d ,wdev_type:%d, tx_mode:%d\n",
				wdev->wdev_idx, wdev->wdev_type, fgUseTxCMD);
#endif
	} else {
		Ret = NDIS_STATUS_FAILURE;
	}
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
				"fgUseTxCMD:%d ,aucPadding:[0x%x][0x%x][0x%x]\n",
				pBssInfoTxCmd->fgUseTxCMD, pBssInfoTxCmd->aucPadding[0],
				pBssInfoTxCmd->aucPadding[1], pBssInfoTxCmd->aucPadding[2]);
	return Ret;
}

static INT32 UniCmdBssInfoBasicWrapAll(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, UINT32 *offset, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PUCHAR pTempBuf = (PUCHAR)pHandle;
	*offset = 0;

	Ret = UniCmdBssInfoBasic(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_BASIC_T);
		*offset += sizeof(UNI_CMD_BSSINFO_BASIC_T);
	}

	/* below TLV is for WA only */
	Ret = UniCmdBssInfoRate(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_RATE_T);
		*offset += sizeof(UNI_CMD_BSSINFO_RATE_T);
	}

	Ret = UniCmdBssInfoSec(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_SEC_T);
		*offset += sizeof(UNI_CMD_BSSINFO_SEC_T);
	}

	Ret = UniCmdBssInfoTxCmd(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_TXCMD_T);
		*offset += sizeof(UNI_CMD_BSSINFO_TXCMD_T);
	}

	return (*offset > 0) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
}

#ifdef RACTRL_FW_OFFLOAD_SUPPORT
static INT32 UniCmdBssInfoRA(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_RA_T pBssInfoRA = (P_UNI_CMD_BSSINFO_RA_T)pHandle;
#ifdef DOT11_EHT_BE
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
#endif /* DOT11_EHT_BE */

	/* Fill TLV format */
	pBssInfoRA->u2Tag = UNI_CMD_BSSINFO_RA;
	pBssInfoRA->u2Length = sizeof(UNI_CMD_BSSINFO_RA_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoRA->u2Tag = cpu2le16(pBssInfoRA->u2Tag);
	pBssInfoRA->u2Length = cpu2le16(pBssInfoRA->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoRA->fgShortPreamble = bss_info->ra_cfg.fgShortPreamble;
	pBssInfoRA->fgTestbedForceShortGI = bss_info->ra_cfg.TestbedForceShortGI;
	pBssInfoRA->fgTestbedForceGreenField = bss_info->ra_cfg.TestbedForceGreenField;
#ifdef DOT11_N_SUPPORT
	pBssInfoRA->ucHtMode = bss_info->ra_cfg.HtMode;
#endif /* DOT11_N_SUPPORT */
	pBssInfoRA->fgSeOff = bss_info->ra_cfg.fgSeOff;
	pBssInfoRA->ucAntennaIndex = bss_info->ra_cfg.ucAntennaIndex;
	pBssInfoRA->u2MaxPhyRate =  cpu2le16(bss_info->ra_cfg.u2MaxPhyRate);
	pBssInfoRA->ucForceTxStream =  bss_info->ra_cfg.ucForceTxStream;
#ifdef DOT11_EHT_BE
	if (wdev)
		pBssInfoRA->ucMaxMcs = wlan_config_get_eht_max_mcs(wdev);
#endif /* DOT11_EHT_BE */
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
		"%d %d %d %d %d %d %d %d %d\n",
		pBssInfoRA->fgShortPreamble, pBssInfoRA->fgTestbedForceShortGI,
		pBssInfoRA->fgTestbedForceGreenField, pBssInfoRA->ucHtMode,
		pBssInfoRA->fgSeOff, pBssInfoRA->ucAntennaIndex,
		pBssInfoRA->u2MaxPhyRate, pBssInfoRA->ucForceTxStream,
		pBssInfoRA->ucMaxMcs);

	return Ret;
}
#endif /* RACTRL_FW_OFFLOAD_SUPPORT */

static INT32 UniCmdBssInfoRLM(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_RLM_T pBssInfoRLM = (P_UNI_CMD_BSSINFO_RLM_T)pHandle;
	struct freq_oper *chan_oper = &bss_info->chan_oper;
	UINT16 phymode = (bss_info->ucPhyModeExt << 8) | bss_info->ucPhyMode;

	if (WMODE_CAP_6G(phymode))
		pBssInfoRLM->ucRfBand = CMD_BAND_6G;
	else if (WMODE_CAP_5G(phymode))
		pBssInfoRLM->ucRfBand = CMD_BAND_5G;
	else if (WMODE_CAP_2G(phymode))
		pBssInfoRLM->ucRfBand = CMD_BAND_2G4;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO, "phymode=%d, ucRfBand=%d\n",
		phymode, pBssInfoRLM->ucRfBand);

	/* Fill TLV format */
	pBssInfoRLM->u2Tag = UNI_CMD_BSSINFO_RLM;
	pBssInfoRLM->u2Length = sizeof(UNI_CMD_BSSINFO_RLM_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoRLM->u2Tag = cpu2le16(pBssInfoRLM->u2Tag);
	pBssInfoRLM->u2Length = cpu2le16(pBssInfoRLM->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoRLM->ucPrimaryChannel = chan_oper->prim_ch;
	pBssInfoRLM->ucCenterChannelSeg0 = chan_oper->cen_ch_1;
	pBssInfoRLM->ucCenterChannelSeg1 = chan_oper->cen_ch_2;
	pBssInfoRLM->ucBandwidth = GetCfgBw2RawBw(chan_oper->bw);
#ifdef RACTRL_FW_OFFLOAD_SUPPORT
	pBssInfoRLM->ucTxStream = bss_info->ra_cfg.TxStream;
	pBssInfoRLM->ucRxStream = bss_info->ra_cfg.RxStream;
#endif /* RACTRL_FW_OFFLOAD_SUPPORT */

	if (is_ru26_disable_channel(pAd, chan_oper->prim_ch, bss_info->ucPhyMode))
		pBssInfoRLM->ucHetbRU26Disable = TRUE;
	else
		pBssInfoRLM->ucHetbRU26Disable = FALSE;

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			 "ucPrimaryChannel = %d, ucCenterChannelSeg0 = %d, ucCenterChannelSeg1 = %d, ucBandwidth = %d, ucTxStream = %d, ucRxStream = %d, ucHetbRU26Disable = %d\n",
			  pBssInfoRLM->ucPrimaryChannel,
			  pBssInfoRLM->ucCenterChannelSeg0,
			  pBssInfoRLM->ucCenterChannelSeg1,
			  pBssInfoRLM->ucBandwidth,
			  pBssInfoRLM->ucTxStream,
			  pBssInfoRLM->ucRxStream,
			  pBssInfoRLM->ucHetbRU26Disable);

	return Ret;
}

static INT32 UniCmdBssInfoProtect(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_PROT_T pBssInfoProt = (P_UNI_CMD_BSSINFO_PROT_T)pHandle;
	struct prot_info *prot = &bss_info->prot;

	/* Fill TLV format */
	pBssInfoProt->u2Tag = UNI_CMD_BSSINFO_PROTECT;
	pBssInfoProt->u2Length = sizeof(UNI_CMD_BSSINFO_PROT_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoProt->u2Tag = cpu2le16(pBssInfoProt->u2Tag);
	pBssInfoProt->u2Length = cpu2le16(pBssInfoProt->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoProt->u4ProtectMode = cpu2le32(prot->cookie.protect_mode);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
				"Bssid("MACSTR") pBssInfoProt->u4ProtectMode=%d.\n",
				MAC2STR(bss_info->Bssid), pBssInfoProt->u4ProtectMode);
	return Ret;
}

#ifdef DOT11_HE_AX
static INT32 UniCmdBssInfoBSSColor(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BSS_COLOR_T pBssInfoBssColor = (P_UNI_CMD_BSSINFO_BSS_COLOR_T)pHandle;
	struct bss_color_ctrl *bss_color = &bss_info->bss_color;

	/* Fill TLV format */
	pBssInfoBssColor->u2Tag = UNI_CMD_BSSINFO_BSS_COLOR;
	pBssInfoBssColor->u2Length = sizeof(UNI_CMD_BSSINFO_BSS_COLOR_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBssColor->u2Tag = cpu2le16(pBssInfoBssColor->u2Tag);
	pBssInfoBssColor->u2Length = cpu2le16(pBssInfoBssColor->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoBssColor->fgEnable = (bss_color->disabled == TRUE) ? FALSE : TRUE;
	pBssInfoBssColor->ucBssColor = bss_color->color;

	return Ret;
}

static INT32 UniCmdBssInfoHEBasic(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_HE_T pBssInfoHE = (P_UNI_CMD_BSSINFO_HE_T)pHandle;
	struct he_mcs_info *mcs = &bss_info->he_bss.max_nss_mcs;
	UINT32  i = 0;

	/* Fill TLV format */
	pBssInfoHE->u2Tag = UNI_CMD_BSSINFO_HE;
	pBssInfoHE->u2Length = sizeof(UNI_CMD_BSSINFO_HE_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoHE->u2Tag = cpu2le16(pBssInfoHE->u2Tag);
	pBssInfoHE->u2Length = cpu2le16(pBssInfoHE->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoHE->u2TxopDurationRtsThreshold = cpu2le16(bss_info->he_bss.txop_dur_rts_thr);
	pBssInfoHE->ucDefaultPEDuration = bss_info->he_bss.default_pe_dur;
	for (i = 0 ; i < HE_MAX_SUPPORT_STREAM; i++) {
		pBssInfoHE->au2MaxNssMcs[CMD_HE_MCS_BW80] |= (mcs->bw80_mcs[i] << (i * 2));
		pBssInfoHE->au2MaxNssMcs[CMD_HE_MCS_BW160] |= (mcs->bw160_mcs[i] << (i * 2));
		pBssInfoHE->au2MaxNssMcs[CMD_HE_MCS_BW8080] |= (mcs->bw8080_mcs[i] << (i * 2));
	}

	for (i = 0 ; i < CMD_HE_MCS_BW_NUM; i++)
		pBssInfoHE->au2MaxNssMcs[i] = cpu2le16(pBssInfoHE->au2MaxNssMcs[i]);

	return Ret;
}
#endif /* DOT11_HE_AX */

#ifdef DOT11V_MBSSID_SUPPORT
static INT32 UniCmdBssInfo11vMBSSID(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_11V_MBSSID_T pBssInfo11vMbssid = (P_UNI_CMD_BSSINFO_11V_MBSSID_T)pHandle;
	struct wifi_dev *wdev = bss_info->priv;
#ifdef CONFIG_AP_SUPPORT
	struct _BSS_STRUCT *bss = NULL, *t_bss = NULL;

	if (wdev && (wdev->wdev_type == WDEV_TYPE_AP))
		bss = wdev->func_dev;
#endif /* CONFIG_AP_SUPPORT */

	/* Fill TLV format */
	pBssInfo11vMbssid->u2Tag = UNI_CMD_BSSINFO_11V_MBSSID;
	pBssInfo11vMbssid->u2Length = sizeof(UNI_CMD_BSSINFO_11V_MBSSID_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfo11vMbssid->u2Tag = cpu2le16(pBssInfo11vMbssid->u2Tag);
	pBssInfo11vMbssid->u2Length = cpu2le16(pBssInfo11vMbssid->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfo11vMbssid->ucMaxBSSIDIndicator = 0;
	pBssInfo11vMbssid->ucMBSSIDIndex = 0;
	pBssInfo11vMbssid->ucTxBssOwnMacIdx = 0; /* uesless for STA */

	if (bss_info->bss_state >= BSS_ACTIVE) {
		/* link up case */
#ifdef CONFIG_AP_SUPPORT
		if (bss && (wdev->wdev_type == WDEV_TYPE_AP)) {
			/* for AP role */
			struct mbss_11v_ctrl *mbss_11v_ctrl = &bss->mbss_11v;

			t_bss = mbss_11v_ctrl->mbss_11v_t_bss;
			if (t_bss) {
				OS_SEM_LOCK(&t_bss->mbss_11v.mbss_11v_ctrl_lock);
				pBssInfo11vMbssid->ucMaxBSSIDIndicator =
					t_bss->mbss_11v.mbss_11v_max_bssid_indicator;
				OS_SEM_UNLOCK(&t_bss->mbss_11v.mbss_11v_ctrl_lock);
			}
			if (bss->mbss_idx >= mbss_11v_ctrl->mbss_11v_t_bss_idx) {
				pBssInfo11vMbssid->ucMBSSIDIndex =
					(bss->mbss_idx - mbss_11v_ctrl->mbss_11v_t_bss_idx);
				if (t_bss)
					pBssInfo11vMbssid->ucTxBssOwnMacIdx = t_bss->wdev.OmacIdx;
			}
		} else
#endif /* CONFIG_AP_SUPPORT */
			if (wdev && (wdev->wdev_type == WDEV_TYPE_STA)) {
				/* for STA role , info get from scan table */
				pBssInfo11vMbssid->ucMaxBSSIDIndicator = bss_info->max_bssid_indicator;
				pBssInfo11vMbssid->ucMBSSIDIndex = bss_info->mbssid_index;
			}
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_NOTICE,
		"BSSID(%pM): MaxBSSIDIndicator(%d),MBSSIDIndex(%d),TxBssOwnMacIdx(0x%02x)\n",
		bss_info->Bssid,
		pBssInfo11vMbssid->ucMaxBSSIDIndicator,
		pBssInfo11vMbssid->ucMBSSIDIndex,
		pBssInfo11vMbssid->ucTxBssOwnMacIdx);
	return Ret;
}
#endif /* DOT11V_MBSSID_SUPPORT */

#ifdef CONFIG_AP_SUPPORT
static INT32 UniCmdBssInfoBcnContent(
	struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BCN_CONTENT_T pBssInfoBcnContent = (P_UNI_CMD_BSSINFO_BCN_CONTENT_T)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	PBCN_BUF_STRUCT bcn_buf = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (wdev)
		bcn_buf = &wdev->bcn_buf;

	/* Fill TLV format */
	pBssInfoBcnContent->u2Tag = UNI_CMD_BSSINFO_BCN_CONTENT;
	pBssInfoBcnContent->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_CONTENT_T);
	if (bcn_buf == NULL)
		return NDIS_STATUS_FAILURE;
	if ((bcn_buf->bBcnSntReq == TRUE) && (bcn_buf->BeaconPkt) && !(bcn_buf->stop_tx & STOP_BCN_TX_NO_BCN))
		pBssInfoBcnContent->u2Length += (cap->tx_hw_hdr_len + bcn_buf->FrameLen);

	/* u2Length  need to 4-byte alignment with WM's sanity */
	if (pBssInfoBcnContent->u2Length % 4 != 0)
		pBssInfoBcnContent->u2Length = (pBssInfoBcnContent->u2Length + 3) & (~0x3);

#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnContent->u2Tag = cpu2le16(pBssInfoBcnContent->u2Tag);
	pBssInfoBcnContent->u2Length = cpu2le16(pBssInfoBcnContent->u2Length);
#endif /* CFG_BIG_ENDIAN */

	if ((bcn_buf->bBcnSntReq == TRUE) && (bcn_buf->BeaconPkt) && !(bcn_buf->stop_tx & STOP_BCN_TX_NO_BCN)) {
		pBssInfoBcnContent->ucAction = BCN_ACTION_ENABLE;
		pBssInfoBcnContent->u2TimIeOffset = cpu2le16(bcn_buf->tim_ie_offset);
		pBssInfoBcnContent->u2CsaIeOffset = cpu2le16(bcn_buf->CsaIELocationInBeacon);
#ifdef DOT11_HE_AX
		pBssInfoBcnContent->u2BccIeOffset = cpu2le16(bcn_buf->bcc_ie_location);
#endif
		/* thes aucPktContent field include TXD,
		 * MAC header and payload
		 */
		pBssInfoBcnContent->aucPktContentType = 0;
		pBssInfoBcnContent->u2PktLength = cpu2le16(cap->tx_hw_hdr_len + bcn_buf->FrameLen);
		pBssInfoBcnContent->u2TimIeOffset = cpu2le16(pBssInfoBcnContent->u2TimIeOffset);
		pBssInfoBcnContent->u2CsaIeOffset = cpu2le16(pBssInfoBcnContent->u2CsaIeOffset);
		pBssInfoBcnContent->u2BccIeOffset = cpu2le16(pBssInfoBcnContent->u2BccIeOffset);
		pBssInfoBcnContent->u2PktLength = cpu2le16(pBssInfoBcnContent->u2PktLength);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			"BSS(%d), BcnLength = %d, IE offset(TIM/CSA/BCC) = %d/%d/%d\n",
			bss_info->ucBssIndex,
			le2cpu16(pBssInfoBcnContent->u2PktLength),
			le2cpu16(pBssInfoBcnContent->u2TimIeOffset),
			le2cpu16(pBssInfoBcnContent->u2CsaIeOffset),
			le2cpu16(pBssInfoBcnContent->u2BccIeOffset));
		hex_dump_with_cat_and_lvl("BCN", (char *)GET_OS_PKT_DATAPTR(bcn_buf->BeaconPkt),
			bcn_buf->FrameLen, DBG_CAT_AP, CATAP_MBSS, DBG_LVL_DEBUG);

		os_move_mem(pBssInfoBcnContent->aucPktContent, (char *)GET_OS_PKT_DATAPTR(bcn_buf->BeaconPkt),
					(cap->tx_hw_hdr_len + bcn_buf->FrameLen));
	} else {
		pBssInfoBcnContent->ucAction = BCN_ACTION_DISABLE;
	}

	return Ret;
}

static INT32 UniCmdBssInfoBcnCSA(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BCN_CSA_T pBssInfoBcnCSA = (P_UNI_CMD_BSSINFO_BCN_CSA_T)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;

	if (!wdev) {
		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_ERROR, "wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	if (BCN_REASON_EQUAL(bss_info->bUpdateReason, BCN_UPDATE_CSA)
#ifdef DOT11_EHT_BE
		|| (IS_BCN_CRIT_UPD(bss_info->bUpdateReason)
			&& wdev->csa_count != 0)
		|| wlan_config_get_eht_csa_dscb_enable(wdev)
#endif
		) {

		/* Fill TLV format */
		pBssInfoBcnCSA->u2Tag = UNI_CMD_BSSINFO_BCN_CSA;
		pBssInfoBcnCSA->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_CSA_T);
#ifdef CFG_BIG_ENDIAN
		pBssInfoBcnCSA->u2Tag = cpu2le16(pBssInfoBcnCSA->u2Tag);
		pBssInfoBcnCSA->u2Length = cpu2le16(pBssInfoBcnCSA->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pBssInfoBcnCSA->ucCsaCount = wdev->csa_count;
		pBssInfoBcnCSA->fgStaticPunctureCsa = 0;
#ifdef DOT11_EHT_BE
		pBssInfoBcnCSA->fgStaticPunctureCsa = wlan_config_get_eht_csa_dscb_enable(wdev);
		if (pBssInfoBcnCSA->fgStaticPunctureCsa)
			pBssInfoBcnCSA->ucCsaCount = 10; // Added CSA count for PP CSA
#endif
		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_NOTICE,
			"BSS(%d),Reason(%d),CsaCount(%d)\n",
			bss_info->ucBssIndex, bss_info->bUpdateReason, wdev->csa_count);

		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_NOTICE,
			"PP CSA cmd to FW, u2Tag=%d, u2Length=%d, ucCsaCount=%d, fgStaticPunctureCsa=%d\n",
			pBssInfoBcnCSA->u2Tag, pBssInfoBcnCSA->u2Length, pBssInfoBcnCSA->ucCsaCount, pBssInfoBcnCSA->fgStaticPunctureCsa);

		return Ret;
	} else
		return NDIS_STATUS_FAILURE;

}

#ifdef DOT11_EHT_BE
static INT32 UniCmdBssInfoBcnMloCSA(struct _RTMP_ADAPTER *pAd,
	BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BCN_MLO_CSA_T pBssInfoMloCSA =
		(P_UNI_CMD_BSSINFO_BCN_MLO_CSA_T)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;

	if (!wdev) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	if (IS_BCN_CRIT_UPD(bss_info->bUpdateReason)
			&& (wdev->bcn_buf.csa.ml_csa_ie_offset != 0)) {

		/* Fill TLV format */
		pBssInfoMloCSA->u2Tag = UNI_CMD_BSSINFO_BCN_MLO_CSA;
		pBssInfoMloCSA->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_MLO_CSA_T);
#ifdef CFG_BIG_ENDIAN
		pBssInfoMloCSA->u2Tag = cpu2le16(pBssInfoMloCSA->u2Tag);
		pBssInfoMloCSA->u2Length = cpu2le16(pBssInfoMloCSA->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pBssInfoMloCSA->ucMloCsaBssIdx = wdev->bcn_buf.csa.csa_bss_idx;
		pBssInfoMloCSA->u2MloCsaIeOffset = wdev->bcn_buf.csa.ml_csa_ie_offset;

		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_NOTICE,
			"BSS(%d),Reason(%d),CsaCount(%d),ml_csa_ie_offset(%d),ml_bss_idx(%d)\n",
			bss_info->ucBssIndex, bss_info->bUpdateReason, wdev->csa_count,
			wdev->bcn_buf.csa.ml_csa_ie_offset, wdev->bcn_buf.csa.csa_bss_idx);

		return Ret;
	} else
		return NDIS_STATUS_FAILURE;

}
#endif

#ifdef DOT11_HE_AX
static INT32 UniCmdBssInfoBcnBCC(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BCN_BCC_T pBssInfoBcnBCC = (P_UNI_CMD_BSSINFO_BCN_BCC_T)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	struct bss_color_ctrl *bss_color = &bss_info->bss_color;

	if (!wdev) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	if (wdev->bcn_buf.bcc_ie_location == 0)
		return NDIS_STATUS_FAILURE;

	/* Fill TLV format */
	pBssInfoBcnBCC->u2Tag = UNI_CMD_BSSINFO_BCN_BCC;
	pBssInfoBcnBCC->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_BCC_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnBCC->u2Tag = cpu2le16(pBssInfoBcnBCC->u2Tag);
	pBssInfoBcnBCC->u2Length = cpu2le16(pBssInfoBcnBCC->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoBcnBCC->ucBccCount = bss_color->u.ap_ctrl.bcc_count;

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO, "BSS(%d), BccCount = %d\n",
			bss_info->ucBssIndex, bss_color->u.ap_ctrl.bcc_count);

	return Ret;
}
#endif /* DOT11_HE_AX */

#ifdef DOT11V_MBSSID_SUPPORT
static INT32 UniCmdBssInfoBcnMBSSID(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BSSINFO_BCN_MBSSID_T pBssInfoBcnMBSSID = (P_UNI_CMD_BSSINFO_BCN_MBSSID_T)pHandle;
	BSS_STRUCT *pMbss = NULL;
	INT32 IdBss, t_bss_idx;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;

	if (IS_BSSID_11V_ENABLED(pAd) == FALSE)
		return NDIS_STATUS_FAILURE;

	if (wdev == NULL) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}
	pMbss = (struct _BSS_STRUCT *)wdev->func_dev;
	if (pMbss == NULL) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_ERROR,
			"pMbss is NULL\n");
		return NDIS_STATUS_FAILURE;
	}
	if (IS_BSSID_11V_NON_TRANS(&pMbss->mbss_11v)) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_WARN,
			"NT-BSS, no need to send this cmd.\n");
		return NDIS_STATUS_FAILURE;
	}
	t_bss_idx = pMbss->mbss_11v.mbss_11v_t_bss_idx;
	/* Fill TLV format */
	pBssInfoBcnMBSSID->u2Tag = UNI_CMD_BSSINFO_BCN_MBSSID;
	pBssInfoBcnMBSSID->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_MBSSID_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnMBSSID->u2Tag = cpu2le16(pBssInfoBcnMBSSID->u2Tag);
	pBssInfoBcnMBSSID->u2Length = cpu2le16(pBssInfoBcnMBSSID->u2Length);
#endif /* CFG_BIG_ENDIAN */

	for (IdBss = MAIN_MBSSID; IdBss < pAd->ApCfg.BssidNum; IdBss++) {
		u8 dot11v_mbssid_idx = 0;

		pMbss = &pAd->ApCfg.MBSSID[IdBss];
		if (pMbss->mbss_11v.mbss_11v_t_bss_idx != t_bss_idx)
			continue;
		MTWF_DBG(NULL, DBG_CAT_FW, CATAP_11V_MBSS, DBG_LVL_INFO,
			"BSS(%d), IE Offset = %d\n",
			IdBss, pMbss->wdev.bcn_buf.tim_ie_offset);

		/* use global 11v mbssid bitmap, and map to per tx group's bitmap */
		if (pAd->ApCfg.dot11v_mbssid_bitmap & (1 << pMbss->mbss_idx)) {
			if (pMbss->mbss_11v.mbss_11v_enable == MBSS_11V_NT) {
				if (pMbss->mbss_idx >= t_bss_idx)
					dot11v_mbssid_idx = (pMbss->mbss_idx - t_bss_idx);
				pBssInfoBcnMBSSID->u4Dot11vMbssidBitmap |= (1 << dot11v_mbssid_idx);
			} else if (pMbss->mbss_11v.mbss_11v_enable == MBSS_11V_T) {
				pBssInfoBcnMBSSID->u4Dot11vMbssidBitmap |= (1 << 0);
			}
		}

		pBssInfoBcnMBSSID->u2MbssidIeOffset[dot11v_mbssid_idx] =
			cpu2le16(pMbss->wdev.bcn_buf.tim_ie_offset);
	}

	MTWF_DBG(NULL, DBG_CAT_FW, CATAP_11V_MBSS, DBG_LVL_INFO,
		"u4Dot11vMbssidBitmap=0x%08x\n",
		pBssInfoBcnMBSSID->u4Dot11vMbssidBitmap);

	pBssInfoBcnMBSSID->u4Dot11vMbssidBitmap = cpu2le32(pBssInfoBcnMBSSID->u4Dot11vMbssidBitmap);

	return Ret;
}

static INT32 UniCmdBssInfoBcnMLT(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BSSINFO_BCN_MLT_T *pBssInfoBcnMLT = (struct UNI_CMD_BSSINFO_BCN_MLT_T *)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	BSS_STRUCT *pMbss = NULL;
	INT32 IdBss, t_bss_idx;

	if (wdev == NULL) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}
	pMbss = (struct _BSS_STRUCT *)wdev->func_dev;
	if (pMbss == NULL) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_ERROR,
			"pMbss is NULL\n");
		return NDIS_STATUS_FAILURE;
	}
	if (IS_BSSID_11V_NON_TRANS(&pMbss->mbss_11v)) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_11V_MBSS, DBG_LVL_WARN,
			"NT-BSS, no need to send this cmd.\n");
		return NDIS_STATUS_FAILURE;
	}
	t_bss_idx = pMbss->mbss_11v.mbss_11v_t_bss_idx;
	/* Fill TLV format */
	pBssInfoBcnMLT->u2Tag = UNI_CMD_BSSINFO_BCN_MLT;
	pBssInfoBcnMLT->u2Length = sizeof(struct UNI_CMD_BSSINFO_BCN_MLT_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnMLT->u2Tag = cpu2le16(pBssInfoBcnMLT->u2Tag);
	pBssInfoBcnMLT->u2Length = cpu2le16(pBssInfoBcnMLT->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* legacy or 11v MBSS T*/
	pBssInfoBcnMLT->u2MltIeOffset = wdev->bcn_buf.mlt_ie_offset;
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
		"wdev(%s), IE Offset = %d\n",
		wdev->if_dev->name, pBssInfoBcnMLT->u2MltIeOffset);

	/* 11v MBSS NT */
	if (IS_BSSID_11V_ENABLED(pAd)) {
		for (IdBss = MAIN_MBSSID; IdBss < pAd->ApCfg.BssidNum; IdBss++) {
			pMbss = &pAd->ApCfg.MBSSID[IdBss];
			if (pMbss->mbss_11v.mbss_11v_t_bss_idx != t_bss_idx)
				continue;
			MTWF_DBG(pAd, DBG_CAT_FW, CATAP_11V_MBSS, DBG_LVL_INFO,
				"BSS(%d), wdev(%s), IE Offset=%d, mbss_idx=%d\n",
				IdBss,
				pMbss->wdev.if_dev->name,
				pMbss->wdev.bcn_buf.mlt_ie_offset,
				pMbss->mbss_idx);

			pBssInfoBcnMLT->u2MbssidMltIeOffset[IdBss] =
				cpu2le16(pMbss->wdev.bcn_buf.mlt_ie_offset);

			/* build global 11v mbssid bitmap */
			if (pAd->ApCfg.dot11v_mbssid_bitmap & (1 << pMbss->mbss_idx))
				pBssInfoBcnMLT->u4Dot11vMbssidBitmap |= (1 << IdBss);
		}
		pBssInfoBcnMLT->u4Dot11vMbssidBitmap = cpu2le32(pBssInfoBcnMLT->u4Dot11vMbssidBitmap);
	}

	return Ret;
}
#endif /* DOT11V_MBSSID_SUPPORT */

#ifdef DOT11_HE_AX
#ifdef WIFI_TWT_SUPPORT
static INT32 UniCmdBssInfoBcnOffloadBTWT(
	struct _RTMP_ADAPTER *pAd,
	BSS_INFO_ARGUMENT_T *bss_info,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	struct UNI_CMD_BSSINFO_BCN_BTWT_T *pBssInfoBcnOffloadBTWT =
							(struct UNI_CMD_BSSINFO_BCN_BTWT_T *)pHandle;
	struct BTWT_BUF_STRUCT *btwt = NULL;
	UINT8 band = BAND0;

	if (!wdev) {
		MTWF_DBG(pAd, DBG_CAT_AP, CATAP_BCN, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	band = HcGetBandByWdev(wdev);
	btwt = &pAd->ApCfg.btwt;
	if (btwt->btwt_element_exist && btwt->btwt_bcn_offset) {
		pBssInfoBcnOffloadBTWT->u2Tag = UNI_CMD_BSSINFO_BCN_BTWT;
		pBssInfoBcnOffloadBTWT->u2Length = sizeof(struct UNI_CMD_BSSINFO_BCN_BTWT_T);
#ifdef CFG_BIG_ENDIAN
		pBssInfoBcnOffloadBTWT->u2Tag = cpu2le16(pBssInfoBcnOffloadBTWT->u2Tag);
		pBssInfoBcnOffloadBTWT->u2Length = cpu2le16(pBssInfoBcnOffloadBTWT->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pBssInfoBcnOffloadBTWT->u2BTWTIeOffset = cpu2le16(btwt->btwt_bcn_offset);

		MTWF_DBG(pAd, DBG_CAT_AP, CATAP_BCN, DBG_LVL_DEBUG,
			"Band(%d), BSS(%d), bTWT offset = %d\n",
			band, bss_info->ucBssIndex, btwt->btwt_bcn_offset);
	} else {
		Ret = NDIS_STATUS_FAILURE;
	}

	return Ret;
}
#endif /* WIFI_TWT_SUPPORT */
#endif /* DOT11_HE_AX */

#ifdef DOT11_EHT_BE
/* Bss Parameter Critical Update */
static INT32 UniCmdBssInfoBcnCritUpd(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T *pBssInfoBcnCritUpd = (struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T *)pHandle;
	BSS_STRUCT *pMbss = NULL;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	INT32 IdBss;

	if (!wdev) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	/* flag not be set or bitmap is 0 */
	if (!wdev->bcn_buf.cu_info.crit_upd_flag || !wdev->bcn_buf.cu_info.crit_upd_bitmap)
		return NDIS_STATUS_FAILURE;

	/* reset the flag */
	wdev->bcn_buf.cu_info.crit_upd_flag = FALSE;

	/* Fill TLV format */
	pBssInfoBcnCritUpd->u2Tag = UNI_CMD_BSSINFO_BCN_CRIT_UPD;
	pBssInfoBcnCritUpd->u2Length = sizeof(struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnCritUpd->u2Tag = cpu2le16(pBssInfoBcnCritUpd->u2Tag);
	pBssInfoBcnCritUpd->u2Length = cpu2le16(pBssInfoBcnCritUpd->u2Length);
#endif /* CFG_BIG_ENDIAN */

	for (IdBss = MAIN_MBSSID; IdBss < pAd->ApCfg.BssidNum; IdBss++) {
		pMbss = &pAd->ApCfg.MBSSID[IdBss];
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			"BSS(%d), TIM IE Offset = %d, Cap Info Offset = %d\n",
			IdBss, pMbss->wdev.bcn_buf.tim_ie_offset,
			pMbss->wdev.bcn_buf.cap_ie_pos);

		pBssInfoBcnCritUpd->u2TimIeOffset[IdBss] =
			cpu2le16(pMbss->wdev.bcn_buf.tim_ie_offset);
		pBssInfoBcnCritUpd->u2CapInfoOffset[IdBss] =
			cpu2le16(pMbss->wdev.bcn_buf.cap_ie_pos);
	}
	pBssInfoBcnCritUpd->u4UpdatedBSSBitmap = cpu2le32(wdev->bcn_buf.cu_info.crit_upd_bitmap);
	pBssInfoBcnCritUpd->u4BypassSeqHandleBmap =
		cpu2le32(wdev->bcn_buf.cu_info.bypass_bcn_seq_bmap);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
		"Updated BSS Bitmap=%d, Bypass=0x%x\n",
		pBssInfoBcnCritUpd->u4UpdatedBSSBitmap,
		pBssInfoBcnCritUpd->u4BypassSeqHandleBmap);

	/* reset bitmap */
	wdev->bcn_buf.cu_info.crit_upd_bitmap = 0;
	wdev->bcn_buf.cu_info.bypass_bcn_seq_bmap = 0;

	return Ret;
}

/* BCN Reconfiguration Multi-Link IE AP Removal Timer update */
/**
 * @AP Removal Timer offset (in Reconfiguration multi-link IE) in BCN
 *
 * @param *pAd _RTMP_ADAPTER
 * @param *bss_info BSS_INFO_ARGUMENT_T
 * @param *pHandle AP Removal Timer offset in BCN
 *        ucOffsetNum: number of Timer offset
 *        aucOffsetInfo: UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T
 */
static INT32 UniCmdBssInfoBcnReconfigTmr(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T *pBssInfoBcnReconf =
		(struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T *)pHandle;
	struct UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T *offset_info;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	struct reconf_ie_info_t *reconfig_ie_info = NULL;
	u8 offset_idx, sub_size = sizeof(struct UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T);

	if (!wdev) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
			"wdev is NULL\n");
		return NDIS_STATUS_FAILURE;
	}

	reconfig_ie_info = &wdev->bcn_buf.reconf_info;
	if (!reconfig_ie_info || !reconfig_ie_info->num_offset) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_DEBUG,
			"Invalid reconf_info!\n");
		return NDIS_STATUS_FAILURE;
	}

	pBssInfoBcnReconf->u2Tag = UNI_CMD_BSSINFO_BCN_RECONFIG_ML;
	pBssInfoBcnReconf->u2Length = sizeof(struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T);
	pBssInfoBcnReconf->u2Length += (sub_size * reconfig_ie_info->num_offset);
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG,
		"extra size: %d\n", sub_size * reconfig_ie_info->num_offset);
	pBssInfoBcnReconf->u2Tag = cpu2le16(pBssInfoBcnReconf->u2Tag);
	pBssInfoBcnReconf->u2Length = cpu2le16(pBssInfoBcnReconf->u2Length);

	pBssInfoBcnReconf->ucOffsetNum = reconfig_ie_info->num_offset;

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG,
		"wdev(%s): num_off=0x%x\n", wdev->if_dev->name, pBssInfoBcnReconf->ucOffsetNum);

	offset_info = (struct UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T *)
		pBssInfoBcnReconf->aucOffsetInfo;
	for (offset_idx = 0; offset_idx < reconfig_ie_info->num_offset; offset_idx++) {
		offset_info->ucBssIdx = reconfig_ie_info->sub_info[offset_idx].fw_bss_idx;
		offset_info->u2ApRmTmrOffset = cpu2le16(reconfig_ie_info->sub_info[offset_idx].tmr_offset);

		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG,
			"offset[%d]=%d for fw_bss %d\n", offset_idx,
			le2cpu16(offset_info->u2ApRmTmrOffset),
			offset_info->ucBssIdx);

		offset_info++;
	}

	hex_dump_with_cat_and_lvl("UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T raw data",
		(u8 *)pHandle, le2cpu16(pBssInfoBcnReconf->u2Length),
		DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG);

	return Ret;
}

/**
 * @AT2LM IE offset in BCN
 *
 * @param *pAd _RTMP_ADAPTER
 * @param *bss_info BSS_INFO_ARGUMENT_T
 * @param *pHandle AT2LM IE offset in BCN
 *        ucVldIdBitmap: valid at2lm_id in bitmap format
 *        u2T2lmIeOffset: bcn offset of at2lm_ie of at2lm_id
 */
static INT32 UniCmdBssInfoBcnAt2lm(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BSSINFO_BCN_AT2LM_T *pBssInfoBcnAt2lm = (struct UNI_CMD_BSSINFO_BCN_AT2LM_T *)pHandle;
	struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
	struct at2lm_ie_info_t *at2lm_info = NULL;
	UINT8 at2lm_id = 0;

	if (!wdev)
		return NDIS_STATUS_FAILURE;

	at2lm_info = &wdev->bcn_buf.at2lm_info;
	if (!at2lm_info->vld_id)
		return NDIS_STATUS_FAILURE;

	pBssInfoBcnAt2lm->u2Tag = UNI_CMD_BSSINFO_BCN_AT2LM;
	pBssInfoBcnAt2lm->u2Length = sizeof(struct UNI_CMD_BSSINFO_BCN_AT2LM_T);
	pBssInfoBcnAt2lm->u2Tag = cpu2le16(pBssInfoBcnAt2lm->u2Tag);
	pBssInfoBcnAt2lm->u2Length = cpu2le16(pBssInfoBcnAt2lm->u2Length);
	pBssInfoBcnAt2lm->ucVldIdBitmap = at2lm_info->vld_id;

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_DEBUG,
		"wdev(%s): vld_id_bitmap=0x%x\n", wdev->if_dev->name, at2lm_info->vld_id);

	for (at2lm_id = 0; at2lm_id < BSS_MNGR_MAX_AT2LM_SET_NUM; at2lm_id++) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_DEBUG,
			"ie_offset[%d]=%d\n", at2lm_id, at2lm_info->ie_offset[at2lm_id]);
		pBssInfoBcnAt2lm->u2T2lmIeOffset[at2lm_id] =
			cpu2le16(at2lm_info->ie_offset[at2lm_id]);
	}

	return Ret;
}
#endif /* DOT11_EHT_BE */

static INT32 UniCmdBssInfoBcnOffloadWrapAll(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, UINT32 *offset, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PUCHAR	pTempBuf = (PUCHAR)pHandle;

	*offset = 0;
	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_BCN, DBG_LVL_INFO,
		"BSS(%d),UpdateReason(%d)\n",
		bss_info->ucBssIndex, bss_info->bUpdateReason);

	Ret = UniCmdBssInfoBcnCSA(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_BCN_CSA_T);
		*offset += sizeof(UNI_CMD_BSSINFO_BCN_CSA_T);
	}

#ifdef DOT11_EHT_BE
	Ret = UniCmdBssInfoBcnMloCSA(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_BCN_MLO_CSA_T);
		*offset += sizeof(UNI_CMD_BSSINFO_BCN_MLO_CSA_T);
	}
#endif /* DOT11_EHT_BE */

#ifdef DOT11_HE_AX
	Ret = UniCmdBssInfoBcnBCC(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_BCN_BCC_T);
		*offset += sizeof(UNI_CMD_BSSINFO_BCN_BCC_T);
	}
#endif /* DOT11_HE_AX */

#ifdef DOT11V_MBSSID_SUPPORT
	Ret = UniCmdBssInfoBcnMBSSID(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(UNI_CMD_BSSINFO_BCN_MBSSID_T);
		*offset += sizeof(UNI_CMD_BSSINFO_BCN_MBSSID_T);
	}
#endif /* DOT11V_MBSSID_SUPPORT */

#ifdef DOT11_EHT_BE
	Ret = UniCmdBssInfoBcnMLT(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(struct UNI_CMD_BSSINFO_BCN_MLT_T);
		*offset += sizeof(struct UNI_CMD_BSSINFO_BCN_MLT_T);
	}

	Ret = UniCmdBssInfoBcnCritUpd(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T);
		*offset += sizeof(struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T);
	}

	Ret = UniCmdBssInfoBcnReconfigTmr(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T *pBssInfoBcnReconf =
			(struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T *)pTempBuf;
		pTempBuf += le2cpu16(pBssInfoBcnReconf->u2Length);
		*offset += le2cpu16(pBssInfoBcnReconf->u2Length);
	}

	Ret = UniCmdBssInfoBcnAt2lm(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		pTempBuf += sizeof(struct UNI_CMD_BSSINFO_BCN_AT2LM_T);
		*offset += sizeof(struct UNI_CMD_BSSINFO_BCN_AT2LM_T);
	}
#endif /* DOT11_EHT_BE */

	Ret = UniCmdBssInfoBcnContent(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		P_UNI_CMD_BSSINFO_BCN_CONTENT_T pBssInfoBcnContent =
					(P_UNI_CMD_BSSINFO_BCN_CONTENT_T)pTempBuf;
		pTempBuf += le2cpu16(pBssInfoBcnContent->u2Length);
		*offset += le2cpu16(pBssInfoBcnContent->u2Length);
	}

#ifdef DOT11_HE_AX
#ifdef WIFI_TWT_SUPPORT
	Ret = UniCmdBssInfoBcnOffloadBTWT(pAd, bss_info, pTempBuf);
	if (Ret == NDIS_STATUS_SUCCESS) {
		struct UNI_CMD_BSSINFO_BCN_BTWT_T *pBssInfoBcnOffloadBTWT =
					(struct UNI_CMD_BSSINFO_BCN_BTWT_T *)pTempBuf;
		pTempBuf += le2cpu16(pBssInfoBcnOffloadBTWT->u2Length);
		*offset += le2cpu16(pBssInfoBcnOffloadBTWT->u2Length);
	}
#endif /* WIFI_TWT_SUPPORT */
#endif /* DOT11_HE_AX */

	return (*offset > 0) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
}

#ifdef BCN_PROTECTION_SUPPORT
static INT32 UniCmdBssInfoBcnProt(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _RTMP_CHIP_CAP *chip_cap;
	P_UNI_CMD_BSSINFO_BCN_PROT_T pBssInfoBcnProt = {0};
	struct bcn_protection_cfg *bcn_prot_cfg = {0};
	struct wifi_dev *wdev = NULL;
	UCHAR tx_tsc[20];
	UINT32 pn_type_mask;
	UCHAR table_idx;

	pBssInfoBcnProt = (P_UNI_CMD_BSSINFO_BCN_PROT_T)pHandle;
	bcn_prot_cfg = &bss_info->bcn_prot_cfg;

	chip_cap = hc_get_chip_cap(pAd->hdev_ctrl);
	table_idx = get_bigtk_table_idx(bcn_prot_cfg);
	NdisZeroMemory(&tx_tsc, sizeof(tx_tsc));
	wdev = (struct wifi_dev *)bss_info->priv;
	if (!wdev)
		return -EINVAL;

	/* Fill TLV format */
	pBssInfoBcnProt->u2Tag = UNI_CMD_BSS_INFO_BCN_PROT;
	pBssInfoBcnProt->u2Length = sizeof(UNI_CMD_BSSINFO_BCN_PROT_T);
#ifdef CFG_BIG_ENDIAN
	pBssInfoBcnProt->u2Tag = cpu2le16(pBssInfoBcnProt->u2Tag);
	pBssInfoBcnProt->u2Length = cpu2le16(pBssInfoBcnProt->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBssInfoBcnProt->ucBcnProtEnabled = (bcn_prot_cfg->bcn_prot_en) ? chip_cap->bcn_prot_sup : BCN_PROT_EN_OFF;
#ifdef SOFT_BIP_GMAC
	if (IS_CIPHER_BIP_GMAC128(bcn_prot_cfg->bigtk_cipher) || IS_CIPHER_BIP_GMAC256(bcn_prot_cfg->bigtk_cipher))
		pBssInfoBcnProt->ucBcnProtEnabled = BCN_PROT_EN_SW_MODE;
#endif
	if (bcn_prot_cfg->show_bcn_prot_info)
		pBssInfoBcnProt->ucBcnProtEnabled = BCN_PROT_EN_SHOW_INFO;
	pBssInfoBcnProt->ucBcnProtKeyId = bcn_prot_cfg->bigtk_key_idx;
	if (IS_CIPHER_BIP_CMAC128(bcn_prot_cfg->bigtk_cipher))
		pBssInfoBcnProt->ucBcnProtCipherId = SEC_CIPHER_ID_BCN_PROT_CMAC_128;
	else if (IS_CIPHER_BIP_CMAC256(bcn_prot_cfg->bigtk_cipher))
		pBssInfoBcnProt->ucBcnProtCipherId = SEC_CIPHER_ID_BCN_PROT_CMAC_256;
	else if (IS_CIPHER_BIP_GMAC128(bcn_prot_cfg->bigtk_cipher))
		pBssInfoBcnProt->ucBcnProtCipherId = SEC_CIPHER_ID_BCN_PROT_GMAC_128;
	else if (IS_CIPHER_BIP_GMAC256(bcn_prot_cfg->bigtk_cipher))
		pBssInfoBcnProt->ucBcnProtCipherId = SEC_CIPHER_ID_BCN_PROT_GMAC_256;
	else {
		MTWF_DBG(pAd, DBG_CAT_SEC, CATSEC_BCNPROT, DBG_LVL_ERROR,
					 "not support bigtk cipher (0x%x), use default bip-cmac-128\n",
					 bcn_prot_cfg->bigtk_cipher);
		pBssInfoBcnProt->ucBcnProtCipherId = SEC_CIPHER_ID_BCN_PROT_CMAC_128;
	}
	if (bcn_prot_cfg->bcn_prot_en) {
		pn_type_mask = TSC_TYPE_BIGTK_PN_MASK;
		AsicGetTxTsc(pAd, wdev, pn_type_mask, tx_tsc);
	}

	tx_tsc[0]++;
	os_move_mem(&pBssInfoBcnProt->aucBcnProtKey, &bcn_prot_cfg->bigtk[table_idx][0], LEN_MAX_BIGTK);
	os_move_mem(&pBssInfoBcnProt->aucBcnProtPN, &tx_tsc, LEN_WPA_TSC);

	MTWF_DBG(NULL, DBG_CAT_SEC, CATSEC_BCNPROT, DBG_LVL_NOTICE,
		"Install BIGTK, BandIdx (%d), BssIndex (%d), ucBcnProtEnabled (%d), ucBcnProtCipherId(%d), ucBcnProtKeyId(%d)\n",
		bss_info->ucBandIdx, bss_info->ucBssIndex,
		pBssInfoBcnProt->ucBcnProtEnabled, pBssInfoBcnProt->ucBcnProtCipherId, pBssInfoBcnProt->ucBcnProtKeyId);

	return Ret;
}
#endif /* BCN_PROTECTION_SUPPORT */
#endif /* CONFIG_AP_SUPPORT */

static INT32 UniCmdBssInfoMld(struct _RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info, VOID *pHandle)
{
	int ret = NDIS_STATUS_SUCCESS;
	struct wifi_dev *wdev = NULL;
	struct bss_mld mld = {0};
	UCHAR mld_addr[MAC_ADDR_LEN] = {0};
	UINT8 mld_group_idx = 0;
	P_UNI_CMD_BSSINFO_MLD_T cmd = (P_UNI_CMD_BSSINFO_MLD_T)pHandle;

	wdev = (struct wifi_dev *)bss_info->priv;
	if (!wdev)
		return -EINVAL;

#ifdef DOT11_EHT_BE
	mld_group_idx = bss_info->mld_info.mld_group_idx;
	wlan_operate_get_mld_addr(wdev, mld_addr);
#else
	mld_group_idx = MLD_GROUP_NONE;
#endif
	ret = HcGetBssMld(wdev, &mld);
	if (ret)
		return ret;

	/* Fill TLV format */
	cmd->u2Tag = UNI_CMD_BSSINFO_MLD;
	cmd->u2Length = sizeof(struct _UNI_CMD_BSSINFO_MLD_T);
	if (mld_group_idx == MLD_GROUP_NONE) {
		cmd->ucGroupMldId = 0xff;
		cmd->ucOwnMldId = mld.mld_addr_idx;
		cmd->ucOmRemapIdx = OM_REMAP_IDX_NONE;
		NdisMoveMemory(cmd->aucOwnMldAddr, mld_addr, MAC_ADDR_LEN);
	} else {
		cmd->ucGroupMldId = mld.mld_group_addr_idx;
		cmd->ucOwnMldId = mld.mld_addr_idx;
		cmd->ucOmRemapIdx = mld.mld_remap_idx;
		NdisMoveMemory(cmd->aucOwnMldAddr, mld_addr, MAC_ADDR_LEN);
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_NOTICE,
		"if_addr(%pM),mld_group_idx=%d,T=%d,L=%d,GrpMldId=%d,MldIdx=%d,RemaIdx=%d,MldAddr=%pM\n",
		wdev->if_addr,
		mld_group_idx,
		cmd->u2Tag,
		cmd->u2Length,
		cmd->ucGroupMldId,
		cmd->ucOwnMldId,
		cmd->ucOmRemapIdx,
		cmd->aucOwnMldAddr);

	return ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdBssInfoTab[] = {
	{
		/* BSS_INFO_OWN_MAC_FEATURE is the same, so ignore it now. */
		.u8CmdFeature = BSS_INFO_BASIC_FEATURE,
		.u4StructSize = (sizeof(UNI_CMD_BSSINFO_BASIC_T) +
						 sizeof(UNI_CMD_BSSINFO_RATE_T) +
						 sizeof(UNI_CMD_BSSINFO_SEC_T) +
						 sizeof(UNI_CMD_BSSINFO_TXCMD_T)),
		.pfHandler = UniCmdBssInfoBasicWrapAll
	},
#ifdef RACTRL_FW_OFFLOAD_SUPPORT
	{
		.u8CmdFeature = BSS_INFO_RA_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_RA_T),
		.pfHandler = UniCmdBssInfoRA
	},
#endif /* RACTRL_FW_OFFLOAD_SUPPORT */
	{
		.u8CmdFeature = BSS_INFO_RF_CH_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_RLM_T),
		.pfHandler = UniCmdBssInfoRLM
	},
	{
		.u8CmdFeature = BSS_INFO_PROTECT_INFO_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_PROT_T),
		.pfHandler = UniCmdBssInfoProtect
	},
#ifdef DOT11_HE_AX
	{
		.u8CmdFeature = BSS_INFO_BSS_COLOR_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_BSS_COLOR_T),
		.pfHandler = UniCmdBssInfoBSSColor
	},
	{
		.u8CmdFeature = BSS_INFO_HE_BASIC_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_HE_T),
		.pfHandler = UniCmdBssInfoHEBasic
	},
#endif /* DOT11_HE_AX */
#ifdef DOT11V_MBSSID_SUPPORT
	{
		.u8CmdFeature = BSS_INFO_11V_MBSSID_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_11V_MBSSID_T),
		.pfHandler = UniCmdBssInfo11vMBSSID
	},
#endif /* DOT11V_MBSSID_SUPPORT */
#ifdef CONFIG_AP_SUPPORT
	{
		.u8CmdFeature = BSS_INFO_OFFLOAD_PKT_FEATURE,
		.u4StructSize = (sizeof(UNI_CMD_BSSINFO_BCN_CONTENT_T)
						 + sizeof(UNI_CMD_BSSINFO_BCN_CSA_T)
#ifdef DOT11_EHT_BE
						 + sizeof(UNI_CMD_BSSINFO_BCN_MLO_CSA_T)
#endif /* DOT11_EHT_BE */
						 + sizeof(UNI_CMD_BSSINFO_BCN_BCC_T)
#ifdef DOT11V_MBSSID_SUPPORT
						 + sizeof(UNI_CMD_BSSINFO_BCN_MBSSID_T)
#endif /* DOT11V_MBSSID_SUPPORT */
#ifdef DOT11_EHT_BE
						 + sizeof(struct UNI_CMD_BSSINFO_BCN_MLT_T)
						 + sizeof(struct UNI_CMD_BSSINFO_BCN_CRIT_UPD_T)
						 + sizeof(struct UNI_CMD_BSSINFO_BCN_RECONFIG_ML_T)
						 + sizeof(struct UNI_CMD_BSSINFO_BCN_AT2LM_T)
#endif /* DOT11_EHT_BE */
#ifdef DOT11_HE_AX
#ifdef WIFI_TWT_SUPPORT
						 + sizeof(struct UNI_CMD_BSSINFO_BCN_BTWT_T)
#endif /* WIFI_TWT_SUPPORT */
#endif /* DOT11_HE_AX */
						 ),
		.pfHandler = UniCmdBssInfoBcnOffloadWrapAll
	},
#endif /* CONFIG_AP_SUPPORT */
	{
		.u8CmdFeature = BSS_INFO_BROADCAST_INFO_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_RATE_T),
		.pfHandler = UniCmdBssInfoRate
	},
#ifdef CONFIG_AP_SUPPORT
#ifdef BCN_PROTECTION_SUPPORT
	{
		.u8CmdFeature = BSS_INFO_BCN_PROT_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_BCN_PROT_T),
		.pfHandler = UniCmdBssInfoBcnProt
	},
#endif /* BCN_PROTECTION_SUPPORT */
#endif /* CONFIG_AP_SUPPORT */
	{
		.u8CmdFeature = BSS_INFO_MLD_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_BSSINFO_MLD_T),
		.pfHandler = UniCmdBssInfoMld
	},
};

static UINT32 UniCmdBssInfoExtraAllocDynSizeCheck(RTMP_ADAPTER *pAd, BSS_INFO_ARGUMENT_T *bss_info)
{
	UINT32 i = 0;
	UINT32 BufSize = 0;
	UINT32 BssInfoTabSize = (sizeof(UniCmdBssInfoTab) / sizeof(UniCmdBssInfoTab[0]));

	for (i = 0; i < BssInfoTabSize; i++) {
		if (bss_info->u8BssInfoFeature & UniCmdBssInfoTab[i].u8CmdFeature) {
			if (UniCmdBssInfoTab[i].u8CmdFeature & BSS_INFO_OFFLOAD_PKT_FEATURE) {
				struct wifi_dev *wdev = (struct wifi_dev *)bss_info->priv;
				PBCN_BUF_STRUCT bcn_buf = NULL;
				RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

				if (!wdev)
					return BufSize;

				bcn_buf = &wdev->bcn_buf;
				if (bcn_buf && (bcn_buf->bBcnSntReq == TRUE) && (bcn_buf->BeaconPkt) && !(bcn_buf->stop_tx & STOP_BCN_TX_NO_BCN)) {
					BufSize += (cap->tx_hw_hdr_len + bcn_buf->FrameLen);

#ifdef DOT11_EHT_BE
					/* dynamic number of offsets for Reconfig Multi-Link IE */
					BufSize += (bcn_buf->reconf_info.num_offset *
						sizeof(struct UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T));
					MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG,
						"extra size for Reconfig ie in bcn %zu\n",
						bcn_buf->reconf_info.num_offset *
						sizeof(struct UNI_CMD_BSSINFO_RECONF_ML_OFFSET_INFO_T));
#endif
				}
			}
		}
	}

	return BufSize;
}

INT32 UniCmdBssInfoUpdate(
	RTMP_ADAPTER *pAd,
	BSS_INFO_ARGUMENT_T *bss_info)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	UINT32					u4Offset = 0;
	P_UNI_CMD_BSSINFO_T		pCmdBssInfoUpdate = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);
	UINT32 					BssInfoTabSize = (sizeof(UniCmdBssInfoTab) / sizeof(UniCmdBssInfoTab[0]));

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_BSSINFO_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < BssInfoTabSize; i++) {
		if (bss_info->u8BssInfoFeature & UniCmdBssInfoTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdBssInfoTab[i].u4StructSize;
	}
	u4CmdNeedMaxBufSize += UniCmdBssInfoExtraAllocDynSizeCheck(pAd, bss_info);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdBssInfoUpdate = (P_UNI_CMD_BSSINFO_T)pNextHeadBuf;
	pCmdBssInfoUpdate->ucBssInfoIdx = bss_info->ucBssIndex;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < BssInfoTabSize; i++) {
		switch (bss_info->u8BssInfoFeature & UniCmdBssInfoTab[i].u8CmdFeature) {
		case BSS_INFO_BASIC_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_BASIC_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, &u4Offset, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += u4Offset;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_RA_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_RA_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_RF_CH_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_RLM_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_PROTECT_INFO_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_PROT_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_BSS_COLOR_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_BSS_COLOR_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_HE_BASIC_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_HE_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_11V_MBSSID_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_11V_MBSSID_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_OFFLOAD_PKT_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_BCN_OFFLOAD_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, &u4Offset, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += u4Offset;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_BROADCAST_INFO_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_RATE_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_BCN_PROT_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_BCN_PROT_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case BSS_INFO_MLD_FEATURE:
			if (UniCmdBssInfoTab[i].pfHandler != NULL) {
				Ret = ((PFN_BSSINFO_MLD_HANDLE)(UniCmdBssInfoTab[i].pfHandler))(pAd, bss_info, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdBssInfoTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_SUCCESS;
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
				" The hanlder of tag (0x%llx) not support!\n", bss_info->u8BssInfoFeature);
			break;
		}

		if (Ret != NDIS_STATUS_SUCCESS)
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdBssInfoTab[i].u8CmdFeature);
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			"u8BssInfoFeature=0x%llx updatereason=%d, OwnMacIdx = %d, Band = %d, BssIndex = %d (%02x-%02x-%02x-%02x-%02x-%02x), TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			bss_info->u8BssInfoFeature, bss_info->bUpdateReason, bss_info->OwnMacIdx, bss_info->ucBandIdx, bss_info->ucBssIndex,
			PRINT_MAC(bss_info->Bssid), u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
					"!!!ERROR!!! u8BssInfoFeature=0x%llx updatereason=%d, OwnMacIdx = %d, Band = %d, BssIndex = %d (%02x-%02x-%02x-%02x-%02x-%02x), TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
					bss_info->u8BssInfoFeature, bss_info->bUpdateReason, bss_info->OwnMacIdx, bss_info->ucBandIdx, bss_info->ucBssIndex,
					PRINT_MAC(bss_info->Bssid), u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);
			ASSERT(0);

			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BSSINFO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			call_fw_cmd_notifieriers(WO_CMD_BSS_INFO, pAd, msg->net_pkt);
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

/*****************************************
 * BssInfo Power Save information (Tag 0x15)
 *****************************************/
INT32 MtUniCmdPmStateCtrl(struct _RTMP_ADAPTER *pAd, MT_PMSTAT_CTRL_T PmStatCtrl)
{
	struct cmd_msg *msg = NULL;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BSSINFO_T UniCmdBssInfo;
	UNI_CMD_BSSINFO_POWER_SAVE_T UniCmdBssInfoPowerSave;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	struct wifi_dev *wdev = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdBssInfo);
	os_zero_mem(&UniCmdBssInfo, u4ComCmdSize);
	os_zero_mem(&UniCmdBssInfoPowerSave, sizeof(UniCmdBssInfoPowerSave));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdBssInfoPowerSave);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BSSINFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	wdev = wdev_search_by_band_omac_idx(pAd, PmStatCtrl.DbdcIdx, PmStatCtrl.OwnMacIdx);
	if (!wdev) {
		AndesForceFreeCmdMsg(msg);
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	UniCmdBssInfo.ucBssInfoIdx = wdev->bss_info_argument.ucBssIndex;
	AndesAppendCmdMsg(msg, (char *)&UniCmdBssInfo, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdBssInfoPowerSave.u2Tag = UNI_CMD_BSSINFO_POWER_SAVE;
	UniCmdBssInfoPowerSave.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdBssInfoPowerSave.u2Tag = cpu2le16(UniCmdBssInfoPowerSave.u2Tag);
	UniCmdBssInfoPowerSave.u2Length = cpu2le16(UniCmdBssInfoPowerSave.u2Length);
#endif /* CFG_BIG_ENDIAN */
	if (PmStatCtrl.PmState == ENTER_PM_STATE)
		UniCmdBssInfoPowerSave.ucPsProfile = ENUM_PSP_CONTINUOUS_POWER_SAVE;
	else
		UniCmdBssInfoPowerSave.ucPsProfile = ENUM_PSP_CONTINUOUS_ACTIVE;
	AndesAppendCmdMsg(msg, (char *)&UniCmdBssInfoPowerSave, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
		"BssidIdx(%d),ucPsProfile(%d)\n",
		UniCmdBssInfo.ucBssInfoIdx, UniCmdBssInfoPowerSave.ucPsProfile);

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", ret);
	return ret;
}

/*****************************************
 * BssInfo IFS time information (Tag 0x17)
 *****************************************/
INT32 MtUniCmdSlotTimeSet(
	struct _RTMP_ADAPTER *pAd,
	UINT16 SlotTime,
	UINT16 SifsTime,
	UINT16 RifsTime,
	UINT16 EifsTime,
	struct wifi_dev *wdev)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BSSINFO_T UniCmdBssInfo;
	UNI_CMD_BSSINFO_IFS_TIME_T UniCmdBssInfoIFSTime;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdBssInfo);
	os_zero_mem(&UniCmdBssInfo, u4ComCmdSize);
	os_zero_mem(&UniCmdBssInfoIFSTime, sizeof(UniCmdBssInfoIFSTime));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdBssInfoIFSTime);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BSSINFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdBssInfo.ucBssInfoIdx = wdev->BssIdx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdBssInfo, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdBssInfoIFSTime.u2Tag = UNI_CMD_BSSINFO_IFS_TIME;
	UniCmdBssInfoIFSTime.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdBssInfoIFSTime.u2Tag = cpu2le16(UniCmdBssInfoIFSTime.u2Tag);
	UniCmdBssInfoIFSTime.u2Length = cpu2le16(UniCmdBssInfoIFSTime.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdBssInfoIFSTime.u2SlotTime = cpu2le16(SlotTime);
	UniCmdBssInfoIFSTime.fgSlotValid = TRUE;
	UniCmdBssInfoIFSTime.u2SifsTime = cpu2le16(SifsTime);
	UniCmdBssInfoIFSTime.fgSifsValid = TRUE;
	UniCmdBssInfoIFSTime.u2RifsTime = RifsTime;
	UniCmdBssInfoIFSTime.fgRifsValid = TRUE;
	UniCmdBssInfoIFSTime.u2EifsTime = EifsTime;
	UniCmdBssInfoIFSTime.fgEifsValid = TRUE;
	AndesAppendCmdMsg(msg, (char *)&UniCmdBssInfoIFSTime, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
	return ret;
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_DEBUG,
			 "(ret = %d)\n", ret);
	return ret;
}

/*****************************************
 * BssInfo frame offload (UPR/FILS) (Tag 0x19)
 *****************************************/
INT32 MtUniCmdFrameOffloadSet(RTMP_ADAPTER *pAd, P_CMD_FRAME_OFFLOAD_T frame_offload)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	P_UNI_CMD_BSSINFO_T pUniCmdBssInfo;
	P_UNI_CMD_BSSINFO_OFFLOAD_PKT_T pUniCmdBssInfoOffloadPkt;
	PUCHAR pTempBuf = NULL, pBufHead = NULL;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	struct wifi_dev *wdev = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			 "Enable=%d, OwnMacIdx=%d, WlanIdx=%d, Band=%d, Len=%d, Tx Type=%d, Tx TU=%d\n",
			  frame_offload->ucEnable, frame_offload->ucOwnMacIdx,
			  frame_offload->u2Wcid, frame_offload->ucBandIdx, frame_offload->u2PktLength,
			  frame_offload->ucTxType, frame_offload->ucTxInterval);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_BSSINFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UNI_CMD_BSSINFO_OFFLOAD_PKT_T);
	if (frame_offload->ucEnable)
		u4CmdNeedMaxBufSize += frame_offload->u2PktLength;

	/* DW alignment */
	u4CmdNeedMaxBufSize = (u4CmdNeedMaxBufSize & 0x3) ? ((u4CmdNeedMaxBufSize | 0x3) + 1) : u4CmdNeedMaxBufSize;

	/* Step 2: Allocate temporary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pBufHead = pTempBuf;

	/* Step 3: Fill and append common parameters here */
	wdev = wdev_search_by_band_omac_idx(pAd, frame_offload->ucBandIdx, frame_offload->ucOwnMacIdx);
	if (!wdev) {
		// AndesForceFreeCmdMsg(msg);
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	pUniCmdBssInfo = (P_UNI_CMD_BSSINFO_T)pTempBuf;
	pUniCmdBssInfo->ucBssInfoIdx = wdev->bss_info_argument.ucBssIndex;
	pTempBuf += u4ComCmdSize;

	/* Step 4: Fill TLV parameters here */
	pUniCmdBssInfoOffloadPkt = (P_UNI_CMD_BSSINFO_OFFLOAD_PKT_T)pTempBuf;
	pUniCmdBssInfoOffloadPkt->u2Tag = UNI_CMD_BSSINFO_OFFLOAD_PKT;
	pUniCmdBssInfoOffloadPkt->u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	pUniCmdBssInfoOffloadPkt->u2Tag = cpu2le16(pUniCmdBssInfoOffloadPkt->u2Tag);
	pUniCmdBssInfoOffloadPkt->u2Length = cpu2le16(pUniCmdBssInfoOffloadPkt->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pUniCmdBssInfoOffloadPkt->u2OffloadPktLength = cpu2le16(frame_offload->u2PktLength);
	// UniCmdBssInfoOffloadPkt.ucTxMode = 0;
	// UniCmdBssInfoOffloadPkt.ucTxType = BSSINFO_UNSOLICIT_TX_FILS_DISC;
	// UniCmdBssInfoOffloadPkt.ucTxInterval = 200;
	pUniCmdBssInfoOffloadPkt->ucTxMode = frame_offload->ucTxMode;
	pUniCmdBssInfoOffloadPkt->ucTxType = frame_offload->ucTxType;
	pUniCmdBssInfoOffloadPkt->ucTxInterval = frame_offload->ucTxInterval;
	pUniCmdBssInfoOffloadPkt->fgEnable = frame_offload->ucEnable;
	pUniCmdBssInfoOffloadPkt->u2Wcid = cpu2le16(frame_offload->u2Wcid);
	if (frame_offload->ucEnable) {
		os_move_mem(pUniCmdBssInfoOffloadPkt->aucPktContent,
			frame_offload->acPktContent, frame_offload->u2PktLength);
	}

	/* Step 5: form in-band command */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BSSINFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	AndesAppendCmdMsg(msg, (char *)pBufHead, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(pAd, msg);
error:
	if (pBufHead)
		os_free_mem(pBufHead);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", ret);
	return ret;
}

#ifdef DOT11_EHT_BE
/*****************************************
 * BssInfo MLD Link Operation (Tag 0x24)
 * MLD Add Link / MLD Delete Link
 *****************************************/
INT MtUniCmdMldLinkOp(struct _RTMP_ADAPTER *pAd, struct wifi_dev *wdev)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	P_UNI_CMD_BSSINFO_T pUniCmdBssInfo;
	struct UNI_CMD_BSSINFO_MLD_LINK_OP_T *cmd;
	PUCHAR pTempBuf = NULL, pBufHead = NULL;
	UINT32 u4ComCmdSize, u4CmdNeedMaxBufSize;
	struct bss_mld mld = {0};
	UCHAR mld_addr[MAC_ADDR_LEN] = {0};
	UINT8 mld_group_idx;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_BSSINFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BSSINFO_MLD_LINK_OP_T);
	/* DW alignment */
	u4CmdNeedMaxBufSize = (u4CmdNeedMaxBufSize & 0x3) ? ((u4CmdNeedMaxBufSize | 0x3) + 1) : u4CmdNeedMaxBufSize;

	/* Step 2: Allocate temporary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pBufHead = pTempBuf;

	/* Step 3: Fill and append common parameters here */
	pUniCmdBssInfo = (P_UNI_CMD_BSSINFO_T)pTempBuf;
	pUniCmdBssInfo->ucBssInfoIdx = wdev->bss_info_argument.ucBssIndex;
	pTempBuf += u4ComCmdSize;

	/* Step 4: Fill TLV parameters here */
	cmd = (struct UNI_CMD_BSSINFO_MLD_LINK_OP_T *)pTempBuf;

#ifdef DOT11_EHT_BE
	mld_group_idx = wdev->bss_info_argument.mld_info.mld_group_idx;
	wlan_operate_get_mld_addr(wdev, mld_addr);
#else
	mld_group_idx = MLD_GROUP_NONE;
#endif
	ret = HcGetBssMld(wdev, &mld);
	if (ret)
		goto error;

	/* Fill TLV format */
	cmd->u2Tag = UNI_CMD_BSSINFO_MLD_LINK_OP;
	cmd->u2Length = sizeof(struct UNI_CMD_BSSINFO_MLD_LINK_OP_T);
	if (mld_group_idx == MLD_GROUP_NONE) {
		cmd->ucLinkOperation = EHT_MLD_OP_DELETE_LINK;
		cmd->ucGroupMldId = 0xff;
		cmd->ucOwnMldId = mld.mld_addr_idx;
		cmd->ucOmRemapIdx = OM_REMAP_IDX_NONE;
		NdisMoveMemory(cmd->aucOwnMldAddr, mld_addr, MAC_ADDR_LEN);
	} else {
		cmd->ucLinkOperation = EHT_MLD_OP_ADD_LINK;
		cmd->ucGroupMldId = mld.mld_group_addr_idx;
		cmd->ucOwnMldId = mld.mld_addr_idx;
		cmd->ucOmRemapIdx = mld.mld_remap_idx;
		NdisMoveMemory(cmd->aucOwnMldAddr, mld_addr, MAC_ADDR_LEN);
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_NOTICE,
		"if_addr(%pM),mld_grp_id=%d,T=%d,L=%d,GrpMldId=%d,MldId=%d,RemaId=%d,MldAddr=%pM,Op=%d\n",
		wdev->if_addr,
		mld_group_idx,
		cmd->u2Tag,
		cmd->u2Length,
		cmd->ucGroupMldId,
		cmd->ucOwnMldId,
		cmd->ucOmRemapIdx,
		cmd->aucOwnMldAddr,
		cmd->ucLinkOperation);

	/* Step 5: form in-band command */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BSSINFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	AndesAppendCmdMsg(msg, (char *)pBufHead, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(pAd, msg);
error:
	if (pBufHead)
		os_free_mem(pBufHead);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_BSSINFO, DBG_LVL_INFO,
			 "%s:(ret = %d)\n", __func__, ret);
	return ret;
}

/**
 * @MLD cmd: Advertised T2LM resource request (Tag 0x02)
 *
 * @param *req AT2LM_RES_REQ_CTRL_T
 * @param *rsp AT2LM_RES_RSP_CTRL_T
 */
INT32 UniCmdMldAt2lmReq(
	struct _RTMP_ADAPTER *pAd,
	struct AT2LM_RES_REQ_CTRL_T *req,
	struct AT2LM_RES_RSP_CTRL_T *rsp
)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MLD_T UniCmdMld;
	struct UNI_CMD_MLD_AT2LM_T UniCmdMldAt2lm;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT8 i = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(struct UNI_CMD_MLD_T);
	os_zero_mem(&UniCmdMld, u4ComCmdSize);
	os_zero_mem(&UniCmdMldAt2lm, sizeof(struct UNI_CMD_MLD_AT2LM_T));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLD_AT2LM_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLD);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, rsp);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventMldHandler);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdMld.ucCmdVer = 0;
	COPY_MAC_ADDR(UniCmdMld.aucMldAddr, req->aucMldaddr);
	UniCmdMld.ucFwMldIdx = req->ucFwMldIdx;
	UniCmdMld.ucFlag = req->ucFlag;
	AndesAppendCmdMsg(msg, (char *)&UniCmdMld, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdMldAt2lm.u2Tag = UNI_CMD_MLD_AT2LM_RES_REQ;
	UniCmdMldAt2lm.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdMldAt2lm.ucAt2lmId = req->ucAt2lmId;
	UniCmdMldAt2lm.ucBssInfoIdx = req->ucBssInfoIdx;
	UniCmdMldAt2lm.ucEnMstTimer = req->ucEnMstTimer;
	UniCmdMldAt2lm.ucEnETimer = req->ucEnETimer;
	UniCmdMldAt2lm.u2MstTimerAdvTime = req->u2MstTimerAdvTime;
	UniCmdMldAt2lm.u2ETimerAdvTime = req->u2ETimerAdvTime;
	UniCmdMldAt2lm.u4MSTDur = req->u4MstDur;
	UniCmdMldAt2lm.u4EDur = req->u4EDur;
	UniCmdMldAt2lm.u2DisLinkidBitmap = req->u2DisLinkidBitmap;

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_INFO,
		"mld_addr=%pM, mld_idx=%d, a_id=%d, fw_idx=%d\n",
		req->aucMldaddr, req->ucFwMldIdx, req->ucAt2lmId, req->ucBssInfoIdx);
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_INFO,
		"mst_dur=%d us, e_dur=%d us, dis_link_id_bitmap=0x%.4x\n",
		req->u4MstDur, req->u4EDur, req->u2DisLinkidBitmap);

	for (i = 0; i < MLD_LINK_MAX; i++) {
		if (UniCmdMldAt2lm.u2DisLinkidBitmap & BIT(i)) {
			UniCmdMldAt2lm.uDisLinkidBssInfoIdx[i] = req->uDisLinkidBssInfoIdx[i];
			MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_INFO,
				"dis_link_id_bss_info_idx[%d]=%d\n",
				i, req->uDisLinkidBssInfoIdx[i]);
		}
	}

	AndesAppendCmdMsg(msg, (char *)&UniCmdMldAt2lm, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
	return ret;
error:
	MTWF_DBG(NULL, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_DEBUG,
		"%s:(ret = %d)\n", __func__, ret);
	return ret;
}

/**
 * @MLD cmd: Set Reconfiguration ML IE - Ap Removal Timer (Tag 0x03)
 *
 * @param *reconfig_info reconfig_set_tmr_t
 */
INT UniCmdMldReconfigTmr(struct _RTMP_ADAPTER *pAd, struct RECONFIG_SET_TMR_CTRL_T *reconfig_ctrl)
{
	struct cmd_msg *msg;
	struct UNI_CMD_MLD_T UniCmdMld = {0};
	struct UNI_CMD_MLD_RECONFIG_TMR_T UniCmdMldReconfigTmr = {0};
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT8 link;
	INT32 ret;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_MLD_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLD_RECONFIG_TMR_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLD);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters */
	UniCmdMld.ucCmdVer = 0;
	COPY_MAC_ADDR(UniCmdMld.aucMldAddr, reconfig_ctrl->aucMldAddr);
	UniCmdMld.ucFwMldIdx = reconfig_ctrl->ucFwMldIdx;
	UniCmdMld.ucFlag = reconfig_ctrl->ucFlag;
	AndesAppendCmdMsg(msg, (char *)&UniCmdMld, u4ComCmdSize);

	/* Step 4: Fill TLV parameters */
	UniCmdMldReconfigTmr.u2Tag = UNI_CMD_MLD_RECONFIG_TMR;
	UniCmdMldReconfigTmr.u2Length = sizeof(struct UNI_CMD_MLD_RECONFIG_TMR_T);
	UniCmdMldReconfigTmr.u2VldLinkIdBmap = reconfig_ctrl->u2VldLinkIdBmap;
	for (link = 0; link < CFG_WIFI_RAM_BAND_NUM; link++) {
		if (reconfig_ctrl->u2VldLinkIdBmap & BIT(link)) {
			UniCmdMldReconfigTmr.aucLinkBssIdx[link] = reconfig_ctrl->aucFwBssIdxLink[link];
			UniCmdMldReconfigTmr.au2NumSeconds[link] = reconfig_ctrl->u2NumSeconds;
			MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_NOTICE,
				"link %d, fw bss idx %d, NumSeconds %d\n",
				link, UniCmdMldReconfigTmr.aucLinkBssIdx[link],
				UniCmdMldReconfigTmr.au2NumSeconds[link]);
		}
	}

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_NOTICE,
		"mld_addr=%pM, fw_mld_idx=%d, link_bmap=0x%x\n",
		UniCmdMld.aucMldAddr, UniCmdMld.ucFwMldIdx, UniCmdMldReconfigTmr.u2VldLinkIdBmap);

	AndesAppendCmdMsg(msg, (char *)&UniCmdMldReconfigTmr,
		sizeof(struct UNI_CMD_MLD_RECONFIG_TMR_T));

	hex_dump_with_cat_and_lvl("MLD cmm raw data",
		(u8 *)&UniCmdMld, sizeof(struct UNI_CMD_MLD_T),
		DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG);

	hex_dump_with_cat_and_lvl("MLD TLV raw data",
		(u8 *)&UniCmdMldReconfigTmr, sizeof(struct UNI_CMD_MLD_RECONFIG_TMR_T),
		DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG);

	ret = chip_cmd_tx(pAd, msg);

	return ret;

error:
	MTWF_DBG(NULL, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_DEBUG,
		"%s:(ret = %d)\n", __func__, ret);
	return ret;
}

/**
 * @MLD cmd: ML Reconfig remove link request (Tag 0x04)
 *
 * @param *pAd Adpater
 * @param *req RECONFIG_RM_LINK_REQ_CTRL_T
 */
INT32 UniCmdMldReconfigRmLinkReq(
	struct _RTMP_ADAPTER *pAd,
	struct RECONFIG_RM_LINK_REQ_CTRL_T *req
)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MLD_T UniCmdMld;
	struct UNI_CMD_MLD_RECONFIG_RM_LINK_T UniCmdMldReconfigRmLink;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT8 i = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(struct UNI_CMD_MLD_T);
	os_zero_mem(&UniCmdMld, u4ComCmdSize);
	os_zero_mem(&UniCmdMldReconfigRmLink, sizeof(struct UNI_CMD_MLD_RECONFIG_RM_LINK_T));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLD_RECONFIG_RM_LINK_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLD);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdMld.ucCmdVer = 0;
	COPY_MAC_ADDR(UniCmdMld.aucMldAddr, req->aucMldaddr);
	UniCmdMld.ucFwMldIdx = req->ucFwMldIdx;
	UniCmdMld.ucFlag = req->ucFlag;
	AndesAppendCmdMsg(msg, (char *)&UniCmdMld, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdMldReconfigRmLink.u2Tag = UNI_CMD_MLD_MLR_RM_LINK;
	UniCmdMldReconfigRmLink.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdMldReconfigRmLink.u2RmLinkIdBitmap = req->u2RmLinkIdBitmap;
	for (i = 0; i < MLD_LINK_MAX; i++)
		UniCmdMldReconfigRmLink.aucLinkIdBssInfoIdx[i] = req->u2LinkIdBssInfoIdx[i];

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_RECONFIG, DBG_LVL_NOTICE,
		"RmLinkIdBitmap=0x%.2x, bss_info_idx[]=[%d, %d, %d]\n",
		req->u2RmLinkIdBitmap,
		UniCmdMldReconfigRmLink.aucLinkIdBssInfoIdx[2],
		UniCmdMldReconfigRmLink.aucLinkIdBssInfoIdx[1],
		UniCmdMldReconfigRmLink.aucLinkIdBssInfoIdx[0]);

	AndesAppendCmdMsg(msg, (char *)&UniCmdMldReconfigRmLink, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
	return ret;
error:
	MTWF_DBG(NULL, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_DEBUG,
		"%s:(ret = %d)\n", __func__, ret);
	return ret;
}

/*****************************************
 * Peer MLD cmd: Nego. T2LM request (Tag 0x00)
 *****************************************/
/**
 * @MLD cmd: Nego. T2LM request (Tag 0x00)
 *
 * @param *req NT2LM_REQ_CTRL_T
 */
INT32 UniCmdPeerMldNt2lmReq(
	struct _RTMP_ADAPTER *pAd,
	struct NT2LM_REQ_CTRL_T *req
)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_PEER_MLD_T UniCmdPeerMld;
	struct UNI_CMD_PEER_MLD_NT2LM_T UniCmdPeerMldNt2lm;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT8 i = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(struct UNI_CMD_PEER_MLD_T);
	os_zero_mem(&UniCmdPeerMld, u4ComCmdSize);
	os_zero_mem(&UniCmdPeerMldNt2lm, sizeof(struct UNI_CMD_PEER_MLD_NT2LM_T));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_PEER_MLD_NT2LM_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PEER_MLD);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdPeerMld.ucCmdVer = 0;
	COPY_MAC_ADDR(UniCmdPeerMld.aucMldAddr, req->aucPeerMldaddr);
	UniCmdPeerMld.ucMldIdx = req->ucMldIdx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdPeerMld, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdPeerMldNt2lm.u2Tag = UNI_CMD_PEER_MLD_NT2LM_REQ;
	UniCmdPeerMldNt2lm.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	COPY_MAC_ADDR(UniCmdPeerMldNt2lm.aucMldAddr, req->aucSelfMldaddr);
	UniCmdPeerMldNt2lm.u2LinkidBitmap = req->u2LinkIdBitmap;
	for (i = 0; i < MLD_LINK_MAX; i++)
		UniCmdPeerMldNt2lm.au2Wcid[i] = req->u2LinkIdToWcid[i];
	os_move_mem(UniCmdPeerMldNt2lm.aucTidmapDl, req->aucTidmapDl, MLD_LINK_MAX);
	os_move_mem(UniCmdPeerMldNt2lm.aucTidmapUl, req->aucTidmapUl, MLD_LINK_MAX);

	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_INFO,
		"peer_mld=%pM, self_mld=%pM, link_id_bitmap=0x%.4x\n",
		UniCmdPeerMld.aucMldAddr,
		UniCmdPeerMldNt2lm.aucMldAddr,
		UniCmdPeerMldNt2lm.u2LinkidBitmap);
	for (i = 0; i < MLD_LINK_MAX; i++) {
		if (UniCmdPeerMldNt2lm.u2LinkidBitmap & (1 << i)) {
			MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_INFO,
				"wcid=%d, tid_dl[%d]=0x%.2x, tid_ul[%d]=0x%.2x\n",
				UniCmdPeerMldNt2lm.au2Wcid[i],
				i, UniCmdPeerMldNt2lm.aucTidmapDl[i],
				i, UniCmdPeerMldNt2lm.aucTidmapUl[i]);
		}
	}

	AndesAppendCmdMsg(msg, (char *)&UniCmdPeerMldNt2lm, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
	return ret;
error:
	MTWF_DBG(NULL, DBG_CAT_MLO, CATMLO_T2LM, DBG_LVL_DEBUG,
		"%s:(ret = %d)\n", __func__, ret);
	return ret;
}
#endif /* DOT11_EHT_BE */

/*
* Unified command UNI_CMD_STAREC_BASIC (TAG 0x00) handler
* refer to StaRecUpdateBasic
*/
static INT32 UniCmdStaRecBasic(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	/* Fill STA Rec Common */
#ifdef CONFIG_STA_SUPPORT
	EDCA_PARM *pEdca = NULL;
#endif /*CONFIG_STA_SUPPORT*/
	P_CMD_STAREC_COMMON_T pStaRecCommon = (P_CMD_STAREC_COMMON_T)pHandle;
#ifdef CONFIG_STA_SUPPORT
	struct _STA_TR_ENTRY *tr_entry = tr_entry_get(pAd, pStaRecCfg->u2WlanIdx);
	PSTA_ADMIN_CONFIG pStaCfg = GetStaCfgByWdev(pAd, tr_entry->wdev);
#endif
	/* Fill TLV format */
	pStaRecCommon->u2Tag = UNI_CMD_STAREC_BASIC;
	pStaRecCommon->u2Length = sizeof(CMD_STAREC_COMMON_T);
	pStaRecCommon->u4ConnectionType = cpu2le32(pStaRecCfg->ConnectionType);
	pStaRecCommon->ucConnectionState = pStaRecCfg->ConnectionState;
	/* New info to indicate this is new way to update STAREC */
	pStaRecCommon->u2ExtraInfo = STAREC_COMMON_EXTRAINFO_V2;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_BASIC (STA_REC_BASIC_STA_RECORD_FEATURE)\n");

	if (pStaRecCfg->IsNewSTARec) {
		pStaRecCommon->u2ExtraInfo |= STAREC_COMMON_EXTRAINFO_NEWSTAREC;
#ifdef SW_CONNECT_SUPPORT
		/*
		* S/W enrty : means use dummy wcid,
		* wm need to set I_PSM on for force Tx Pkts
		* TBD:
		* PS may need to unify in Host in H/W & S/W Entry,
		* TIM PVB bit set in beacon. (now is set in WM)
		*/
		if (IS_SW_MAIN_STA(tr_entry)) {
			pStaRecCommon->u2ExtraInfo |= STAREC_COMMON_EXTRAINFO_NEWSTAREC_DUMMY;
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"set Dummy Flag to WM!\n");
		}
#endif /* SW_CONNECT_SUPPORT */
	}

#ifdef CONFIG_AP_SUPPORT

	if (pEntry) {
		pStaRecCommon->ucIsQBSS =
			CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE) ?
			TRUE : FALSE;
		pStaRecCommon->u2AID = cpu2le16(pEntry->Aid);

		if (pEntry->vendor_ie.is_mtk)
			pStaRecCommon->u2ExtraInfo |= STAREC_COMMON_EXTRAINFO_MEDIATEK;
	}

#endif /* CONFIG_AP_SUPPORT */
#ifdef CONFIG_STA_SUPPORT

	if (pStaCfg) {
		pEdca = hwifi_get_edca(pAd, &pStaCfg->wdev);

		if (pEdca)
			pStaRecCommon->ucIsQBSS = pEdca->bValid;

		pStaRecCommon->u2AID = cpu2le16(pStaCfg->StaActive.Aid);
	}

#endif /*CONFIG_STA_SUPPORT*/

	if (pEntry) {
#ifdef SW_CONNECT_SUPPORT
		/* Force Fake as magic peer mac,  to let Rx correct S/W wcid again */
		if (IS_SW_MAIN_STA(tr_entry) || IS_SW_STA(tr_entry)) {
			pStaRecCommon->aucPeerMacAddr[0] = 0x00;
			pStaRecCommon->aucPeerMacAddr[1] = 0xdd;
			pStaRecCommon->aucPeerMacAddr[2] = 0xdd;
			pStaRecCommon->aucPeerMacAddr[3] = 0xdd;
			pStaRecCommon->aucPeerMacAddr[4] = 0xdd;
			pStaRecCommon->aucPeerMacAddr[5] = (pStaRecCfg->u2WlanIdx & 0xff);
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
				"Fake Dummy MAC u2WlanIdx=%u\n", pStaRecCfg->u2WlanIdx);
		} else
#endif /* SW_CONNECT_SUPPORT */
			os_move_mem(pStaRecCommon->aucPeerMacAddr,
					pEntry->Addr, MAC_ADDR_LEN);
	} else {
#ifdef CONFIG_STA_SUPPORT
		if (tr_entry->EntryType == ENTRY_CAT_MCAST &&
			(tr_entry->wdev->wdev_type == WDEV_TYPE_STA ||
			tr_entry->wdev->wdev_type == WDEV_TYPE_REPEATER ||
			tr_entry->wdev->wdev_type == WDEV_TYPE_ADHOC))
			os_move_mem(pStaRecCommon->aucPeerMacAddr,
					tr_entry->bssid, MAC_ADDR_LEN);
		else
#endif
		os_move_mem(pStaRecCommon->aucPeerMacAddr,
					BROADCAST_ADDR, MAC_ADDR_LEN);
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			 "(CMD_STAREC_COMMON_T), u4ConnectionType = %d, ucConnectionState = %d, ucIsQBSS = %d, u2AID = %d\n",
			  le2cpu32(pStaRecCommon->u4ConnectionType),
			  pStaRecCommon->ucConnectionState,
			  pStaRecCommon->ucIsQBSS,
			  le2cpu16(pStaRecCommon->u2AID));
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			 "\taucPeerMacAddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
			  PRINT_MAC(pStaRecCommon->aucPeerMacAddr));

	/* Append this feature */
#ifdef CFG_BIG_ENDIAN
	pStaRecCommon->u2Tag = cpu2le16(pStaRecCommon->u2Tag);
	pStaRecCommon->u2Length = cpu2le16(pStaRecCommon->u2Length);
	pStaRecCommon->u2ExtraInfo = cpu2le16(pStaRecCommon->u2ExtraInfo);
#endif
	return Ret;
}

static INT32 UniCmdStaRecBasicBmc(
		struct _RTMP_ADAPTER *pAd,
		STA_REC_CFG_T *pStaRecCfg,
		UNI_CMD_TAG_HANDLE_T *pTagHandle,
		VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	/* Fill STA Rec Common */
#ifdef CONFIG_STA_SUPPORT
	EDCA_PARM * pEdca = NULL;
#endif /*CONFIG_STA_SUPPORT*/
	P_CMD_STAREC_COMMON_T pStaRecCommon = (P_CMD_STAREC_COMMON_T)pHandle;
#ifdef CONFIG_STA_SUPPORT
	STA_TR_ENTRY * tr_entry = tr_entry_get(pAd, pAd->u2BMCIdx);
	PSTA_ADMIN_CONFIG pStaCfg = GetStaCfgByWdev(pAd, tr_entry->wdev);
#endif
	/* Fill TLV format */
	pStaRecCommon->u2Tag = UNI_CMD_STAREC_BASIC;
	pStaRecCommon->u2Length = sizeof(CMD_STAREC_COMMON_T);
	pStaRecCommon->u4ConnectionType = cpu2le32(pStaRecCfg->ConnectionType);
	pStaRecCommon->ucConnectionState = pStaRecCfg->ConnectionState;
	/* New info to indicate this is new way to update STAREC */
	pStaRecCommon->u2ExtraInfo = STAREC_COMMON_EXTRAINFO_V2;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_BASIC (STA_REC_BASIC_STA_RECORD_BMC_FEATURE)\n");

	if (pStaRecCfg->IsNewSTARec)
		pStaRecCommon->u2ExtraInfo |= STAREC_COMMON_EXTRAINFO_NEWSTAREC;

#ifdef CONFIG_STA_SUPPORT

	if (pStaCfg) {
		pEdca = hwifi_get_edca(pAd, &pStaCfg->wdev);

		if (pEdca)
			pStaRecCommon->ucIsQBSS = pEdca->bValid;

		pStaRecCommon->u2AID = cpu2le16(pStaCfg->StaActive.Aid);
	}

	os_move_mem(pStaRecCommon->aucPeerMacAddr,
			tr_entry->bssid, MAC_ADDR_LEN);
#endif /*CONFIG_STA_SUPPORT*/

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"(CMD_STAREC_COMMON_T), u4ConnectionType = %d, ucConnectionState = %d, ucIsQBSS = %d, u2AID = %d\n",
			le2cpu32(pStaRecCommon->u4ConnectionType),
			pStaRecCommon->ucConnectionState,
			pStaRecCommon->ucIsQBSS,
			le2cpu16(pStaRecCommon->u2AID));
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"\taucPeerMacAddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
			PRINT_MAC(pStaRecCommon->aucPeerMacAddr));

	/* Append this feature */
#ifdef CFG_BIG_ENDIAN
	pStaRecCommon->u2Tag = cpu2le16(pStaRecCommon->u2Tag);
	pStaRecCommon->u2Length = cpu2le16(pStaRecCommon->u2Length);
	pStaRecCommon->u2ExtraInfo = cpu2le16(pStaRecCommon->u2ExtraInfo);
#endif
	return Ret;
}

#ifdef DOT11_EHT_BE
static void MloRcpiCalculate(
	struct _RTMP_ADAPTER *ad,
	struct _MAC_TABLE_ENTRY *entry)
{
	struct mld_dev *mld;
	struct wifi_dev *wdev, *setup_wdev;
	struct _MAC_TABLE_ENTRY *setup_entry = NULL;
	UINT32 value = 0;
	UINT8 rcpi_tmp = 0;
	struct mld_entry_t *mld_entry = NULL;
	UINT32 rx_ant = 0;

	MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
			"entry->mlo.mlo_en=%d\n",
			entry->mlo.mlo_en);
	MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
			"entry(%02x:%02x:%02x:%02x:%02x:%02x)\n",
			PRINT_MAC(entry->Addr));
	if (entry->mlo.mlo_en) {
		wdev = entry->wdev;
		if (!wdev) {
			MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_ERROR,
				"wdev is null!");
			return;
		}

		mld = wdev->mld_dev;
		if (entry->mlo.is_setup_link_entry)
			MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
				"Setup link entry.\n");
		else {
			MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
				"NonSetup link - RcpiCalculate!\n");
			mt_rcu_read_lock();
			mld_entry = get_mld_entry_by_mac(entry->mlo.mld_addr);
			if (!mld_entry) {
				MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_ERROR,
					"mld_entry = NULL\n");
				mt_rcu_read_unlock();
				return;
			}
			MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
				"mld_entry=%p!\n", mld_entry);
			setup_entry = mld_entry_link_select(mld_entry);
			mt_rcu_read_unlock();
			if (setup_entry) {
				setup_wdev = setup_entry->wdev;
				if (!setup_wdev) {
					MTWF_DBG(ad,
						DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_ERROR,
						"setup_wdev is null!");
						return;
				}
				MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
					"setup_wdev->PhyMode = 0x%x, wdev->PhyMode = 0x%x\n",
					setup_wdev->PhyMode,
					wdev->PhyMode);
				MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
					"setup_entry(%02x:%02x:%02x:%02x:%02x:%02x)\n",
					PRINT_MAC(setup_entry->Addr));
				MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
					"setup_entry rcpi: 0x%x, 0x%x, 0x%x, 0x%x\n",
					setup_entry->rcpi0,
					setup_entry->rcpi1,
					setup_entry->rcpi2,
					setup_entry->rcpi3);
				if (WMODE_CAP_2G(setup_wdev->PhyMode)) {
					MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
						"Setup link: 2G, entry link is 5G or 6G\n");
					rcpi_tmp = ~setup_entry->rcpi0+1;
					value = rcpi_tmp + (rcpi_tmp/5);
					rcpi_tmp = (value <= 255) ? value:255;
					entry->rcpi0 = ~rcpi_tmp+1;

					rcpi_tmp = ~setup_entry->rcpi1+1;
					value = rcpi_tmp + (rcpi_tmp/5);
					rcpi_tmp = (value <= 255) ? value:255;
					entry->rcpi1 = ~rcpi_tmp+1;

					rcpi_tmp = ~setup_entry->rcpi2+1;
					value = rcpi_tmp + (rcpi_tmp/5);
					rcpi_tmp = (value <= 255) ? value:255;
					entry->rcpi2 = ~rcpi_tmp+1;

					rcpi_tmp = ~setup_entry->rcpi3+1;
					value = rcpi_tmp + (rcpi_tmp/5);
					rcpi_tmp = (value <= 255) ? value:255;
					entry->rcpi3 = ~rcpi_tmp+1;
				} else {
					MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
						"Setup link: 5G or 6G\n");
					if (WMODE_CAP_2G(wdev->PhyMode)) {
						MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
							"Entry link: 2G\n");
						rcpi_tmp = ~setup_entry->rcpi0+1;
						value = rcpi_tmp - (rcpi_tmp/5);
						rcpi_tmp = (value <= 255) ? value:255;
						entry->rcpi0 = ~rcpi_tmp+1;

						rcpi_tmp = ~setup_entry->rcpi1+1;
						value = rcpi_tmp - (rcpi_tmp/5);
						rcpi_tmp = (value <= 255) ? value:255;
						entry->rcpi1 = ~rcpi_tmp+1;

						rcpi_tmp = ~setup_entry->rcpi2+1;
						value = rcpi_tmp - (rcpi_tmp/5);
						rcpi_tmp = (value <= 255) ? value:255;
						entry->rcpi2 = ~rcpi_tmp+1;

						rcpi_tmp = ~setup_entry->rcpi3+1;
						value = rcpi_tmp - (rcpi_tmp/5);
						rcpi_tmp = (value <= 255) ? value:255;
						entry->rcpi3 = ~rcpi_tmp+1;
					} else {
						MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_DEBUG,
							"Entry link: 5G or 6G\n");
						entry->rcpi0 = setup_entry->rcpi0;
						entry->rcpi1 = setup_entry->rcpi1;
						entry->rcpi2 = setup_entry->rcpi2;
						entry->rcpi3 = setup_entry->rcpi3;
					}
				}

				if (WMODE_CAP_BE(wdev->PhyMode))
					rx_ant = wlan_config_get_eht_rx_nss(wdev);

				/* set entry rcpi by number of antenna */
				if (rx_ant < 4)
					entry->rcpi3 = 255;
				if (rx_ant < 3)
					entry->rcpi2 = 255;
				if (rx_ant < 2)
					entry->rcpi1 = 255;

			} else
				MTWF_DBG(ad, DBG_CAT_MLO, CATMLO_ENTRY, DBG_LVL_ERROR,
						"Cannot find setup link entry.");
			return;
		}
	}
}
#endif /* DOT11_EHT_BE */

/*
* Unified command UNI_CMD_STAREC_RA (TAG 0x01) handler
* refer to StaRecUpdateRa
*/
static INT32 UniCmdStaRecRA(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
#ifdef RACTRL_FW_OFFLOAD_SUPPORT
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct _STAREC_AUTO_RATE_T *CmdStaRecAutoRate = (struct _STAREC_AUTO_RATE_T *)pHandle;

	if (pEntry) {
		os_zero_mem(CmdStaRecAutoRate, sizeof(struct _STAREC_AUTO_RATE_T));
		StaRecAutoRateParamSet(&pEntry->RaEntry, CmdStaRecAutoRate);
#ifdef DOT11_EHT_BE
		MloRcpiCalculate(pAd, pEntry);
#endif /* DOT11_EHT_BE */
		CmdStaRecAutoRate->ucRxRcpi0 = pEntry->rcpi0;
		CmdStaRecAutoRate->ucRxRcpi1 = pEntry->rcpi1;
		CmdStaRecAutoRate->ucRxRcpi2 = pEntry->rcpi2;
		CmdStaRecAutoRate->ucRxRcpi3 = pEntry->rcpi3;

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"ucRxRcpi0=0x%x\n", CmdStaRecAutoRate->ucRxRcpi0);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"ucRxRcpi1=0x%x\n", CmdStaRecAutoRate->ucRxRcpi1);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"ucRxRcpi2=0x%x\n", CmdStaRecAutoRate->ucRxRcpi2);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"ucRxRcpi3=0x%x\n", CmdStaRecAutoRate->ucRxRcpi3);
		CmdStaRecAutoRate->u2Tag = UNI_CMD_STAREC_RA;
		CmdStaRecAutoRate->u2Length = sizeof(struct _STAREC_AUTO_RATE_T);
#ifdef CFG_BIG_ENDIAN
		CmdStaRecAutoRate->u2Tag = cpu2le16(CmdStaRecAutoRate->u2Tag);
		CmdStaRecAutoRate->u2Length = cpu2le16(CmdStaRecAutoRate->u2Length);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_RA (STA_REC_RA_FEATURE)\n");
#endif
		return NDIS_STATUS_SUCCESS;
	}
#endif /* RACTRL_FW_OFFLOAD_SUPPORT */
	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_RA_UPDATE (TAG 0x03) handler
* refer to StaRecUpdateRaUpdate
*/
static INT32 UniCmdStaRecRAUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
#ifdef RACTRL_FW_OFFLOAD_SUPPORT
	P_CMD_STAREC_AUTO_RATE_UPDATE_T pCmdStaRecAutoRateUpdate = pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;

	if (pEntry) {
		os_zero_mem(pCmdStaRecAutoRateUpdate, sizeof(CMD_STAREC_AUTO_RATE_UPDATE_T));
		StaRecAutoRateUpdate(&pEntry->RaEntry, &pEntry->RaInternal,
							 pStaRecCfg->pRaParam, pCmdStaRecAutoRateUpdate);

		pCmdStaRecAutoRateUpdate->u2Tag = UNI_CMD_STAREC_RA_UPDATE;
		pCmdStaRecAutoRateUpdate->u2Length = sizeof(CMD_STAREC_AUTO_RATE_UPDATE_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_RA_UPDATE (STA_REC_RA_UPDATE_FEATURE)\n");
#ifdef CFG_BIG_ENDIAN
		pCmdStaRecAutoRateUpdate->u2Tag = cpu2le16(pCmdStaRecAutoRateUpdate->u2Tag);
		pCmdStaRecAutoRateUpdate->u2Length = cpu2le16(pCmdStaRecAutoRateUpdate->u2Length);
#endif
		return NDIS_STATUS_SUCCESS;
	}
#endif /* RACTRL_FW_OFFLOAD_SUPPORT */
	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_HT_BASIC (TAG 0x09) handler
* refer to StaRecUpdateHtInfo
*/
static INT32 UniCmdStaRecHTBasic(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_CMD_STAREC_HT_INFO_T pCmdStaRecHtInfo = (P_CMD_STAREC_HT_INFO_T)pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;

	if (pEntry) {
		os_zero_mem(pCmdStaRecHtInfo, sizeof(CMD_STAREC_HT_INFO_T));
		pCmdStaRecHtInfo->u2Tag = UNI_CMD_STAREC_HT_BASIC;
		pCmdStaRecHtInfo->u2Length = sizeof(CMD_STAREC_HT_INFO_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_HT_BASIC (STA_REC_BASIC_HT_INFO_FEATURE)\n");
		/* FIXME: may need separate function to compose the payload */
		os_move_mem(&(pCmdStaRecHtInfo->u2HtCap), &(pEntry->HTCapability.HtCapInfo),
					sizeof(pCmdStaRecHtInfo->u2HtCap));
		os_move_mem(&(pCmdStaRecHtInfo->u2HtExtendedCap), &(pEntry->HTCapability.ExtHtCapInfo),
					sizeof(pCmdStaRecHtInfo->u2HtExtendedCap));
		os_move_mem(&(pCmdStaRecHtInfo->ucHtCapParm), &(pEntry->HTCapability.HtCapParm),
					sizeof(pCmdStaRecHtInfo->ucHtCapParm));
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"HtCapInfo=%d, HtCapParm=%d\n", pCmdStaRecHtInfo->u2HtCap, pCmdStaRecHtInfo->ucHtCapParm);
#ifdef CFG_BIG_ENDIAN
		pCmdStaRecHtInfo->u2HtCap = cpu2le16(pCmdStaRecHtInfo->u2HtCap);
		pCmdStaRecHtInfo->u2HtExtendedCap = cpu2le16(pCmdStaRecHtInfo->u2HtExtendedCap);
		pCmdStaRecHtInfo->u2Tag = cpu2le16(pCmdStaRecHtInfo->u2Tag);
		pCmdStaRecHtInfo->u2Length = cpu2le16(pCmdStaRecHtInfo->u2Length);
#endif
		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_VHT_BASIC (TAG 0x0A) handler
* refer to StaRecUpdateVhtInfo
*/
static INT32 UniCmdStaRecVHTBasic(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_CMD_STAREC_VHT_INFO_T pCmdStaRecVHtInfo = (P_CMD_STAREC_VHT_INFO_T) pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;

	if (pEntry) {
		os_zero_mem(pCmdStaRecVHtInfo, sizeof(CMD_STAREC_VHT_INFO_T));
		pCmdStaRecVHtInfo->u2Tag = UNI_CMD_STAREC_VHT_BASIC;
		pCmdStaRecVHtInfo->u2Length = sizeof(CMD_STAREC_VHT_INFO_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_VHT_BASIC (STA_REC_BASIC_VHT_INFO_FEATURE)\n");
		/* FIXME: may need separate function to compose the payload */
		os_move_mem(&(pCmdStaRecVHtInfo->u4VhtCap),
					&(pEntry->vht_cap_ie.vht_cap),
					sizeof(pCmdStaRecVHtInfo->u4VhtCap));
		os_move_mem(&(pCmdStaRecVHtInfo->u2VhtRxMcsMap),
					&(pEntry->vht_cap_ie.mcs_set.rx_mcs_map),
					sizeof(pCmdStaRecVHtInfo->u2VhtRxMcsMap));
		os_move_mem(&(pCmdStaRecVHtInfo->u2VhtTxMcsMap),
					&(pEntry->vht_cap_ie.mcs_set.tx_mcs_map),
					sizeof(pCmdStaRecVHtInfo->u2VhtTxMcsMap));

		if (IS_VHT_STA(pEntry) && !IS_HE_2G_STA(pEntry->cap.modes)) {
				UCHAR ucRTSBWSig = wlan_config_get_vht_bw_sig(pEntry->wdev);
				/* for StaRec: 0-disable DynBW, 1-static BW, 2 Dynamic BW */
				pCmdStaRecVHtInfo->ucRTSBWSig = ucRTSBWSig;
		}

		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u4VhtCap=%d u2VhtRxMcsMap=%d u2VhtTxMcsMap=%d ucRTSBWSig=%d\n",
				pCmdStaRecVHtInfo->u4VhtCap,
				pCmdStaRecVHtInfo->u2VhtRxMcsMap, pCmdStaRecVHtInfo->u2VhtTxMcsMap,
				pCmdStaRecVHtInfo->ucRTSBWSig);

#ifdef CFG_BIG_ENDIAN
		pCmdStaRecVHtInfo->u2Tag = cpu2le16(pCmdStaRecVHtInfo->u2Tag);
		pCmdStaRecVHtInfo->u2Length = cpu2le16(pCmdStaRecVHtInfo->u2Length);
		pCmdStaRecVHtInfo->u4VhtCap = cpu2le32(pCmdStaRecVHtInfo->u4VhtCap);
		pCmdStaRecVHtInfo->u2VhtRxMcsMap = cpu2le16(pCmdStaRecVHtInfo->u2VhtRxMcsMap);
		pCmdStaRecVHtInfo->u2VhtTxMcsMap = cpu2le16(pCmdStaRecVHtInfo->u2VhtTxMcsMap);
#endif
		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}
/*
* Unified command UNI_CMD_STAREC_WTBL (TAG 0x0D) handler
* refer to StaRecUpdateWtbl
*/
static INT32 UniCmdStaRecWTBL(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	UINT8 *pNext = (UINT8 *)pHandle;
	struct UNI_CMD_STAREC_AADOM_T *pAADOM = NULL;
	struct UNI_CMD_STAREC_HDRT_T *pHDRT = NULL;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;

	if (pEntry == NULL)
		return NDIS_STATUS_FAILURE;

	pAADOM = (struct UNI_CMD_STAREC_AADOM_T *)pNext;
	pNext += sizeof(*pAADOM);
	pHDRT = (struct UNI_CMD_STAREC_HDRT_T *)pNext;
	pNext += sizeof(*pHDRT);

	pAADOM->u2Tag = UNI_CMD_STAREC_AAD_OM;
	pAADOM->u2Length = sizeof(struct UNI_CMD_STAREC_AADOM_T);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_AAD_OM (STA_REC_WTBL_FEATURE)\n");
	if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RDG_CAPABLE)
		&& CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET))
		pAADOM->ucAadOm = 1;

	pHDRT->u2Tag = UNI_CMD_STAREC_HDRT;
	pHDRT->u2Length = sizeof(struct UNI_CMD_STAREC_HDRT_T);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_HDRT (STA_REC_WTBL_FEATURE)\n");
	if (!IS_BELLWETHER(pAd))
		pHDRT->ucHdrtMode = 1;
	else
		pHDRT->ucHdrtMode = 0;

#ifdef CFG_BIG_ENDIAN
	pAADOM->u2Tag = cpu2le16(pAADOM->u2Tag);
	pAADOM->u2Length = cpu2le16(pAADOM->u2Length);
	pHDRT->u2Tag = cpu2le16(pHDRT->u2Tag);
	pHDRT->u2Length = cpu2le16(pHDRT->u2Length);
#endif

	return NDIS_STATUS_SUCCESS;
}
static INT32 UniCmdStaRecBMCWTBL(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	struct UNI_CMD_STAREC_HDRT_T *pHDRT = NULL;

	pHDRT = (struct UNI_CMD_STAREC_HDRT_T *)pHandle;
	pHDRT->u2Tag = UNI_CMD_STAREC_HDRT;
	pHDRT->u2Length = sizeof(struct UNI_CMD_STAREC_HDRT_T);
	if (!IS_BELLWETHER(pAd))
		pHDRT->ucHdrtMode = 1;
	else
		pHDRT->ucHdrtMode = 0;
#ifdef CFG_BIG_ENDIAN
	pHDRT->u2Tag = cpu2le16(pHDRT->u2Tag);
	pHDRT->u2Length = cpu2le16(pHDRT->u2Length);
#endif
	return NDIS_STATUS_SUCCESS;
}

/*
* Unified command UNI_CMD_STAREC_HE_BASIC (TAG 0x0E) handler
* refer to sta_rec_update_he_info
*/
static INT32 UniCmdStaRecHEInfo(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_UNI_CMD_STAREC_HE_INFO_T phe_info = (P_UNI_CMD_STAREC_HE_INFO_T) pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct he_sta_mac_info *mac_info = &pStaRecCfg->he_sta.mac_info;
	struct he_sta_phy_info *phy_info = &pStaRecCfg->he_sta.phy_info;
	struct he_mcs_info *mcs = &pStaRecCfg->he_sta.max_nss_mcs;
	int i;

	if (pEntry) {
		os_zero_mem(phe_info, sizeof(UNI_CMD_STAREC_HE_INFO_T));
		phe_info->u2Tag = UNI_CMD_STAREC_HE_BASIC_OLD;
		phe_info->u2Length = sizeof(UNI_CMD_STAREC_HE_INFO_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_HE_BASIC_OLD (STA_REC_BASIC_HE_INFO_FEATURE)\n");

		/*mac info*/
		phe_info->u4HeCap |= (mac_info->bqr_support << STA_REC_HE_CAP_BQR);
		phe_info->u4HeCap |= (mac_info->htc_support << STA_REC_HE_CAP_HTC);
		phe_info->u4HeCap |= (mac_info->bsr_support << STA_REC_HE_CAP_BSR);
		phe_info->u4HeCap |= (mac_info->om_support << STA_REC_HE_CAP_OM);
		phe_info->u4HeCap |= (mac_info->amsdu_in_ampdu_support << STA_REC_HE_CAP_AMSDU_IN_AMPDU);
		phe_info->ucMaxAmpduLenExponent = mac_info->max_ampdu_len_exp;
		phe_info->ucMaxAmpduLenExponentExtension = 0; /* TODO: Check this value */
		phe_info->ucTrigerFrameMacPadDuration = mac_info->trigger_frame_mac_pad_dur;
		/*phy info*/
		phe_info->u4HeCap |= (phy_info->dual_band_support << STA_REC_HE_CAP_DUAL_BAND);
		phe_info->u4HeCap |= (phy_info->ldpc_support << STA_REC_HE_CAP_LDPC);
		phe_info->u4HeCap |= (phy_info->triggered_cqi_feedback_support << STA_REC_HE_CAP_TRIG_CQI_FK);
		phe_info->u4HeCap |= (phy_info->partial_bw_ext_range_support << STA_REC_HE_CAP_PARTIAL_BW_EXT_RANGE);
		phe_info->u4HeCap |= (phy_info->bw20_242tone << STA_REC_HE_CAP_BW20_RU242_SUPPORT);
		phe_info->ucChBwSet = phy_info->ch_width_set;
		phe_info->ucDeviceClass = phy_info->device_class;
		phe_info->ucPuncPreamRx = phy_info->punctured_preamble_rx;
		phe_info->ucPktExt = 2;	/* force Packet Extension as 16 us by default */
		phe_info->ucDcmTxMode = phy_info->dcm_cap_tx;
		phe_info->ucDcmRxMode = phy_info->dcm_cap_rx;
		phe_info->ucDcmTxMaxNss = phy_info->dcm_max_nss_tx;
		phe_info->ucDcmRxMaxNss = phy_info->dcm_max_nss_rx;
		phe_info->ucDcmMaxRu = phy_info->dcm_max_ru;
		/*1024QAM*/
		phe_info->u4HeCap |= (phy_info->tx_le_ru242_1024qam << STA_REC_HE_CAP_TX_1024QAM_UNDER_RU242);
		phe_info->u4HeCap |= (phy_info->rx_le_ru242_1024qam << STA_REC_HE_CAP_RX_1024QAM_UNDER_RU242);
		/*STBC*/
		if (phy_info->stbc_support & HE_LE_EQ_80M_TX_STBC)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_LE_EQ_80M_TX_STBC);
		if (phy_info->stbc_support & HE_LE_EQ_80M_RX_STBC)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_LE_EQ_80M_RX_STBC);
		if (phy_info->stbc_support & HE_GT_80M_RX_STBC)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_GT_80M_RX_STBC);
		if (phy_info->stbc_support & HE_GT_80M_TX_STBC)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_GT_80M_TX_STBC);
		/*GI*/
		if (phy_info->gi_cap & HE_SU_PPDU_1x_LTF_DOT8US_GI)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_SU_PPDU_1x_LTF_DOT8US_GI);
		if (phy_info->gi_cap & HE_SU_PPDU_MU_PPDU_4x_LTF_DOT8US_GI)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_SU_PPDU_MU_PPDU_4x_LTF_DOT8US_GI);
		if (phy_info->gi_cap & HE_ER_SU_PPDU_1x_LTF_DOT8US_GI)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_ER_SU_PPDU_1x_LTF_DOT8US_GI);
		if (phy_info->gi_cap & HE_ER_SU_PPDU_4x_LTF_DOT8US_GI)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_ER_SU_PPDU_4x_LTF_DOT8US_GI);
		if (phy_info->gi_cap & HE_NDP_4x_LTF_3DOT2MS_GI)
			phe_info->u4HeCap |= (1 << STA_REC_HE_CAP_NDP_4x_LTF_3DOT2MS_GI);
		/*MAX NSS MCS*/
		for (i = 0 ; i < HE_MAX_SUPPORT_STREAM; i++) {
			phe_info->au2MaxNssMcs[CMD_HE_MCS_BW80] |= (mcs->bw80_mcs[i] << (i * 2));
			phe_info->au2MaxNssMcs[CMD_HE_MCS_BW160] |= (mcs->bw160_mcs[i] << (i * 2));
			phe_info->au2MaxNssMcs[CMD_HE_MCS_BW8080] |= (mcs->bw8080_mcs[i] << (i * 2));
		}
#ifdef CFG_BIG_ENDIAN
		phe_info->u2Tag = cpu2le16(phe_info->u2Tag);
		phe_info->u2Length = cpu2le16(phe_info->u2Length);
		phe_info->u4HeCap = cpu2le32(phe_info->u4HeCap);
		for (i = 0 ; i < CMD_HE_MCS_BW_NUM ; i++)
			phe_info->au2MaxNssMcs[i] = cpu2le16(phe_info->au2MaxNssMcs[i]);
#endif

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
				"u2Tag %x, u2Length %x, u4HeCap 0x%x, ucChBwSet(%d)\n",
				 phe_info->u2Tag, phe_info->u2Length, phe_info->u4HeCap, phe_info->ucChBwSet);

		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_HW_AMSDU (TAG 0x0F) handler
* refer to StaRecUpdateHwAmsdu
*/
static INT32 UniCmdStaRecHwAmsdu(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_CMD_STAREC_AMSDU_T pCmdStaRecAmsdu = (P_CMD_STAREC_AMSDU_T) pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (pEntry) {
		os_zero_mem(pCmdStaRecAmsdu, sizeof(CMD_STAREC_AMSDU_T));
		pCmdStaRecAmsdu->u2Tag = UNI_CMD_STAREC_HW_AMSDU;
		pCmdStaRecAmsdu->u2Length = sizeof(CMD_STAREC_AMSDU_T);
		pCmdStaRecAmsdu->ucMaxMpduSize = pEntry->AMsduSize;
		pCmdStaRecAmsdu->ucMaxAmsduNum = cap->hw_max_amsdu_nums;
		pCmdStaRecAmsdu->ucAmsduEnable = TRUE;
#ifdef CFG_BIG_ENDIAN
		pCmdStaRecAmsdu->u2Tag = cpu2le16(pCmdStaRecAmsdu->u2Tag);
		pCmdStaRecAmsdu->u2Length = cpu2le16(pCmdStaRecAmsdu->u2Length);
#endif
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_HW_AMSDU (STA_REC_HW_AMSDU_FEATURE)\n");
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"ucMaxAmsduNum=0x%x,ucMaxMpduSize=0x%x,ucAmsduEnable=0x%x,\n",
			pCmdStaRecAmsdu->ucMaxAmsduNum, pCmdStaRecAmsdu->ucMaxMpduSize,
			pCmdStaRecAmsdu->ucAmsduEnable);

		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}


/*
* Unified command UNI_CMD_STAREC_INSTALL_KEY (TAG 0x0C)
* and UNI_CMD_STAREC_INSTALL_KEY_V2 (TAG 11) handler
* refer to StaRecUpdateSecKey
*/
static INT32 UniCmdStaRecInstallKeyFeature(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	ASIC_SEC_INFO *asic_sec_info = &pStaRecCfg->asic_sec_info;
	INT32  Ret = NDIS_STATUS_SUCCESS;

	Ret = chip_fill_key_install_uni_cmd(pAd->hdev_ctrl,
				asic_sec_info, STAREC_SEC_KEY_METHOD, pHandle);

	HOST_DBG(pAd, "[logan] %s: PeerAddr("
		MACSTR") Wcid=0x%x (%d), Cipher=0x%x, BssIndex=0x%x, Operation=%d\n",
		__func__,
		MAC2STR(asic_sec_info->PeerAddr),
		asic_sec_info->Wcid,
		asic_sec_info->Wcid,
		asic_sec_info->Cipher,
		asic_sec_info->BssIndex,
		IS_REMOVEKEY_OPERATION(asic_sec_info));
	HOST_DBG(pAd, "[logan] %s: KeyIdx=0x%x, igtk_key_idx=0x%x, bigtk_key_idx=0x%x\n",
		__func__,
		asic_sec_info->KeyIdx,
		asic_sec_info->igtk_key_idx,
		asic_sec_info->bigtk_key_idx);
	return Ret;
}

/*
* Unified command UNI_CMD_STAREC_BF (TAG 0x04)
* refer to StaRecUpdateBf
*/
#ifdef TXBF_SUPPORT
static INT32 UniCmdStaRecUpdateBf(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	P_UNI_CMD_STAREC_BF_T pCmdStaRecBf = (P_UNI_CMD_STAREC_BF_T) pHandle;

	if (pEntry) {
		os_zero_mem(pCmdStaRecBf, sizeof(UNI_CMD_STAREC_BF_T));
		UniCmdStaRecBfUpdate(pEntry, pCmdStaRecBf);
		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}
#endif

/*
* Unified command UNI_CMD_STAREC_AP_PS (TAG 0x0b)
* refer to StaRecUpdateApPs
*/
static INT32 UniCmdStaRecUpdateApPs(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	P_CMD_STAREC_PS_T pCmdPsInfo = (P_CMD_STAREC_PS_T) pHandle;
	UINT8 IdApsd;
	UINT8 ACTriSet = 0;
	UINT8 ACDelSet = 0;

	if (pEntry) {
		/* Fill TLV format */
		pCmdPsInfo->u2Tag = UNI_CMD_STAREC_AP_PS;
		pCmdPsInfo->u2Length = sizeof(CMD_STAREC_PS_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_AP_PS (STA_REC_AP_PS_FEATURE)\n");
		/* Find Triggerable AC */
		/* Find Deliverable AC */
		ACTriSet = 0;
		ACDelSet = 0;

		for (IdApsd = 0; IdApsd < 4; IdApsd++) {
			if (pEntry->bAPSDCapablePerAC[IdApsd])
				ACTriSet |= 1 << IdApsd;

			if (pEntry->bAPSDDeliverEnabledPerAC[IdApsd])
				ACDelSet |= 1 << IdApsd;
		}

		pCmdPsInfo->ucStaBmpTriggerAC = ACTriSet;
		pCmdPsInfo->ucStaBmpDeliveryAC = ACDelSet;
		pCmdPsInfo->ucStaMaxSPLength = pStaRecCfg->pEntry->MaxSPLength;
		pCmdPsInfo->u2StaListenInterval = 0; /* TODO: */
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
				 "(STA_REC_AP_PS), Delv=%x Trig=%x SP=%d LInt=%d",
				  pCmdPsInfo->ucStaBmpDeliveryAC,
				  pCmdPsInfo->ucStaBmpTriggerAC,
				  pCmdPsInfo->ucStaMaxSPLength,
				  pCmdPsInfo->u2StaListenInterval);
#ifdef CFG_BIG_ENDIAN
		pCmdPsInfo->u2Tag = cpu2le16(pCmdPsInfo->u2Tag);
		pCmdPsInfo->u2Length = cpu2le16(pCmdPsInfo->u2Length);
		pCmdPsInfo->u2StaListenInterval = cpu2le16(pCmdPsInfo->u2StaListenInterval);
#endif
		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_MURU (TAG 0x12)
* refer to sta_rec_update_muru_info
*/
INT32 UniCmdStaRecUpdateMuruInfo(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_CMD_STAREC_MURU_T pmuru_info = NULL;
	P_MURU_WDEV_CFG wdev_cfg = NULL;
	P_MURU_STA_DL_OFDMA dl_ofdma = NULL;
	P_MURU_STA_UL_OFDMA ul_ofdma = NULL;
	P_MURU_STA_DL_MIMO dl_mimo = NULL;
	P_MURU_STA_UL_MIMO ul_mimo = NULL;
	MAC_TABLE_ENTRY *pEntry = NULL;
	struct wifi_dev *wdev = NULL;

	if ((pHandle == NULL) || (pStaRecCfg == NULL))
		return NDIS_STATUS_FAILURE;

	pmuru_info = (P_CMD_STAREC_MURU_T) pHandle;
	wdev_cfg = &pmuru_info->rMuRuStaCap.rWdevCfg;
	dl_ofdma = &pmuru_info->rMuRuStaCap.rDlOfdma;
	ul_ofdma = &pmuru_info->rMuRuStaCap.rUlOfdma;
	dl_mimo = &pmuru_info->rMuRuStaCap.rDlMimo;
	ul_mimo = &pmuru_info->rMuRuStaCap.rUlMimo;
	pEntry = pStaRecCfg->pEntry;

	os_zero_mem(pmuru_info, sizeof(CMD_STAREC_MURU_T));

	if (pEntry) {
		wdev = pEntry->wdev;

		if ((wdev == NULL) || (wdev_cfg == NULL)
				|| (dl_ofdma == NULL) || (ul_ofdma == NULL)
				|| (dl_mimo == NULL) || (ul_mimo == NULL))
			return NDIS_STATUS_FAILURE;

		pmuru_info->u2Tag = UNI_CMD_STAREC_MURU;
		pmuru_info->u2Length = sizeof(CMD_STAREC_MURU_T);
#ifdef CFG_BIG_ENDIAN
		pmuru_info->u2Tag = cpu2le16(pmuru_info->u2Tag);
		pmuru_info->u2Length	= cpu2le16(pmuru_info->u2Length);
#endif
		/* global wdev setting */
		wdev_cfg->fgDlOfdmaEn = wlan_config_get_mu_dl_ofdma(wdev);
		wdev_cfg->fgUlOfdmaEn = wlan_config_get_mu_ul_ofdma(wdev);
		wdev_cfg->fgDlMimoEn = wlan_config_get_mu_dl_mimo(wdev);
		wdev_cfg->fgUlMimoEn = wlan_config_get_mu_ul_mimo(wdev);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_MURU (STA_REC_MURU_FEATURE)\n");

		/* Sta Cap. of DL OFDMA */
		dl_ofdma->u1PhyPunRx = pEntry->cap.punc_preamble_rx;
		dl_ofdma->u120MIn40M2G = (pEntry->cap.he_phy_cap & HE_24G_20M_IN_40M_PPDU) ? 1 : 0;
		dl_ofdma->u120MIn160M = (pEntry->cap.he_phy_cap & HE_20M_IN_160M_8080M_PPDU) ? 1 : 0;
		dl_ofdma->u180MIn160M = (pEntry->cap.he_phy_cap & HE_80M_IN_160M_8080M_PPDU) ? 1 : 0;
		dl_ofdma->u1Lt16SigB = 0;				/* Wait he_phy_cap to support the cap */
		dl_ofdma->u1RxSUCompSigB = 0;			/* Wait he_phy_cap to support the cap */
		dl_ofdma->u1RxSUNonCompSigB = 0;		/* Wait he_phy_cap to support the cap */

		/* Sta Cap. of UL OFDMA */
		ul_ofdma->u1TrigFrmPad = pEntry->cap.tf_mac_pad_duration;
		ul_ofdma->u1MuCascading = (pEntry->cap.he_mac_cap & HE_MU_CASCADING) ? 1 : 0;
		ul_ofdma->u1UoRa = (pEntry->cap.he_mac_cap & HE_OFDMA_RA) ? 1 : 0;
		ul_ofdma->u12x996Tone = 0;				/* Wait he_mac_cap to support the cap */
		ul_ofdma->u1RxTrgFrmBy11ac = 0;			/* Wait he_mac_cap to support the cap */
		ul_ofdma->u1RxCtrlFrmToMBss = (pEntry->cap.he_mac_cap & HE_RX_CTRL_FRAME_TO_MULTIBSS) ? 1 : 0;

		/* Sta Cap. of DL MIMO */
		dl_mimo->fgVhtMuBfee = pEntry->vht_cap_ie.vht_cap.bfee_cap_mu;
		dl_mimo->fgParBWDlMimo = (pEntry->cap.he_phy_cap & HE_PARTIAL_BW_DL_MU_MIMO) ? 1 : 0;

		/* Sta Cap. of UL MIMO */
		ul_mimo->fgFullUlMimo = (pEntry->cap.he_phy_cap & HE_FULL_BW_UL_MU_MIMO) ? 1 : 0;
		ul_mimo->fgParUlMimo = (pEntry->cap.he_phy_cap & HE_PARTIAL_BW_UL_MU_MIMO) ? 1 : 0;

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"fgDlOfdmaEn = 0x%02X, fgUlOfdmaEn = 0x%02X\n",
				wdev_cfg->fgDlOfdmaEn, wdev_cfg->fgUlOfdmaEn);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"fgDlMimoEn = 0x%02X, fgUlMimoEn= 0x%02X\n",
				wdev_cfg->fgDlMimoEn, wdev_cfg->fgUlMimoEn);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1PhyPunRx = 0x%02X, u120MIn40M2G = 0x%02X\n",
				dl_ofdma->u1PhyPunRx, dl_ofdma->u120MIn40M2G);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u120MIn160M = 0x%02X, u180MIn160M= 0x%02X\n",
				dl_ofdma->u120MIn160M, dl_ofdma->u180MIn160M);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1Lt16SigB = 0x%02X, u1RxSUCompSigB = 0x%02X\n",
				dl_ofdma->u1Lt16SigB, dl_ofdma->u1RxSUCompSigB);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1RxSUNonCompSigB = 0x%02X\n",
				dl_ofdma->u1RxSUNonCompSigB);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1TrigFrmPad = 0x%02X, u1MuCascading = 0x%02X\n",
				ul_ofdma->u1TrigFrmPad, ul_ofdma->u1MuCascading);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1UoRa = 0x%02X, u12x996Tone= 0x%02X\n",
				ul_ofdma->u1UoRa, ul_ofdma->u12x996Tone);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1RxTrgFrmBy11ac = 0x%02X\n", ul_ofdma->u1RxTrgFrmBy11ac);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"u1RxCtrlFrmToMBss = 0x%02X\n", ul_ofdma->u1RxCtrlFrmToMBss);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"fgVhtMuBfee = 0x%02X, fgParBWDlMimo = 0x%02X\n",
				dl_mimo->fgVhtMuBfee, dl_mimo->fgParBWDlMimo);

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"fgFullUlMimo = 0x%02X, fgParUlMimo = 0x%02X\n",
				ul_mimo->fgFullUlMimo, ul_mimo->fgParUlMimo);

		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}

/*
* Unified command UNI_CMD_STAREC_BFEE (TAG 0x14)
* refer to StaRecUpdateBfee
*/
#ifdef TXBF_SUPPORT
static INT32 UniCmdStaRecUpdateBfee(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	P_CMD_STAREC_BFEE pCmdStaRecBfee = (P_CMD_STAREC_BFEE) pHandle;

	if (pEntry) {
		os_zero_mem(pCmdStaRecBfee, sizeof(CMD_STAREC_BFEE));
		StaRecBfeeUpdate(pEntry, pCmdStaRecBfee);

		pCmdStaRecBfee->u2Tag = UNI_CMD_STAREC_BFEE;
		pCmdStaRecBfee->u2Length = sizeof(CMD_STAREC_BFEE);
#ifdef CFG_BIG_ENDIAN
		pCmdStaRecBfee->u2Tag = cpu2le16(pCmdStaRecBfee->u2Tag);
		pCmdStaRecBfee->u2Length = cpu2le16(pCmdStaRecBfee->u2Length);
#endif
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_BFEE (STA_REC_BFEE_FEATURE)\n");
		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}
#endif

/*
* Unified command UNI_CMD_STAREC_HE_6G_CAP (TAG 0x17)
*/
static INT32 UniCmdStaRecUpdate6GCap(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	P_CMD_STAREC_HE_6G_CAP_T pCmdStaRecHE6GCap = (P_CMD_STAREC_HE_6G_CAP_T) pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	pCmdStaRecHE6GCap->u2Tag = UNI_CMD_STAREC_HE_6G_CAP;
	pCmdStaRecHE6GCap->u2Length = sizeof(CMD_STAREC_HE_6G_CAP_T);
	if (pEntry)
		pCmdStaRecHE6GCap->u2He6gBandCapInfo = pEntry->cap.he_6g_cap.caps_info;
#ifdef CFG_BIG_ENDIAN
	pCmdStaRecHE6GCap->u2Tag     		 = cpu2le16(pCmdStaRecHE6GCap->u2Tag);
	pCmdStaRecHE6GCap->u2Length     	 = cpu2le16(pCmdStaRecHE6GCap->u2Length);
	pCmdStaRecHE6GCap->u2He6gBandCapInfo = cpu2le16(pCmdStaRecHE6GCap->u2He6gBandCapInfo);
#endif
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_HE_6G_CAP (STA_REC_HE_6G_CAP_FEATURE)\n");

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"T=0x%x,L=%d,u2He6gBandCapInfo=0x%x.\n",
		pCmdStaRecHE6GCap->u2Tag,
		pCmdStaRecHE6GCap->u2Length,
		pCmdStaRecHE6GCap->u2He6gBandCapInfo);
	return NDIS_STATUS_SUCCESS;
}

static VOID StaRecHeBasicCapAdjust(
	struct _RTMP_ADAPTER *pAd,
	MAC_TABLE_ENTRY *pEntry,
	struct CMD_STAREC_HE_BASIC_T *pHeBasic)
{
	struct wifi_dev *wdev = NULL;
	UINT8 ucTemp = 0;

	if ((pEntry == NULL) ||
		(pEntry->wdev == NULL) ||
		(pHeBasic == NULL))
		return;

	wdev = pEntry->wdev;
	if (wlan_config_get_he_ldpc(wdev) == 0) {
		/* DOT11AX_PHY_CAP_LDPC */
		ucTemp = pHeBasic->aucHePhyCapInfo[1];
		ucTemp &= ~((UINT8)1 << 5);
		pHeBasic->aucHePhyCapInfo[1] = ucTemp;
	}

	if ((wlan_config_get_he_tx_stbc(wdev) == 0) &&
		(wlan_config_get_he_rx_stbc(wdev) == 0)) {
		/* DOT11AX_PHY_CAP_TX_STBC_LE_EQ_80M */
		/* DOT11AX_PHY_CAP_RX_STBC_LE_EQ_80M */
		ucTemp = pHeBasic->aucHePhyCapInfo[1];
		ucTemp &= ~((UINT8)1 << 10);
		ucTemp &= ~((UINT8)1 << 11);
		pHeBasic->aucHePhyCapInfo[1] = ucTemp;

		/* DOT11AX_PHY_CAP_TX_STBC_GT_80M */
		/* DOT11AX_PHY_CAP_RX_STBC_GT_80M */
		ucTemp = pHeBasic->aucHePhyCapInfo[4];
		ucTemp &= ~((UINT8)1 << 6);
		ucTemp &= ~((UINT8)1 << 7);
		pHeBasic->aucHePhyCapInfo[4] = ucTemp;
	}

	if (wlan_config_get_he_dyn_smps(wdev) == 0) {
		/* DOT11AX_MAC_CAP_HE_DYN_SMPS */
		ucTemp = pHeBasic->aucHeMacCapInfo[5];
		ucTemp &= ~((UINT8)1 << 5);
		pHeBasic->aucHeMacCapInfo[5] = ucTemp;
	}
}

/*
* Unified command UNI_CMD_STAREC_HE_BASIC (TAG 0x19) handler
* refer to sta_rec_update_he_info
*/
static INT32 UniCmdStaRecHeBasic(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	struct CMD_STAREC_HE_BASIC_T *he_basic = (struct CMD_STAREC_HE_BASIC_T *)pHandle;
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct he_mcs_info *mcs = &pStaRecCfg->he_sta.max_nss_mcs;
	int i;

	if (pEntry || pStaRecCfg->ConnectionType == CONNECTION_INFRA_BC) {
		os_zero_mem(he_basic, sizeof(struct CMD_STAREC_HE_BASIC_T));
		he_basic->u2Tag = UNI_CMD_STAREC_HE_BASIC;
		he_basic->u2Length = sizeof(struct CMD_STAREC_HE_BASIC_T);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"=> UNI_CMD_STAREC_HE_BASIC (STA_REC_HE_BASIC_FEATURE)\n");

		/*mac info*/
		if (pEntry)
			os_move_mem(&he_basic->aucHeMacCapInfo[0], &pEntry->aucHeMacCapInfo[0],
				sizeof(he_basic->aucHeMacCapInfo));

		/*phy info*/
		if (pEntry)
			os_move_mem(&he_basic->aucHePhyCapInfo[0], &pEntry->aucHePhyCapInfo[0],
				sizeof(he_basic->aucHePhyCapInfo));

		/* Check if our device related capability support or not */
		StaRecHeBasicCapAdjust(pAd, pEntry, he_basic);

		/* packet extension */
		he_basic->ucPktExt = 2;	/* force Packet Extension as 16 us by default */

		/*MAX NSS MCS*/
		for (i = 0 ; i < HE_MAX_SUPPORT_STREAM; i++) {
			he_basic->au2RxMaxNssMcs[CMD_HE_MCS_BW80] |= (mcs->bw80_mcs[i] << (i * 2));
			he_basic->au2RxMaxNssMcs[CMD_HE_MCS_BW160] |= (mcs->bw160_mcs[i] << (i * 2));
			he_basic->au2RxMaxNssMcs[CMD_HE_MCS_BW8080] |= (mcs->bw8080_mcs[i] << (i * 2));
		}
#ifdef CFG_BIG_ENDIAN
		he_basic->u2Tag = cpu2le16(he_basic->u2Tag);
		he_basic->u2Length = cpu2le16(he_basic->u2Length);
		for (i = 0 ; i < CMD_HE_MCS_BW_NUM ; i++)
			he_basic->au2RxMaxNssMcs[i] = cpu2le16(he_basic->au2RxMaxNssMcs[i]);
#endif
		hex_dump_with_cat_and_lvl("aucHeMacCapInfo", he_basic->aucHeMacCapInfo, sizeof(he_basic->aucHeMacCapInfo), DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG);
		hex_dump_with_cat_and_lvl("aucHePhyCapInfo", he_basic->aucHePhyCapInfo, sizeof(he_basic->aucHePhyCapInfo), DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG);

		return NDIS_STATUS_SUCCESS;
	}

	return NDIS_STATUS_FAILURE;
}

INT32 UniCmdStaRecWTBLHeaderTrans(
	struct _RTMP_ADAPTER *pAd,
	UINT32 wcid,
	UINT8 DIS_RHTR)
{
	PSTA_ADMIN_CONFIG pStaCfg;
	MAC_TABLE_ENTRY *pEntry = NULL;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_HDR_TRANS_T wtbl_header_trans;
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	if (VALID_UCAST_ENTRY_WCID(pAd, wcid)) {
		pEntry = entry_get(pAd, wcid);
		if ((pEntry == NULL) || (pEntry->wdev == NULL)) {
			MTWF_PRINT("pEntry or wdev is NULL ptr!\n");
			ret = NDIS_STATUS_FAILURE;
			goto error;
		}
		if (!IS_VALID_ENTRY(pEntry)) {
			MTWF_PRINT("pEntry is invalid!\n");
			ret = NDIS_STATUS_FAILURE;
			goto error;
		}
	} else {
		MTWF_PRINT("non unicast wcid!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&wtbl_header_trans, sizeof(wtbl_header_trans));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(wtbl_header_trans);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = pEntry->wdev->bss_info_argument.ucBssIndex;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL, wcid);
	CmdStaRecUpdate.ucMuarIdx = 0; /* useless for this cmd */
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STAREC_HDR_TRANS_T */
	wtbl_header_trans.u2Tag = UNI_CMD_STAREC_HDR_TRANS;
	wtbl_header_trans.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	wtbl_header_trans.ucDisRxHdrTran = DIS_RHTR;

	if (pEntry->wdev->wdev_type == WDEV_TYPE_AP) {
		wtbl_header_trans.ucFromDs = 1;
		wtbl_header_trans.ucToDs = 0;
#ifdef MWDS
		if ((pEntry->bSupportMWDS && pEntry->wdev->bSupportMWDS)
#ifdef CONFIG_MAP_SUPPORT
			|| IS_MAP_ENABLE(pAd)
#endif /* CONFIG_MAP_SUPPORT */
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			|| (pEntry->bEnable4Addr && pEntry->wdev->wds_enable)
#endif
		) {
			wtbl_header_trans.ucFromDs = 1;
			wtbl_header_trans.ucToDs = 1;
		}
#endif
	}

#ifdef CONFIG_STA_SUPPORT
	if (pEntry->wdev->wdev_type == WDEV_TYPE_STA) {
		wtbl_header_trans.ucFromDs = 0;
		wtbl_header_trans.ucToDs = 1;
		pStaCfg = GetStaCfgByWdev(pAd, pEntry->wdev);
		if (pStaCfg == NULL) {
			MTWF_PRINT("pStaCfg is invalid!\n");
			ret = NDIS_STATUS_FAILURE;
			goto error;
		}
#ifdef MWDS
		if ((pStaCfg->MlmeAux.bSupportMWDS && pEntry->wdev->bSupportMWDS)
#ifdef CONFIG_MAP_SUPPORT
			|| IS_MAP_ENABLE(pAd)
#endif /* CONFIG_MAP_SUPPORT */
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			|| (pEntry->bEnable4Addr && pEntry->wdev->wds_enable)
#endif
		) {
			wtbl_header_trans.ucFromDs = 1;
			wtbl_header_trans.ucToDs = 1;
		}
#endif
	}
#endif

	AndesAppendCmdMsg(msg, (char *)&wtbl_header_trans, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"T=0x%x,L=%d,ucFromDs=%d,ucToDs=%d,ucDisRxHdrTran=%d\n",
		wtbl_header_trans.u2Tag,
		wtbl_header_trans.u2Length,
		wtbl_header_trans.ucFromDs,
		wtbl_header_trans.ucToDs,
		wtbl_header_trans.ucDisRxHdrTran);

	/* Step 5: Send out CMD */
	ret = AndesSendCmdMsg(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

static INT32 UniCmdStaRecHdrTrans(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	PSTA_ADMIN_CONFIG pStaCfg;

	if ((pEntry == NULL) || (pEntry->wdev == NULL))
		return NDIS_STATUS_FAILURE;

	if (pEntry->wdev->wdev_type == WDEV_TYPE_AP) {
#ifdef MWDS
		if ((pEntry->bSupportMWDS && pEntry->wdev->bSupportMWDS)
#ifdef CONFIG_MAP_SUPPORT
			|| IS_MAP_ENABLE(pAd)
#endif /* CONFIG_MAP_SUPPORT */
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			|| (pEntry->bEnable4Addr)
#endif

		) {
			struct UNI_CMD_STAREC_HDR_TRANS_T *hdr_trans =
				(struct UNI_CMD_STAREC_HDR_TRANS_T *) pHandle;
			hdr_trans->u2Tag = UNI_CMD_STAREC_HDR_TRANS;
			hdr_trans->u2Length = sizeof(struct UNI_CMD_STAREC_HDR_TRANS_T);
			hdr_trans->ucFromDs = 1;
			hdr_trans->ucToDs = 1;
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			if ((!pEntry->wdev->wds_enable)
#ifdef MWDS
				&& (!pEntry->bSupportMWDS)
#endif
#ifdef CONFIG_MAP_SUPPORT
				&& (!IS_MAP_ENABLE(pAd))
#endif
			) {
				if (IS_ENTRY_CLIENT(pEntry))
					hdr_trans->ucToDs = 0;
			}
#endif
			hdr_trans->ucDisRxHdrTran = 0;
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"=> UNI_CMD_STAREC_HDR_TRANS (STA_REC_HDR_TRANS_FEATURE)\n");
			return NDIS_STATUS_SUCCESS;
		}
#endif
	}

#ifdef CONFIG_STA_SUPPORT
	if (pEntry->wdev->wdev_type == WDEV_TYPE_STA) {
		pStaCfg = GetStaCfgByWdev(pAd, pEntry->wdev);
		if (pStaCfg == NULL)
			return NDIS_STATUS_FAILURE;
#ifdef MWDS
		if ((pStaCfg->MlmeAux.bSupportMWDS && pEntry->wdev->bSupportMWDS)
#ifdef CONFIG_MAP_SUPPORT
			|| IS_MAP_ENABLE(pAd)
#endif /* CONFIG_MAP_SUPPORT */
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			|| (pEntry->bEnable4Addr)
#endif
		) {
			struct UNI_CMD_STAREC_HDR_TRANS_T *hdr_trans =
				(struct UNI_CMD_STAREC_HDR_TRANS_T *) pHandle;
			hdr_trans->u2Tag = UNI_CMD_STAREC_HDR_TRANS;
			hdr_trans->u2Length = sizeof(struct UNI_CMD_STAREC_HDR_TRANS_T);
			hdr_trans->ucFromDs = 1;
			hdr_trans->ucToDs = 1;
#if defined(MBSS_AS_WDS_AP_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT)
			if ((!pEntry->wdev->wds_enable)
#ifdef MWDS
				&& (!pStaCfg->MlmeAux.bSupportMWDS)
#endif
#ifdef CONFIG_MAP_SUPPORT
				&& (!IS_MAP_ENABLE(pAd))
#endif
			) {
				if (IS_ENTRY_PEER_AP(pEntry))
					hdr_trans->ucFromDs = 0;
			}
#endif
			hdr_trans->ucDisRxHdrTran = 0;
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
				"=> UNI_CMD_STAREC_HDR_TRANS (STA_REC_HDR_TRANS_FEATURE)\n");
			return NDIS_STATUS_SUCCESS;
		}
#endif
	}
#endif
	return NDIS_STATUS_FAILURE;
}

#ifdef MLR_SUPPORT
static INT32 UniCmdStaRecMlrInfo(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct UNI_CMD_STAREC_MLR_INFO_T *mlr_info =
			(struct UNI_CMD_STAREC_MLR_INFO_T *) pHandle;

	if ((pEntry == NULL) || (pEntry->wdev == NULL))
		return NDIS_STATUS_FAILURE;

	mlr_info->u2Tag = STA_REC_MLR_INFO;
	mlr_info->u2Length = sizeof(struct UNI_CMD_STAREC_MLR_INFO_T);
	mlr_info->ucMlrMode = pEntry->MlrMode;
	mlr_info->ucMlrState = pEntry->MlrCurState;
	MTWF_DBG(NULL, DBG_CAT_MLR, CATMLR_CFG, DBG_LVL_DEBUG,
		"=> STA_REC_MLR_INFO_FEATURE, tag=%d, MlrMode=%d, MlrState=%d\n",
		mlr_info->u2Tag, mlr_info->ucMlrMode, mlr_info->ucMlrState);

	return NDIS_STATUS_SUCCESS;
}

INT32 UniCmdStaRecForceMlrState(
	struct _RTMP_ADAPTER *pAd,
	UINT16 Wcid,
	UINT8 ForceState)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_MLR_INFO_T CmdStaMlrStateUpdate;
	struct _CMD_ATTRIBUTE attr = {0};
	MAC_TABLE_ENTRY *pMacEntry = NULL;
	UINT8 MlrMode = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLR, CATMLR_CFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaMlrStateUpdate, sizeof(CmdStaMlrStateUpdate));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaMlrStateUpdate);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill common parameters here */
	if (VALID_UCAST_ENTRY_WCID(pAd, Wcid)) {
		pMacEntry = entry_get(pAd, Wcid);
		if (pMacEntry->wdev) {
			CmdStaRecUpdate.ucBssInfoIdx = pMacEntry->wdev->bss_info_argument.ucBssIndex;
			MlrMode = pMacEntry->MlrMode;
		} else
			CmdStaRecUpdate.ucBssInfoIdx = 0;
	} else {
		CmdStaRecUpdate.ucBssInfoIdx = 0;
	}
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL, Wcid);
	CmdStaRecUpdate.ucMuarIdx = 0; /* useless for this cmd */
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STAREC_EML_OP_T */
	CmdStaMlrStateUpdate.u2Tag = UNI_CMD_STA_REC_MLR_INFO;
	CmdStaMlrStateUpdate.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	CmdStaMlrStateUpdate.ucMlrMode = MlrMode;
	CmdStaMlrStateUpdate.ucMlrStateForceType = ForceState;
	MTWF_DBG(NULL, DBG_CAT_MLR, CATMLR_CFG, DBG_LVL_DEBUG,
		"=> UNI_CMD_STA_REC_MLR_INFO, Wcid %d, ucMlrMode %d, ucMlrStateForceType %d\n",
			Wcid, CmdStaMlrStateUpdate.ucMlrMode, CmdStaMlrStateUpdate.ucMlrStateForceType);

	AndesAppendCmdMsg(msg, (char *)&CmdStaMlrStateUpdate, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_MLR, CATMLR_CFG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif

static INT32 UniCmdStaRecA4Info(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct UNI_CMD_STAREC_A4_INFO_T *a4_info =
			(struct UNI_CMD_STAREC_A4_INFO_T *) pHandle;

	if ((pEntry == NULL) || (pEntry->wdev == NULL))
		return NDIS_STATUS_FAILURE;

	a4_info->u2Tag = STA_REC_A4_INFO;
	a4_info->u2Length = sizeof(struct UNI_CMD_STAREC_A4_INFO_T);
	a4_info->ucA4Cap = 1;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
		"=> UNI_CMD_STA_REC_A4_INFO, tag=%d,a4_cap=%d\n",
		a4_info->u2Tag, a4_info->ucA4Cap);

	return NDIS_STATUS_SUCCESS;
}

static INT32 UniCmdStaRecRCA1(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	MAC_TABLE_ENTRY *pEntry = pStaRecCfg->pEntry;
	struct UNI_CMD_STAREC_RCA1_T *CmdStaRecRCA1 = (struct UNI_CMD_STAREC_RCA1_T *) pHandle;

	if ((pEntry == NULL) || (pEntry->wdev == NULL))
		return NDIS_STATUS_FAILURE;

	CmdStaRecRCA1->u2Tag = UNI_CMD_STA_REC_RCA1;
	CmdStaRecRCA1->u2Length = sizeof(struct UNI_CMD_STAREC_RCA1_T);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STA_REC_RCA1 (STA_REC_RCA1_FEATURE)\n");
	CmdStaRecRCA1->fgEnable = 0;

	return NDIS_STATUS_SUCCESS;
}



#ifdef DOT11_EHT_BE
/*
 * convert protocol link_id to hardware band_id
 */
static NDIS_STATUS link2band(struct _MAC_TABLE_ENTRY *pEntry, UINT8 link_id, UINT8 *band_id)
{
	struct _MAC_TABLE_ENTRY *peer_entry = NULL;
	struct mld_entry_t *mld_entry = NULL;

	mt_rcu_read_lock();

	if (!pEntry || !pEntry->mlo.mlo_en || link_id >= MLD_LINK_MAX) {
		mt_rcu_read_unlock();
		return NDIS_STATUS_INVALID_DATA;
	}

	mld_entry = get_mld_entry_by_mac(pEntry->mlo.mld_addr);
	if (!mld_entry) {
		mt_rcu_read_unlock();
		return NDIS_STATUS_INVALID_DATA;
	}

	peer_entry = (struct _MAC_TABLE_ENTRY *)mld_entry->link_entry[link_id];
	mt_rcu_read_unlock();
	if (!peer_entry || !peer_entry->mlo.mlo_en || !peer_entry->wdev)
		return NDIS_STATUS_INVALID_DATA;

	*band_id = HcGetBandByWdev(peer_entry->wdev);

	return NDIS_STATUS_SUCCESS;

}

/*
* STA_REC_MLD_SETUP(0x20) of UNI_CMD_ID_STAREC_INFO command (0x03)
*/
INT32 UniCmdStaRecMldSetup(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	int ret = NDIS_STATUS_FAILURE;
	struct _MAC_TABLE_ENTRY *entry = NULL;
	struct _MAC_TABLE_ENTRY *setup_link_entry = NULL;
	void *link_entry = NULL;
	struct mld_entry_t *mld_entry = NULL;
	struct peer_mld peer_mld_hw_info = {0};
	struct CMD_STAREC_LINK_INFO_T *link_info = NULL;
	uint8_t i = 0;
	struct CMD_STAREC_MLD_SETUP_T *pCmdStaRecMldSetup =
		(struct CMD_STAREC_MLD_SETUP_T *)pHandle;

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		return ret;
	}

	if (!entry->mlo.mlo_en) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):mlo_en=%d\n", entry->mlo.mlo_en);
		return ret;
	}

	mt_rcu_read_lock();
	mld_entry = get_mld_entry_by_mac(entry->mlo.mld_addr);
	if (!mld_entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):mld_entry=NULL\n");
		mt_rcu_read_unlock();
		return ret;
	}

	if (MAC_ADDR_EQUAL(mld_entry->addr, ZERO_MAC_ADDR)) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):peer_mld_addr=zero\n");
		mt_rcu_read_unlock();
		return ret;
	}

	if (mld_entry->link_num == 0 ||
		mld_entry->link_num > MLD_LINK_MAX) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):link_num=%d\n", mld_entry->link_num);
		mt_rcu_read_unlock();
		return ret;
	}

	ret = hc_get_peer_mld(pAd, entry->wcid, &peer_mld_hw_info);
	if (ret) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):ret=%d\n", ret);
		mt_rcu_read_unlock();
		return ret;
	}

	setup_link_entry = (struct _MAC_TABLE_ENTRY *)mld_entry->link_entry[mld_entry->setup_link_id];
	pCmdStaRecMldSetup->u2Tag = UNI_CMD_STAREC_MLD_SETUP;
	pCmdStaRecMldSetup->u2Length = sizeof(struct CMD_STAREC_MLD_SETUP_T) +
		sizeof(struct CMD_STAREC_LINK_INFO_T) * mld_entry->link_num;
#ifdef CFG_BIG_ENDIAN
	pCmdStaRecMldSetup->u2Tag = cpu2le16(pCmdStaRecMldSetup->u2Tag);
	pCmdStaRecMldSetup->u2Length = cpu2le16(pCmdStaRecMldSetup->u2Length);
#endif
	os_move_mem(pCmdStaRecMldSetup->aucPeerMldAddr, mld_entry->addr, MAC_ADDR_LEN);
	pCmdStaRecMldSetup->u2PrimaryMldId = peer_mld_hw_info.mld_primary_idx;
	pCmdStaRecMldSetup->u2SecondMldId = peer_mld_hw_info.mld_secondary_idx;
	pCmdStaRecMldSetup->u2SetupWlanId = mld_entry->setup_link_wcid;
	pCmdStaRecMldSetup->ucLinkNumber = mld_entry->link_num;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_MLD_SETUP (STA_REC_MLD_SETUP_FEATURE)\n");

	link_info = (struct CMD_STAREC_LINK_INFO_T *)pCmdStaRecMldSetup->aucLinkInfo;

	for (i = 0; i < MLD_LINK_MAX; i++) {
		link_entry = mld_entry->link_entry[i];
		if (link_entry) {
			link_info->u2WlanIdx =  ((struct _MAC_TABLE_ENTRY *)link_entry)->wcid;
			link_info->ucBssIdx = ((struct _MAC_TABLE_ENTRY *)link_entry)->wdev->bss_info_argument.ucBssIndex;
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_INFO,
				"i=%d,wcid=%d,bss_idx=%d\n",
				i, link_info->u2WlanIdx, link_info->ucBssIdx);
			link_info++;
		}
	}
	mt_rcu_read_unlock();

	if (entry->vendor_ie.mtk_mlo_enable & MEDIATEK_TLV1_TYPE4_MLO_V1) {
		pCmdStaRecMldSetup->ucExtraInfo |= STAREC_MLD_SETUP_EXTRAINFO_MTK_MLO;
		pCmdStaRecMldSetup->ucExtraInfo |= STAREC_MLD_SETUP_EXTRAINFO_DRAFT1DOT2;
	} else if (entry->vendor_ie.mtk_mlo_enable & MEDIATEK_TLV1_TYPE4_MLO_V1_1)
		pCmdStaRecMldSetup->ucExtraInfo |= STAREC_MLD_SETUP_EXTRAINFO_DRAFT1DOT2;

	/* TODO: DBG_LVL_OFF --> DBG_LVL_INFO when stable */
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
		"T=%d,L=%d,primary_mld_id=%d,second_mld_id=%d,\n",
		pCmdStaRecMldSetup->u2Tag,
		pCmdStaRecMldSetup->u2Length,
		pCmdStaRecMldSetup->u2PrimaryMldId,
		pCmdStaRecMldSetup->u2SecondMldId);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
		"setup_link_wcid=%d,link_num=%d,peer_mld_addr=%pM\n",
		pCmdStaRecMldSetup->u2SetupWlanId,
		pCmdStaRecMldSetup->ucLinkNumber,
		pCmdStaRecMldSetup->aucPeerMldAddr);

	return NDIS_STATUS_SUCCESS;
}

/*
* STA_REC_MLD_BASIC(0x21) of UNI_CMD_ID_STAREC_INFO command (0x03)
*/
INT32 UniCmdStaRecEhtMld(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	int ret = NDIS_STATUS_FAILURE, i = 0, link = 0;
	UINT8 hw_band_idx, peer_hw_band_idx;
	struct _MAC_TABLE_ENTRY *entry = NULL;
	struct mld_entry_t *mld_entry = NULL;
	struct CMD_STAREC_EHT_MLD_T *pCmdStaRecEhtMld =
		(struct CMD_STAREC_EHT_MLD_T *)pHandle;

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		return ret;
	}

	if (!entry->mlo.mlo_en) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):mlo_en=%d\n", entry->mlo.mlo_en);
		return ret;
	}

	mt_rcu_read_lock();
	mld_entry = get_mld_entry_by_mac(entry->mlo.mld_addr);
	if (!mld_entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
			"(ERROR):mlo_info=NULL\n");
		mt_rcu_read_unlock();
		return ret;
	}

	pCmdStaRecEhtMld->u2Tag = UNI_CMD_STAREC_EHT_MLD;
	pCmdStaRecEhtMld->u2Length = sizeof(struct CMD_STAREC_EHT_MLD_T);
#ifdef CFG_BIG_ENDIAN
	pCmdStaRecEhtMld->u2Tag = cpu2le16(pCmdStaRecEhtMld->u2Tag);
	pCmdStaRecEhtMld->u2Length = cpu2le16(pCmdStaRecEhtMld->u2Length);
#endif
	pCmdStaRecEhtMld->fgNSEP =
		((wlan_config_get_nsep_priority_access(entry->wdev) &
		mld_entry->nsep) ? 1 : 0);

	pCmdStaRecEhtMld->aucEmlCap = cpu2le16(mld_entry->eml_cap);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_EHT_MLD (STA_REC_EHT_MLD_FEATURE)\n");

	/* set STR among all bands by default */
	for (i = 0; i < CFG_WIFI_RAM_BAND_NUM; i++)
		pCmdStaRecEhtMld->afgStrCapBitmap[i] = BITS(0, CFG_WIFI_RAM_BAND_NUM - 1);
	/*
	 * afgStrCapBitmap[index]: 'index' is hardware band index, not the link_id used in driver.
	 * Therefore, need to convert bitmap to correct bitmap following hw band index rule,
	 * and put in corresponding band_idx.
	 */
	for (link = 0; link < MLD_LINK_MAX; link++) {
		ret = link2band(entry, link, &hw_band_idx);

		if (ret != NDIS_STATUS_SUCCESS)
			continue;

		for (i = 0; i < MLD_LINK_MAX; i++) {
			ret = link2band(entry, i, &peer_hw_band_idx);

			if (ret != NDIS_STATUS_SUCCESS)
				continue;

			if (!(mld_entry->str_map[link] & BIT(i)))
				pCmdStaRecEhtMld->afgStrCapBitmap[hw_band_idx] &= ~(BIT(peer_hw_band_idx));
		}
	}
	mt_rcu_read_unlock();
	/* TODO: DBG_LVL_ERROR --> DBG_LVL_INFO when stable */
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_INFO,
		"T=%d,L=%d,nsep=%d,str[0x%x,0x%x,0x%x],eml cap[0x%x]\n",
		pCmdStaRecEhtMld->u2Tag,
		pCmdStaRecEhtMld->u2Length,
		pCmdStaRecEhtMld->fgNSEP,
		pCmdStaRecEhtMld->afgStrCapBitmap[0],
		pCmdStaRecEhtMld->afgStrCapBitmap[1],
		pCmdStaRecEhtMld->afgStrCapBitmap[2],
		pCmdStaRecEhtMld->aucEmlCap);

	return NDIS_STATUS_SUCCESS;
}

/*
* STA_REC_EHT_BASIC(0x22) of UNI_CMD_ID_STAREC_INFO command (0x03)
*/
static INT32 UniCmdStaRecEhtBasic(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	int ret = NDIS_STATUS_FAILURE;
	struct _MAC_TABLE_ENTRY *entry = NULL;
	struct eht_link_t *link_info = NULL;
	struct CMD_STAREC_EHT_BASIC_T *pCmdStaRecEthBasic =
		(struct CMD_STAREC_EHT_BASIC_T *)pHandle;

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_ERROR,
				"(ERROR):entry=NULL\n");
		return ret;
	}

	if (entry->mlo.mlo_en) {
		link_info = &entry->mlo.link_info;
		pCmdStaRecEthBasic->ucTidBitmap = link_info->tid_map_dl;
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_INFO,
				"mlo_en=%d, dl=0x%.2x, ul=0x%.2x\n",
				entry->mlo.mlo_en,
				link_info->tid_map_dl,
				link_info->tid_map_ul);
	} else
		pCmdStaRecEthBasic->ucTidBitmap = 0xFF;

	pCmdStaRecEthBasic->u2Tag = UNI_CMD_STAREC_EHT_BASIC;
	pCmdStaRecEthBasic->u2Length = sizeof(struct CMD_STAREC_EHT_BASIC_T);
#ifdef CFG_BIG_ENDIAN
	pCmdStaRecEthBasic->u2Tag = cpu2le16(pCmdStaRecEthBasic->u2Tag);
	pCmdStaRecEthBasic->u2Length = cpu2le16(pCmdStaRecEthBasic->u2Length);
#endif

	pCmdStaRecEthBasic->u2EhtMacCap = entry->eht_mac_cap;
	pCmdStaRecEthBasic->u8EhtPhyCap = entry->eht_phy_cap;
	pCmdStaRecEthBasic->u8EhtPhyCapExt = entry->eht_phy_cap_ext;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_EHT_BASIC (STA_REC_EHT_BASIC_FEATURE)\n");

	/*
	 * Update information from peer to WM directly. WM knows how to use these information.
	 */
	NdisMoveMemory((UINT8 *)pCmdStaRecEthBasic->aucMscMap20MHzSta,
		(UINT8 *)&entry->eht_support_mcs_nss.eht_txrx_mcs_nss_20_only,
		sizeof(struct eht_txrx_mcs_nss_20));
	NdisMoveMemory((UINT8 *)pCmdStaRecEthBasic->aucMscMap80MHz,
		(UINT8 *)&entry->eht_support_mcs_nss.eht_txrx_mcs_nss[0],
		sizeof(struct eht_txrx_mcs_nss));
	NdisMoveMemory((UINT8 *)pCmdStaRecEthBasic->aucMscMap160MHz,
		(UINT8 *)&entry->eht_support_mcs_nss.eht_txrx_mcs_nss[1],
		sizeof(struct eht_txrx_mcs_nss));
	NdisMoveMemory((UINT8 *)pCmdStaRecEthBasic->aucMscMap320MHz,
		(UINT8 *)&entry->eht_support_mcs_nss.eht_txrx_mcs_nss[2],
		sizeof(struct eht_txrx_mcs_nss));

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"sta(%pM)T=%d,L=%d,tid=0x%x,EhtMacCap=0x%x,EhtPhyCap=0x%lx,EhtPhyCapExt=0x%lx\n",
		entry->Addr,
		pCmdStaRecEthBasic->u2Tag,
		pCmdStaRecEthBasic->u2Length,
		pCmdStaRecEthBasic->ucTidBitmap,
		pCmdStaRecEthBasic->u2EhtMacCap,
		pCmdStaRecEthBasic->u8EhtPhyCap,
		pCmdStaRecEthBasic->u8EhtPhyCapExt);
	return NDIS_STATUS_SUCCESS;
}

/*
* STA_REC_MLD_TEARDOWN(0x23) of UNI_CMD_ID_STAREC_INFO command (0x03)
*/
static INT32 UniCmdStaRecMldTeardown(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	struct CMD_STAREC_MLD_TEARDOWN_T *pCmdStaRecMldTeardown =
		(struct CMD_STAREC_MLD_TEARDOWN_T *)pHandle;

	pCmdStaRecMldTeardown->u2Tag = UNI_CMD_STAREC_MLD_TEARDOWN;
	pCmdStaRecMldTeardown->u2Length = sizeof(struct CMD_STAREC_MLD_TEARDOWN_T);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_MLD_TEARDOWN (STA_REC_MLD_TEARDOWN_FEATURE)\n");
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_MLD, DBG_LVL_INFO,
		"T=%d,L=%d\n",
		pCmdStaRecMldTeardown->u2Tag,
		pCmdStaRecMldTeardown->u2Length);
	/* wifi_sys_disconn_act->WSYS_NOTIFY_DISCONNT_ACT to del other pEntry? */
#ifdef CFG_BIG_ENDIAN
	pCmdStaRecMldTeardown->u2Tag = cpu2le16(pCmdStaRecMldTeardown->u2Tag);
	pCmdStaRecMldTeardown->u2Length = cpu2le16(pCmdStaRecMldTeardown->u2Length);
#endif

	return NDIS_STATUS_SUCCESS;
}
#endif /* DOT11_EHT_BE */

static INT32 UniCmdStaRecUpdateTxProc(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UNI_CMD_TAG_HANDLE_T *pTagHandle,
	VOID *pHandle)
{
	struct UNI_CMD_STAREC_TX_PROC_T *CmdStaRecTxProc = (struct UNI_CMD_STAREC_TX_PROC_T *) pHandle;
	struct _MAC_TABLE_ENTRY *pEntry = NULL;
#ifdef CONFIG_CSO_SUPPORT
	struct _RTMP_CHIP_CAP *pChipCap = hc_get_chip_cap(pAd->hdev_ctrl);
#endif
/*
#ifndef WMM_ACM_SUPPORT
#ifdef CONFIG_STA_SUPPORT
	STA_REC_CFG_T *pStaRecCfg = (STA_REC_CFG_T *)args;
#endif // CONFIG_STA_SUPPORT
#endif // WMM_ACM_SUPPORT
*/
#if defined(VLAN_SUPPORT) || defined(APCLI_AS_WDS_STA_SUPPORT) || defined(MBSS_AS_WDS_AP_SUPPORT)
#ifdef CONFIG_STA_SUPPORT
	struct _STA_TR_ENTRY *tr_entry = tr_entry_get(pAd, pStaRecCfg->u2WlanIdx);
	struct wifi_dev *bss_wdev = NULL;
#endif /* CONFIG_STA_SUPPORT */
#endif
	UINT8 rx_policy_is_set = FALSE, i;

#ifdef CONFIG_STA_SUPPORT
	pEntry = pStaRecCfg->pEntry;
#endif /* CONFIG_STA_SUPPORT */
	os_zero_mem(CmdStaRecTxProc, sizeof(struct UNI_CMD_STAREC_TX_PROC_T));
	CmdStaRecTxProc->u2Tag = UNI_CMD_STAREC_TX_PROC;
	CmdStaRecTxProc->u2Length = sizeof(struct UNI_CMD_STAREC_TX_PROC_T);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_TX_PROC (STA_REC_TX_PROC_FEATURE)\n");
#ifdef VLAN_SUPPORT
#ifdef CONFIG_STA_SUPPORT
	bss_wdev = tr_entry->wdev;
#endif /* CONFIG_STA_SUPPORT */
	if ((pEntry && pEntry->wdev && pEntry->wdev->bVLAN_Tag) || (bss_wdev && bss_wdev->bVLAN_Tag))
		CmdStaRecTxProc->u4TxProcFlag = 0;
	else
#endif /*VLAN_SUPPORT*/
#ifdef MAP_R2
	if (IS_MAP_R2_ENABLE(pAd)) {
		AsicRxHeaderTransCtl(pAd, TRUE, FALSE, FALSE, FALSE, FALSE);
		rx_policy_is_set = TRUE;
		CmdStaRecTxProc->u4TxProcFlag = 0;
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"set u4TxProcFlag = 0 to keep vlan tag\n");
		if (pEntry && pEntry->wdev)
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"%s\n", pEntry->wdev->if_dev->name);
	} else
#endif
	CmdStaRecTxProc->u4TxProcFlag = UNI_RVLAN;
#if defined(APCLI_AS_WDS_STA_SUPPORT) || defined(MBSS_AS_WDS_AP_SUPPORT)
	if ((pEntry && pEntry->wdev && pEntry->wdev->bVLAN_Tag) || (bss_wdev && bss_wdev->bVLAN_Tag)) {
		AsicRxHeaderTransCtl(pAd, TRUE, FALSE, FALSE, FALSE, FALSE);
		CmdStaRecTxProc->u4TxProcFlag = 0;
		rx_policy_is_set = TRUE;
	}
#endif

#ifdef WHNAT_SUPPORT
	if (pEntry && PD_GET_WHNAT_ENABLE(pAd->physical_dev)) {
		/* Update RMVL info to WED */
		if (CmdStaRecTxProc->u4TxProcFlag & UNI_RVLAN)
			hc_set_wed_rmvl_per_sta(pAd, pEntry->wcid, TRUE);
		else
			hc_set_wed_rmvl_per_sta(pAd, pEntry->wcid, FALSE);
	}
#endif

#ifdef CONFIG_CSO_SUPPORT

	if (pChipCap->asic_caps & fASIC_CAP_CSO) {
		CmdStaRecTxProc->u4TxProcFlag |= UNI_IPCSO;
		CmdStaRecTxProc->u4TxProcFlag |= UNI_TCPUDPCSO;
	}

#endif
#ifdef CONFIG_STA_SUPPORT
	if (pEntry && (IS_ENTRY_PEER_AP(pEntry) || IS_ENTRY_REPEATER(pEntry))) {
		CmdStaRecTxProc->u4TxProcFlag |= UNI_TX_PROC_ACM_CFG_EN;

		if (pEntry->bACMBit[0] == TRUE)
			CmdStaRecTxProc->u4TxProcFlag |= UNI_TX_PROC_ACM_CFG_BK;

		if (pEntry->bACMBit[1] == TRUE)
			CmdStaRecTxProc->u4TxProcFlag |= UNI_TX_PROC_ACM_CFG_BE;

		if (pEntry->bACMBit[2] == TRUE)
			CmdStaRecTxProc->u4TxProcFlag |= UNI_TX_PROC_ACM_CFG_VI;

		if (pEntry->bACMBit[3] == TRUE)
			CmdStaRecTxProc->u4TxProcFlag |= UNI_TX_PROC_ACM_CFG_VO;
	}
#endif /* CONFIG_STA_SUPPORT */
#ifdef CFG_BIG_ENDIAN
	CmdStaRecTxProc->u4TxProcFlag = cpu2le32(CmdStaRecTxProc->u4TxProcFlag);
	CmdStaRecTxProc->u2Tag = cpu2le16(CmdStaRecTxProc->u2Tag);
	CmdStaRecTxProc->u2Length = cpu2le16(CmdStaRecTxProc->u2Length);
#endif

	if (rx_policy_is_set == TRUE) {
		for (i = 0; i < MAX_MBSSID_NUM(pAd); i++)
			pAd->ApCfg.MBSSID[i].wdev.VLAN_Policy[RX_VLAN] = 2;
		for (i = 0; i < MAX_MULTI_STA; i++)
			pAd->StaCfg[i].wdev.VLAN_Policy[RX_VLAN] = 2;
	}

	return NDIS_STATUS_SUCCESS;
}

static UNI_CMD_TAG_HANDLE_T UniCmdStaRecTab[] = {
	{
		.u8CmdFeature = STA_REC_BASIC_STA_RECORD_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_COMMON_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecBasic
	},
	{
		.u8CmdFeature = STA_REC_RA_FEATURE,
		.u4StructSize = sizeof(struct _STAREC_AUTO_RATE_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecRA
	},
	{
		.u8CmdFeature = STA_REC_RA_UPDATE_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_AUTO_RATE_UPDATE_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler =  UniCmdStaRecRAUpdate
	},
	{
		.u8CmdFeature = STA_REC_TX_PROC_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_TX_PROC_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdateTxProc
	},
	{
		.u8CmdFeature = STA_REC_BASIC_HT_INFO_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_HT_INFO_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecHTBasic
	},
	{
		.u8CmdFeature = STA_REC_BASIC_VHT_INFO_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_VHT_INFO_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecVHTBasic
	},
	{
		.u8CmdFeature = STA_REC_INSTALL_KEY_FEATURE,
		.u4StructSize = sizeof(CMD_WTBL_SECURITY_KEY_V2_T),
		.u4DyncBufSize = 0, /* Size Calculated by UniCmdStaRecExtraAllocDynSizeCheck */
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecInstallKeyFeature
	},
	{
		.u8CmdFeature = STA_REC_WTBL_FEATURE,
		.u4StructSize = (sizeof(struct UNI_CMD_STAREC_AADOM_T) +
						 sizeof(struct UNI_CMD_STAREC_HDRT_T)),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 2,
		.pfHandler = UniCmdStaRecWTBL
	},
	{
		.u8CmdFeature = STA_REC_BMC_WTBL_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_HDRT_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecBMCWTBL
	},
	{
		.u8CmdFeature = STA_REC_BASIC_HE_INFO_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_STAREC_HE_INFO_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecHEInfo
	},
	{
		.u8CmdFeature = STA_REC_HW_AMSDU_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_AMSDU_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecHwAmsdu
	},
#ifdef TXBF_SUPPORT
	{
		.u8CmdFeature = STA_REC_BF_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_STAREC_BF_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdateBf
	},
#endif /* TXBF_SUPPORT */
	{
		.u8CmdFeature = STA_REC_AP_PS_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_PS_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdateApPs
	},
	{
		.u8CmdFeature = STA_REC_MURU_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_MURU_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdateMuruInfo
	},
#ifdef TXBF_SUPPORT
	{
		.u8CmdFeature = STA_REC_BFEE_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_BFEE),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdateBfee
	},
#endif /* TXBF_SUPPORT */
	{
		.u8CmdFeature = STA_REC_HE_6G_CAP_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_HE_6G_CAP_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecUpdate6GCap
	},
	{
		.u8CmdFeature = STA_REC_HE_BASIC_FEATURE,
		.u4StructSize = sizeof(struct CMD_STAREC_HE_BASIC_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecHeBasic
	},
	{
		.u8CmdFeature = STA_REC_HDR_TRANS_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_HDR_TRANS_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecHdrTrans
	},
	{
		.u8CmdFeature = STA_REC_RCA1_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_RCA1_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecRCA1
	},
	{
		.u8CmdFeature = STA_REC_BASIC_STA_RECORD_BMC_FEATURE,
		.u4StructSize = sizeof(CMD_STAREC_COMMON_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecBasicBmc
	},
#ifdef DOT11_EHT_BE
	{
		.u8CmdFeature = STA_REC_MLD_SETUP_FEATURE,
		.u4StructSize = sizeof(struct CMD_STAREC_MLD_SETUP_T),
		.u4DyncBufSize = 0, /* Size Calculated by UniCmdStaRecExtraAllocDynSizeCheck */
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecMldSetup
	},
	{
		.u8CmdFeature = STA_REC_EHT_MLD_FEATURE,
		.u4StructSize = sizeof(struct CMD_STAREC_EHT_MLD_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecEhtMld
	},
	{
		.u8CmdFeature = STA_REC_EHT_BASIC_FEATURE,
		.u4StructSize = sizeof(struct CMD_STAREC_EHT_BASIC_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecEhtBasic
	},
	{
		.u8CmdFeature = STA_REC_MLD_TEARDOWN_FEATURE,
		.u4StructSize = sizeof(struct CMD_STAREC_MLD_TEARDOWN_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecMldTeardown
	},
	{
		.u8CmdFeature = STA_REC_A4_INFO_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_A4_INFO_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecA4Info
	},
#endif /* DOT11_EHT_BE */
#ifdef MLR_SUPPORT
	{
		.u8CmdFeature = STA_REC_MLR_INFO_FEATURE,
		.u4StructSize = sizeof(struct UNI_CMD_STAREC_MLR_INFO_T),
		.u4DyncBufSize = 0,
		.u2TLVNumber = 1,
		.pfHandler = UniCmdStaRecMlrInfo
	},
#endif /* MLR_SUPPORT */
};

UINT32 UniCmdStaRecExtraAllocDynSizeCheck(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg)
{
	UINT32 cmd_len = 0;
	UINT32 dynsize = 0;
	UINT32 StaRecTabSize = ARRAY_SIZE(UniCmdStaRecTab);
	UINT32 i = 0;

	for (i = 0; i < StaRecTabSize; i++) {
		if (pStaRecCfg->u8EnableFeature & UniCmdStaRecTab[i].u8CmdFeature) {
			cmd_len = 0;
			UniCmdStaRecTab[i].u4DyncBufSize = 0;
			if (UniCmdStaRecTab[i].u8CmdFeature == STA_REC_INSTALL_KEY_FEATURE) {
				chip_fill_key_install_uni_cmd_dynsize_check(
						pAd->hdev_ctrl, &pStaRecCfg->asic_sec_info, &cmd_len);
				/* For buffer offset process later. */
				UniCmdStaRecTab[i].u4DyncBufSize = cmd_len;
			}
#ifdef DOT11_EHT_BE
			else if (UniCmdStaRecTab[i].u8CmdFeature == STA_REC_MLD_SETUP_FEATURE) {
				struct _MAC_TABLE_ENTRY *entry = NULL;
				struct mld_entry_t *mld_entry = NULL;

				entry = pStaRecCfg->pEntry;
				if (entry != NULL) {
					mt_rcu_read_lock();
					mld_entry = get_mld_entry_by_mac(entry->mlo.mld_addr);
					if (mld_entry) {
						if ((entry->mlo.mlo_en == 1) &&
							!MAC_ADDR_EQUAL(mld_entry->addr, ZERO_MAC_ADDR) &&
							((mld_entry->link_num > 0) &&
							(mld_entry->link_num <= MLD_LINK_MAX))) {
							cmd_len =
								(sizeof(struct CMD_STAREC_LINK_INFO_T) * mld_entry->link_num);
							/* For buffer offset process later. */
							UniCmdStaRecTab[i].u4DyncBufSize = cmd_len;
						}
					}
					mt_rcu_read_unlock();
				}
			}
#endif /* DOT11_EHT_BE */
			dynsize += cmd_len;
		}
	}

	return dynsize;
}

#ifndef WLAN_STATUS_SUCCESS
#define WLAN_STATUS_SUCCESS ((UINT32)0x00000000L)
#endif
#ifndef WLAN_STATUS_NOT_ACCEPTED
#define WLAN_STATUS_NOT_ACCEPTED ((UINT32)0x00010003L)
#endif
#ifndef STAREC_RETRY
#define STAREC_RETRY 3
#endif

INT32 UniCmdStaRecUpdate_ReSyncDelete(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T *pCmdStaRecUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
	UINT32 StaRecTabSize = ARRAY_SIZE(UniCmdStaRecTab);
	STA_REC_CFG_T StaRecCfgForDel;

	/* Clear command result first */
	pStaRecCfg->u4FwCmdStatus = 0;

	/* Copy from original structure */
	os_move_mem(&StaRecCfgForDel, pStaRecCfg, sizeof(StaRecCfgForDel));

	/* Change to disconnect state for sta rec update */
	StaRecCfgForDel.ConnectionState = STATE_DISCONNECT;
	StaRecCfgForDel.u8EnableFeature = STA_REC_BASIC_STA_RECORD_FEATURE;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STAREC_INFO_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < StaRecTabSize; i++) {
		if (StaRecCfgForDel.u8EnableFeature & UniCmdStaRecTab[i].u8CmdFeature) {
			u4CmdNeedMaxBufSize += UniCmdStaRecTab[i].u4StructSize;
			break;
		}
	}

	if (i == StaRecTabSize) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"Can't found this feature: 0x%lx\n", STA_REC_BASIC_STA_RECORD_FEATURE);
		return NDIS_STATUS_FAILURE;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf)
		return NDIS_STATUS_RESOURCES;

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdStaRecUpdate = (struct UNI_CMD_STAREC_INFO_T *)pNextHeadBuf;
	pCmdStaRecUpdate->ucBssInfoIdx = StaRecCfgForDel.ucBssIndex;
	WCID_SET_H_L(pCmdStaRecUpdate->ucWlanIdxHnVer,
		pCmdStaRecUpdate->ucWlanIdxL, StaRecCfgForDel.u2WlanIdx);
	pCmdStaRecUpdate->ucMuarIdx = StaRecCfgForDel.MuarIdx;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	if (UniCmdStaRecTab[i].pfHandler != NULL) {
		Ret = ((PFN_STAREC_HANDLE)(UniCmdStaRecTab[i].pfHandler))(pAd, &StaRecCfgForDel, &UniCmdStaRecTab[i], pNextHeadBuf);
		if (Ret == NDIS_STATUS_SUCCESS) {
			pNextHeadBuf += (UniCmdStaRecTab[i].u4StructSize + UniCmdStaRecTab[i].u4DyncBufSize);
			u2TLVNumber += UniCmdStaRecTab[i].u2TLVNumber;
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
				"The hanlder of tag (0x%llx) return success!\n", UniCmdStaRecTab[i].u8CmdFeature);
		} else
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"The hanlder of tag (0x%llx) return fail!\n", UniCmdStaRecTab[i].u8CmdFeature);
	} else {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				 "StaRecTag = %lld no corresponding function handler.\n",
				  UniCmdStaRecTab[i].u8CmdFeature);
	}

	if (u2TLVNumber > 0) {
		pCmdStaRecUpdate->u2TotalElementNum = cpu2le16(u2TLVNumber);
		pCmdStaRecUpdate->ucAppendCmdTLV = TRUE;
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, &StaRecCfgForDel);
			if ((!bNeedFrag) || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdStaRecRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			call_fw_cmd_notifieriers(WO_CMD_STA_REC, pAd, msg->net_pkt);
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

	/* Copy fw command result */
	pStaRecCfg->u4FwCmdStatus = StaRecCfgForDel.u4FwCmdStatus;

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStaRecUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T *pCmdStaRecUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
	UINT32 StaRecTabSize = ARRAY_SIZE(UniCmdStaRecTab);
	BOOLEAN	bNeedReSyncDelete = FALSE;
	UINT8 retry = STAREC_RETRY;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STAREC_INFO_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < StaRecTabSize; i++) {
		if (pStaRecCfg->u8EnableFeature & UniCmdStaRecTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdStaRecTab[i].u4StructSize;
	}
	u4CmdNeedMaxBufSize += UniCmdStaRecExtraAllocDynSizeCheck(pAd, pStaRecCfg);

UniCmdStaRecUpdate_restart:
	/* Clear command result first */
	pStaRecCfg->u4FwCmdStatus = 0;

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdStaRecUpdate = (struct UNI_CMD_STAREC_INFO_T *)pNextHeadBuf;
	pCmdStaRecUpdate->ucBssInfoIdx = pStaRecCfg->ucBssIndex;
	WCID_SET_H_L(pCmdStaRecUpdate->ucWlanIdxHnVer,
		pCmdStaRecUpdate->ucWlanIdxL, pStaRecCfg->u2WlanIdx);
	pCmdStaRecUpdate->ucMuarIdx = pStaRecCfg->MuarIdx;
	pNextHeadBuf += u4ComCmdSize;

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"ucBssIndex(%d), WlanIdx(%d), ucMuarIdx(%d), ConnectionType(%d), ConnectionState(0x%x), u4EnableFeature(0x%llx), IsNewSTARec(%d)\n",
		pStaRecCfg->ucBssIndex, pStaRecCfg->u2WlanIdx, pStaRecCfg->MuarIdx,
		pStaRecCfg->ConnectionType, pStaRecCfg->ConnectionState,
		pStaRecCfg->u8EnableFeature, pStaRecCfg->IsNewSTARec);

	/* Step 4: Traverse all support features */
	u2TLVNumber = 0;
	for (i = 0; i < StaRecTabSize; i++) {
		if (pStaRecCfg->u8EnableFeature & UniCmdStaRecTab[i].u8CmdFeature) {
			if (UniCmdStaRecTab[i].pfHandler != NULL) {
				Ret = ((PFN_STAREC_HANDLE)(UniCmdStaRecTab[i].pfHandler))(pAd, pStaRecCfg, &UniCmdStaRecTab[i], pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += (UniCmdStaRecTab[i].u4StructSize + UniCmdStaRecTab[i].u4DyncBufSize);
					u2TLVNumber += UniCmdStaRecTab[i].u2TLVNumber;
					MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
						"The hanlder of tag (0x%llx) return success!\n", UniCmdStaRecTab[i].u8CmdFeature);
				} else
					MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdStaRecTab[i].u8CmdFeature);
			} else {
				MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
						 "StaRecTag = %lld no corresponding function handler.\n",
						  UniCmdStaRecTab[i].u8CmdFeature);
			}
		}
	}
	if (u2TLVNumber > 0) {
		pCmdStaRecUpdate->u2TotalElementNum = cpu2le16(u2TLVNumber);
		pCmdStaRecUpdate->ucAppendCmdTLV = TRUE;
	}


	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pStaRecCfg);
			if ((!bNeedFrag) || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdStaRecRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			call_fw_cmd_notifieriers(WO_CMD_STA_REC, pAd, msg->net_pkt);
			Ret = AndesSendCmdMsg(pAd, msg);

			/* ReSync Delete Case */
			if ((pStaRecCfg->u4FwCmdStatus == WLAN_STATUS_NOT_ACCEPTED) &&
				(pStaRecCfg->ConnectionState == STATE_CONNECTED) &&
				(pStaRecCfg->u8EnableFeature & STA_REC_BASIC_STA_RECORD_FEATURE)) {
				bNeedReSyncDelete = TRUE;
				break;
			}

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	if (bNeedReSyncDelete) {
		bNeedReSyncDelete = FALSE;
		while (retry) {
			retry--;
			Ret = UniCmdStaRecUpdate_ReSyncDelete(pAd, pStaRecCfg);
			if ((Ret != NDIS_STATUS_SUCCESS) ||
				(pStaRecCfg->u4FwCmdStatus != WLAN_STATUS_SUCCESS))
				continue;

			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
					"retry = %d, Re-Sync delete fw sta rec successfully!\n", retry);
			goto UniCmdStaRecUpdate_restart;
		}
	}

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

/* Send unified command of "UNI_CMD_STAREC_BA" */
INT32 UniCmdStaRecBaUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_BA_CFG_T StaRecBaCfg)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	CMD_STAREC_BA_T CmdStaRecBa;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
	MAC_TABLE_ENTRY *mac_entry;
	UINT32 PairwiseCipher;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaRecBa, sizeof(CmdStaRecBa));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaRecBa);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = StaRecBaCfg.BssIdx;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL, StaRecBaCfg.WlanIdx);
	CmdStaRecUpdate.ucMuarIdx = StaRecBaCfg.MuarIdx;
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of CMD_STAREC_BA*/
	CmdStaRecBa.u2Tag = UNI_CMD_STAREC_BA;
	CmdStaRecBa.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	CmdStaRecBa.ucTid = StaRecBaCfg.tid;
	CmdStaRecBa.ucBaDirection = StaRecBaCfg.baDirection;
	CmdStaRecBa.ucAmsduCap = StaRecBaCfg.amsdu;
	CmdStaRecBa.ucBaEenable = StaRecBaCfg.BaEnable;
	CmdStaRecBa.u2BaStartSeq = StaRecBaCfg.sn;
	CmdStaRecBa.u2BaWinSize = StaRecBaCfg.ba_wsize;
	if (CmdStaRecBa.ucBaDirection == BA_SESSION_RECP &&
		CmdStaRecBa.ucBaEenable &&
		cap->hw_rro_en &&
		cap->asic_caps & fASIC_CAP_HW_RRO)
		CmdStaRecBa.ucBaAddRro = TRUE;
	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_BA\n");

	mac_entry = entry_get(pAd, StaRecBaCfg.WlanIdx);
	PairwiseCipher = mac_entry->SecConfig.PairwiseCipher;
	if (IS_CIPHER_CCMP128(PairwiseCipher) || IS_CIPHER_CCMP256(PairwiseCipher) ||
		IS_CIPHER_GCMP128(PairwiseCipher) || IS_CIPHER_GCMP256(PairwiseCipher) ||
		IS_CIPHER_TKIP(PairwiseCipher)) {
		CmdStaRecBa.ucBaPnChkEn = !(mac_entry->DISABLE_PN_CHK & BIT(StaRecBaCfg.tid));
	}
	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_INFO,
			 "BaInfo:\n");
	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_INFO,
		 "Wcid=%d, u2Tag=%d, u2Length=%d, ucTid=%d, u2BaDirectin=%d, BaEnable=%d, u2BaStartSeq=%d, u2BaWinSize=%d, ucAmsduCap=%d ucBaPnChkEn=%d\n",
		  StaRecBaCfg.WlanIdx, CmdStaRecBa.u2Tag, CmdStaRecBa.u2Length, CmdStaRecBa.ucTid, CmdStaRecBa.ucBaDirection,
		  CmdStaRecBa.ucBaEenable, CmdStaRecBa.u2BaStartSeq, CmdStaRecBa.u2BaWinSize, CmdStaRecBa.ucAmsduCap, CmdStaRecBa.ucBaPnChkEn);
#ifdef CFG_BIG_ENDIAN
	CmdStaRecBa.u2Tag = cpu2le16(CmdStaRecBa.u2Tag);
	CmdStaRecBa.u2Length = cpu2le16(CmdStaRecBa.u2Length);
	CmdStaRecBa.u2BaStartSeq = cpu2le16(CmdStaRecBa.u2BaStartSeq);
	CmdStaRecBa.u2BaWinSize = cpu2le16(CmdStaRecBa.u2BaWinSize);
#endif
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecBa, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Send out CMD */
	call_fw_cmd_notifieriers(WO_CMD_STA_REC, pAd, msg->net_pkt);
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_INFO,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef HTC_DECRYPT_IOT
/* Unified command for UNI_CMD_STAREC_AAD_OM 0x10 */
INT32 UniCmdStaRecAADOmUpdate(
	struct _RTMP_ADAPTER *pAd,
	UINT16 Wcid,
	UINT8 AadOm)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_AADOM_T CmdStaRecAadom;
	struct _CMD_ATTRIBUTE attr = {0};
	MAC_TABLE_ENTRY *pMacEntry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaRecAadom, sizeof(CmdStaRecAadom));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaRecAadom);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill common parameters here */
	if (VALID_UCAST_ENTRY_WCID(pAd, Wcid)) {
		pMacEntry = entry_get(pAd, Wcid);
		if (pMacEntry->wdev)
			CmdStaRecUpdate.ucBssInfoIdx = pMacEntry->wdev->bss_info_argument.ucBssIndex;
		else
			CmdStaRecUpdate.ucBssInfoIdx = 0;
	} else {
		CmdStaRecUpdate.ucBssInfoIdx = 0;
	}
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL, Wcid);
	CmdStaRecUpdate.ucMuarIdx = 0; /* useless for this cmd */
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of CMD_STAREC_BA*/
	CmdStaRecAadom.u2Tag = UNI_CMD_STAREC_AAD_OM;
	CmdStaRecAadom.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	CmdStaRecAadom.ucAadOm = AadOm;
#ifdef CFG_BIG_ENDIAN
	CmdStaRecAadom.u2Tag = cpu2le16(CmdStaRecAadom.u2Tag);
	CmdStaRecAadom.u2Length = cpu2le16(CmdStaRecAadom.u2Length);
#endif
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecAadom, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step5: send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* HTC_DECRYPT_IOT */

/* Unified command for UNI_CMD_STAREC_PSM 0x2a */
INT32 UniCmdStaRecPsmUpdate(
	struct _RTMP_ADAPTER *pAd,
	UINT16 Wcid,
	UINT8 Psm)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_PSM_T CmdStaRecPsm;
	struct _CMD_ATTRIBUTE attr = {0};
	MAC_TABLE_ENTRY *pMacEntry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaRecPsm, sizeof(CmdStaRecPsm));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaRecPsm);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill common parameters here */
	if (VALID_UCAST_ENTRY_WCID(pAd, Wcid)) {
		pMacEntry = entry_get(pAd, Wcid);
		if (pMacEntry->wdev)
			CmdStaRecUpdate.ucBssInfoIdx = pMacEntry->wdev->bss_info_argument.ucBssIndex;
		else
			CmdStaRecUpdate.ucBssInfoIdx = 0;
	} else {
		CmdStaRecUpdate.ucBssInfoIdx = 0;
	}
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL, Wcid);
	CmdStaRecUpdate.ucMuarIdx = 0; /* useless for this cmd */
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of CMD_STAREC_PSM*/
	CmdStaRecPsm.u2Tag = UNI_CMD_STAREC_PSM;
	CmdStaRecPsm.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	if (Psm == PWR_ACTIVE)
		CmdStaRecPsm.fgIsPsm = FALSE;
	else
		CmdStaRecPsm.fgIsPsm = TRUE;
#ifdef CFG_BIG_ENDIAN
	CmdStaRecPsm.u2Tag = cpu2le16(CmdStaRecPsm.u2Tag);
	CmdStaRecPsm.u2Length = cpu2le16(CmdStaRecPsm.u2Length);
#endif
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_PSM\n");
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecPsm, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step5: send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdWtblUpdate(RTMP_ADAPTER *pAd, UINT16 u2WlanIdx, UINT8 ucOperation,
					   VOID *pBuffer, UINT32 u4BufferLen)
{
	UINT64 u8EnableFeature = 0;
	UINT16 ucTLVNumber = 0;
	P_CMD_WTBL_GENERIC_TLV_T pWtblGenericTlv = NULL;
	UINT32 u4RemainingTLVBufLen = 0;
	PUCHAR TempBuffer = (PUCHAR)pBuffer;
	INT32					Ret = 0;

	/* Get TVL number from TLV buffer*/
	u4RemainingTLVBufLen = u4BufferLen;

	while (u4RemainingTLVBufLen > 0) {
		pWtblGenericTlv = (P_CMD_WTBL_GENERIC_TLV_T)TempBuffer;

		if (pWtblGenericTlv == NULL) {
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
					 "pWtblGenericTlv is NULL\n");
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		} else if (pWtblGenericTlv->u2Length == 0) {
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
					 "fail to handle T(%d), L(%d)\n", pWtblGenericTlv->u2Tag, pWtblGenericTlv->u2Length);
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if (pWtblGenericTlv->u2Tag >= WTBL_MAX_NUM) {
			MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
					 "u2Tag is invalid!\n");
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if (pWtblGenericTlv->u2Tag == WTBL_GENERIC ||
			pWtblGenericTlv->u2Tag == WTBL_HT ||
			pWtblGenericTlv->u2Tag == WTBL_PN ||
			pWtblGenericTlv->u2Tag == WTBL_SECURITY_KEY_V2)
			MTWF_PRINT("not support anymore! handle T(%d), L(%d)\n",
						pWtblGenericTlv->u2Tag, pWtblGenericTlv->u2Length);
		u8EnableFeature |= (1 << (pWtblGenericTlv->u2Tag));
		TempBuffer += pWtblGenericTlv->u2Length;
		u4RemainingTLVBufLen -= pWtblGenericTlv->u2Length;
		ucTLVNumber++;
	}
	return Ret;
}
INT32 UniCmdSetRecSecPnInfo(RTMP_ADAPTER *pAd, UINT16 u2WlanIdx, UINT8 ucOperation,
					  VOID *pBuffer, UINT32 u4BufferLen, UINT32 tsc_cnt)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS, i = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT8 *pParamBuffer = pBuffer;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	P_CMD_WTBL_PN_T pParam = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T *pCmdStaRecUpdate = NULL;
	P_UNI_CMD_STAREC_SEC_PN_INFO_T pCmdStaRecPnInfo = NULL;
	MAC_TABLE_ENTRY *pMacEntry = NULL;
	struct wifi_dev *wdev = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	if (!IS_WCID_VALID(pAd, u2WlanIdx))
		return NDIS_STATUS_INVALID_DATA;

	if (VALID_UCAST_ENTRY_WCID(pAd, u2WlanIdx))
		pMacEntry = entry_get(pAd, u2WlanIdx);
	else
		pMacEntry = entry_get(pAd, MCAST_WCID_TO_REMOVE);
	if (!IS_VALID_ENTRY(pMacEntry))
		return NDIS_STATUS_FAILURE;

	wdev = pMacEntry->wdev;
	if (wdev == NULL)
		return NDIS_STATUS_FAILURE;


	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STAREC_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UNI_CMD_STAREC_SEC_PN_INFO_T) * tsc_cnt;

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdStaRecUpdate = (struct UNI_CMD_STAREC_INFO_T *)pNextHeadBuf;
	pCmdStaRecUpdate->ucBssInfoIdx = wdev->bss_info_argument.ucBandIdx;
	WCID_SET_H_L(pCmdStaRecUpdate->ucWlanIdxHnVer, pCmdStaRecUpdate->ucWlanIdxL, u2WlanIdx);
	pCmdStaRecUpdate->ucMuarIdx = 0; /* useless for this cmd */
	pCmdStaRecUpdate->u2TotalElementNum = tsc_cnt;
	pCmdStaRecUpdate->ucAppendCmdTLV = TRUE;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Fill TLV parameters here */
	for (i = 0; i < tsc_cnt; i++) {
		pParam = (P_CMD_WTBL_PN_T)pParamBuffer;
		pCmdStaRecPnInfo = (P_UNI_CMD_STAREC_SEC_PN_INFO_T)pNextHeadBuf;
		pCmdStaRecPnInfo->u2Tag = cpu2le16(UNI_CMD_STAREC_SEC_PN_INFO);
		pCmdStaRecPnInfo->u2Length = cpu2le16(sizeof(UNI_CMD_STAREC_SEC_PN_INFO_T));
		pCmdStaRecPnInfo->ucTscType = pParam->ucTscType;
		memcpy(&(pCmdStaRecPnInfo->aucPn), &(pParam->aucPn), sizeof(pParam->aucPn));

		pParamBuffer += sizeof(CMD_WTBL_PN_T);
		pNextHeadBuf += sizeof(UNI_CMD_STAREC_SEC_PN_INFO_T);
	}
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_SEC_PN_INFO\n");

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			tsc_cnt, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		uint8_t uSeqNum = AndesGetCmdMsgSeq(pAd);
		uint8_t uFragNum = 0;
		uint8_t uTotalFrag = 0;
		uint8_t bNeedFrag = FALSE;
		uint8_t bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pBuffer);
			if ((!bNeedFrag) || bLastFrag) {
				if (ucOperation == QUERY_WTBL) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventStaRecEvent);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef DOT11_EHT_BE
/* Send unified command of "UNI_CMD_STAREC_EML_OP_T" */
INT32 UniCmdStaRecEmlOp(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_EML_OP_T CmdStaEmlOp;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT8 link, hw_band_idx;
	struct _MAC_TABLE_ENTRY *entry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	if (!entry->mlo.mlo_en) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
			"(ERROR):mlo_en=%d\n", entry->mlo.mlo_en);
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaEmlOp, sizeof(CmdStaEmlOp));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaEmlOp);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = pStaRecCfg->ucBssIndex;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer,
		CmdStaRecUpdate.ucWlanIdxL, pStaRecCfg->u2WlanIdx);
	CmdStaRecUpdate.ucMuarIdx = pStaRecCfg->MuarIdx;
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STAREC_EML_OP_T */
	CmdStaEmlOp.u2Tag = UNI_CMD_STAREC_EML_OP;
	CmdStaEmlOp.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STAREC_EML_OP\n");

	for (link = 0; link < CFG_WIFI_RAM_BAND_NUM; link++)
		CmdStaEmlOp.ucLinkAntNum[link] = pStaRecCfg->pEntry->eht_cfg.emlsr_antnum;

	/*
	 * ucEmlsrBitmap: bit position is hardware band index, not the link_id used in driver.
	 * Therefore, need to convert bitmap to correct bitmap following hw band index rule.
	 */
	for (link = 0; link < MLD_LINK_MAX; link++) {
		INT32 ret = link2band(entry, link, &hw_band_idx);

		/* apcli cfg bitmap by .dat cfg, don't need to do conversion by link id */
		if (entry->EntryType == ENTRY_AP) {
			CmdStaEmlOp.ucEmlsrBitmap = entry->EmlsrBitmap;
			break;
		}

		if (ret != NDIS_STATUS_SUCCESS)
			continue;

		if (entry->EmlsrBitmap & BIT(link))
			CmdStaEmlOp.ucEmlsrBitmap |= BIT(hw_band_idx);
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_INFO,
		"u2Tag=0x%x, u2Length=%d, ucEmlsrBitmap=0x%x\n",
		CmdStaEmlOp.u2Tag, CmdStaEmlOp.u2Length, CmdStaEmlOp.ucEmlsrBitmap);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_DEBUG,
		"ucBssIndex=%d, u2WlanIdx=0x%x, (0x%x, 0x%x)\n",
		pStaRecCfg->ucBssIndex, pStaRecCfg->u2WlanIdx,
		CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL);
	for (link = 0; link < CFG_WIFI_RAM_BAND_NUM; link++)
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_INFO,
			"ucLinkAntNum[%d]=%d\n",
		link, CmdStaEmlOp.ucLinkAntNum[link]);
	AndesAppendCmdMsg(msg, (char *)&CmdStaEmlOp, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

/* Send unified command of "struct UNI_CMD_STAREC_TX_CAP_T" */
INT32 UniCmdStaRecTxCapUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	BOOLEAN EnableAGGLimit)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_TX_CAP_T CmdStaTxCap;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _MAC_TABLE_ENTRY *entry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaTxCap, sizeof(CmdStaTxCap));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaTxCap);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = pStaRecCfg->ucBssIndex;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer,
		CmdStaRecUpdate.ucWlanIdxL, pStaRecCfg->u2WlanIdx);
	CmdStaRecUpdate.ucMuarIdx = pStaRecCfg->MuarIdx;
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STAREC_TX_CAP_T */
	CmdStaTxCap.u2Tag = UNI_CMD_STA_REC_TX_CAP;
	CmdStaTxCap.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_INFO,
		"=> UNI_CMD_STA_REC_TX_CAP\n");
	CmdStaTxCap.fgTxLimit = EnableAGGLimit;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_NOTICE,
		"u2Tag=0x%x, u2Length=%d, fgEnable=0x%x\n",
		CmdStaTxCap.u2Tag, CmdStaTxCap.u2Length, CmdStaTxCap.fgTxLimit);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_DEBUG,
		"ucBssIndex=%d, u2WlanIdx=0x%x, (0x%x, 0x%x)\n",
		pStaRecCfg->ucBssIndex, pStaRecCfg->u2WlanIdx,
		CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL);

	AndesAppendCmdMsg(msg, (char *)&CmdStaTxCap, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#endif /* DOT11_EHT_BE */

INT32 UniCmdStaRecTxPwrUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	UINT8  TxPowerOffset)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_TX_PWR_T CmdStaTxPwr;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _MAC_TABLE_ENTRY *entry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaTxPwr, sizeof(CmdStaTxPwr));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaTxPwr);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = pStaRecCfg->ucBssIndex;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer,
		CmdStaRecUpdate.ucWlanIdxL, pStaRecCfg->u2WlanIdx);
	CmdStaRecUpdate.ucMuarIdx = pStaRecCfg->MuarIdx;
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STA_REC_TX_PWR */
	CmdStaTxPwr.u2Tag = UNI_CMD_STA_REC_TX_PWR;
	CmdStaTxPwr.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	CmdStaTxPwr.ucTxPowerOffset = TxPowerOffset;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_NOTICE,
		"u2Tag=0x%x, u2Length=%d, ucTxPowerOffset=0x%x\n",
		CmdStaTxPwr.u2Tag, CmdStaTxPwr.u2Length, CmdStaTxPwr.ucTxPowerOffset);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_DEBUG,
		"ucBssIndex=%d, u2WlanIdx=0x%x, (0x%x, 0x%x)\n",
		pStaRecCfg->ucBssIndex, pStaRecCfg->u2WlanIdx,
		CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL);

	AndesAppendCmdMsg(msg, (char *)&CmdStaTxPwr, (u4CmdNeedMaxBufSize -
u4ComCmdSize));

	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStaSNSet(
	struct _RTMP_ADAPTER *pAd,
	INT wcid,
	UCHAR SnUpdate_type)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct _UNI_CMD_PER_STA_TID_SN_SET_T *CmdStaTidSnUpdate;
	struct _UNI_CMD_ONE_STA_SN_SET_INFO_T *CmdStaSNOp;
	struct _CMD_ATTRIBUTE attr = {0};

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*CmdStaTidSnUpdate) + sizeof(*CmdStaSNOp);

	/* Step 1: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 2: Count maximum buffer size from per TLV */
	CmdStaTidSnUpdate = (struct _UNI_CMD_PER_STA_TID_SN_SET_T *) pNextHeadBuf;
	CmdStaTidSnUpdate->u2Tag = UNI_CMD_PER_STA_TID_SN_SET;
	CmdStaTidSnUpdate->u2Length = sizeof(struct _UNI_CMD_PER_STA_TID_SN_SET_T) + sizeof(struct _UNI_CMD_ONE_STA_SN_SET_INFO_T);
	CmdStaTidSnUpdate->u2StaTidSnPairNum = 1;
	CmdStaTidSnUpdate->ucUpdateType = SnUpdate_type;
#ifdef CFG_BIG_ENDIAN
	CmdStaTidSnUpdate->u2Tag = cpu2le16(CmdStaTidSnUpdate->u2Tag);
	CmdStaTidSnUpdate->u2Length = cpu2le16(CmdStaTidSnUpdate->u2Length);
#endif /* CFG_BIG_ENDIAN */


	pNextHeadBuf += sizeof(*CmdStaTidSnUpdate);
	CmdStaSNOp = (struct _UNI_CMD_ONE_STA_SN_SET_INFO_T *) pNextHeadBuf;

	CmdStaSNOp->u2WlanIdx = wcid;
	CmdStaSNOp->ucTid = 0xff;
	if (SnUpdate_type)
		CmdStaSNOp->u2Sn = RESET_SN;
	else
		CmdStaSNOp->u2Sn = RANDOM_SN;

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_NOTICE,
		"CmdStaSNOp.u2WlanIdx [%d], CmdStaSNOp.ucTid [%d], CmdStaSNOp.u2Sn[%d]\n", CmdStaSNOp->u2WlanIdx, CmdStaSNOp->ucTid, CmdStaSNOp->u2Sn);
	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"(Ret = %d)\n", Ret);
	return Ret;

}
INT32 UniCmdStaRecDualCTSUpdate(
	struct _RTMP_ADAPTER *pAd,
	STA_REC_CFG_T *pStaRecCfg,
	BOOLEAN EnableDualCTS)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_STAREC_INFO_T CmdStaRecUpdate;
	struct UNI_CMD_STAREC_DUAL_CTS_T CmdStaDualCTS;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _MAC_TABLE_ENTRY *entry = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	entry = pStaRecCfg->pEntry;
	if (!entry) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_ERROR,
			"(ERROR):entry=NULL\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdStaRecUpdate);
	os_zero_mem(&CmdStaRecUpdate, u4ComCmdSize);
	os_zero_mem(&CmdStaDualCTS, sizeof(CmdStaDualCTS));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdStaDualCTS);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STAREC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdStaRecUpdate.ucBssInfoIdx = pStaRecCfg->ucBssIndex;
	WCID_SET_H_L(CmdStaRecUpdate.ucWlanIdxHnVer,
		CmdStaRecUpdate.ucWlanIdxL, pStaRecCfg->u2WlanIdx);
	CmdStaRecUpdate.ucMuarIdx = pStaRecCfg->MuarIdx;
	CmdStaRecUpdate.u2TotalElementNum = cpu2le16(1);
	CmdStaRecUpdate.ucAppendCmdTLV = TRUE;
	AndesAppendCmdMsg(msg, (char *)&CmdStaRecUpdate, u4ComCmdSize);

	/* Step 4: Filled in parameters of UNI_CMD_STA_REC_DUAL_CTS */
	CmdStaDualCTS.u2Tag = UNI_CMD_STA_REC_DUAL_CTS;
	CmdStaDualCTS.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	CmdStaDualCTS.fgDualCts = EnableDualCTS;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_NOTICE,
		"u2Tag=0x%x, u2Length=%d, fgDualCts=0x%x\n",
		CmdStaDualCTS.u2Tag, CmdStaDualCTS.u2Length, CmdStaDualCTS.fgDualCts);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EHT, DBG_LVL_DEBUG,
		"ucBssIndex=%d, u2WlanIdx=0x%x, (0x%x, 0x%x)\n",
		pStaRecCfg->ucBssIndex, pStaRecCfg->u2WlanIdx,
		CmdStaRecUpdate.ucWlanIdxHnVer, CmdStaRecUpdate.ucWlanIdxL);

	AndesAppendCmdMsg(msg, (char *)&CmdStaDualCTS, (u4CmdNeedMaxBufSize -
u4ComCmdSize));

	/* Send out CMD */
	Ret = AndesSendCmdMsg(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_STAREC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

/*****************************************
 * Command ID: UNI_CMD_ID_EDCA_SET = 0x04
*****************************************/
static INT32 UniCmdEDCAAcSet(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	MT_EDCA_CTRL_T *pEdcaParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	P_TX_AC_PARAM_T pAcParam = NULL;
	P_UNI_CMD_EDCA_AC_PARM_T pEDCAAc = (P_UNI_CMD_EDCA_AC_PARM_T)pHandle;

	for (i = 0; i < pEdcaParam->ucTotalNum; i++) {
		pAcParam = &pEdcaParam->rAcParam[i];
		/* Fill TLV format */
		pEDCAAc->u2Tag = UNI_CMD_EDCA_AC_PARM;
		pEDCAAc->u2Length = sizeof(UNI_CMD_EDCA_AC_PARM_T);
#ifdef CFG_BIG_ENDIAN
		pEDCAAc->u2Tag = cpu2le16(pEDCAAc->u2Tag);
		pEDCAAc->u2Length = cpu2le16(pEDCAAc->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pEDCAAc->ucAcIndex = pAcParam->ucAcNum;

		if (pAcParam->ucVaildBit & CMD_EDCA_AIFS_BIT) {
			pEDCAAc->ucAifsn = pAcParam->ucAifs;
			pEDCAAc->ucValidBitmap |= MASK_AIFS_SET;
		}

		if (pAcParam->ucVaildBit & CMD_EDCA_WIN_MIN_BIT) {
			pEDCAAc->ucCWmin = pAcParam->ucWinMin;
			pEDCAAc->ucValidBitmap |= MASK_WINMIN_SET;
		}

		if (pAcParam->ucVaildBit & CMD_EDCA_WIN_MAX_BIT) {
			pEDCAAc->ucCWmax = (UINT8)pAcParam->u2WinMax;
			pEDCAAc->ucValidBitmap |= MASK_WINMAX_SET;
		}

		if (pAcParam->ucVaildBit & CMD_EDCA_TXOP_BIT) {
			pEDCAAc->u2TxopLimit = cpu2le16(pAcParam->u2Txop);
			pEDCAAc->ucValidBitmap |= MASK_TXOP_SET;
		}

		pEDCAAc++;
	}

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdEDCATab[UNI_CMD_EDCA_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_EDCA_AC_PARM,
		.u4StructSize = sizeof(UNI_CMD_EDCA_AC_PARM_T),
		.pfHandler = UniCmdEDCAAcSet
	},
};

INT32 MtUniCmdEdcaParameterSet(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	P_CMD_EDCA_CTRL_T pEdcaParam)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_EDCA_T		pCmdEDCAUpdate = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_EDCA_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_EDCA_MAX_NUM; i++) {
		if (i == UNI_CMD_EDCA_AC_PARM)
			u4CmdNeedMaxBufSize +=
				(UniCmdEDCATab[i].u4StructSize * pEdcaParam->ucTotalNum);
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdEDCAUpdate = (P_UNI_CMD_EDCA_T)pNextHeadBuf;
	pCmdEDCAUpdate->ucBssInfoIdx = wdev->bss_info_argument.ucBssIndex;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_EDCA_MAX_NUM; i++) {
		switch (i) {
		case UNI_CMD_EDCA_AC_PARM:
			if (UniCmdEDCATab[i].pfHandler != NULL) {
				Ret = ((PFN_EDCA_AC_HANDLE)(UniCmdEDCATab[i].pfHandler))(pAd, wdev, pEdcaParam, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += (UniCmdEDCATab[i].u4StructSize * pEdcaParam->ucTotalNum);
					u2TLVNumber++;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_SUCCESS;
			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_MAC, DBG_LVL_INFO,
				"The hanlder of tag (0x%llx) not support!\n", UniCmdEDCATab[i].u8CmdFeature);
			break;
		}

		if (Ret != NDIS_STATUS_SUCCESS)
			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdEDCATab[i].u8CmdFeature);
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_MAC, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EDCA_SET);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdChannelSwitch(RTMP_ADAPTER *pAd, MT_SWITCH_CHANNEL_CFG SwChCfg)
{
	struct cmd_msg *msg;
	struct UNI_CMD_CHAN_SWITCH_T *pCmdChanSwitch = NULL;
	struct UNI_CMD_CHAN_SWITCH_TLV_T *pCmdChanSwitchTlv = NULL;
	uint8_t *pTempBuf = NULL;
	uint8_t *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	INT32 ret = 0;
	USHORT doNotCal = 0;
	RTMP_CHIP_OP *chip_ops = hc_get_chip_ops(pAd->hdev_ctrl);
	P_ENUM_DFS_INB_CH_SWITCH_STAT_T ch_stat = &pAd->CommonCfg.DfsParameter.inband_ch_stat;
	PDFS_PARAM pDfsParam = &pAd->CommonCfg.DfsParameter;
	struct _CMD_ATTRIBUTE attr = {0};
	uint8_t TxPowerDrop = 0;
	uint8_t ucTxPath = pAd->Antenna.field.TxPath;
	UCHAR ucDebugLevel = DBG_LVL_NOTICE;
#ifdef SINGLE_SKU_V2
	UCHAR fg5Gband = 0;
#endif
	uint8_t SKUIdx = 0;
#if defined(CONFIG_ATE)
	uint8_t rx_stream_num = 0, ant_seq = 0;
#endif	/* CONFIG_ATE */

	/*if in scan change debug log level to info*/
	if (scan_in_run_state(pAd, NULL)) {
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_INFO,
				 "in scan change log level to info\n");
		ucDebugLevel = DBG_LVL_INFO;
	}

	/*if 0x1A5[6]=1 , ch36~ch48 do not calibration at boot up*/
	chip_ops->eeread(pAd, PRECAL_INDICATION_BYTE, &doNotCal);
	doNotCal = doNotCal & (1 << 6);

    /* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_CHAN_SWITCH_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdChanSwitch = (struct UNI_CMD_CHAN_SWITCH_T *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

    /* Step 4: Filled in parameters of CMD_CHAN_SWITCH_T*/
	pCmdChanSwitchTlv = (struct UNI_CMD_CHAN_SWITCH_TLV_T *) pNextHeadBuf;
	os_zero_mem(pCmdChanSwitchTlv, sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T));
	pCmdChanSwitchTlv->u2Tag = UNI_CMD_CHAN_SWITCH;
	pCmdChanSwitchTlv->u2Length = sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T);

	if (SwChCfg.CentralChannel == 0) {
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_ERROR,
				 "central channel = 0 is invalid\n");
		ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

#ifdef DOT11_EHT_BE
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, ucDebugLevel,
		"ctl_chl=%d, cen_ch=%d, eht_cen_ch=%d, DBDCIdx=%d, Band=%d, BW=%d, scan=%d\n",
		SwChCfg.ControlChannel, SwChCfg.CentralChannel, SwChCfg.eht_cen_ch,
		SwChCfg.BandIdx, SwChCfg.Channel_Band, SwChCfg.Bw, SwChCfg.bScan);
#endif /* DOT11_EHT_BE */

#ifdef ANTENNA_CONTROL_SUPPORT
	{
		if (pAd->bAntennaSetAPEnable) {
			SwChCfg.TxStream = pAd->TxStream;
			SwChCfg.RxStream = pAd->RxStream;
		}
	}
#endif /* ANTENNA_CONTROL_SUPPORT */

	/* Step 5: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CHAN_SWITCH);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);


	//MtAndesInitCmdMsg(msg, attr);
	//os_zero_mem(&CmdChanSwitch, sizeof(CmdChanSwitch));
	pCmdChanSwitchTlv->rChanSwitchInfo.ucPrimCh = SwChCfg.ControlChannel;
#ifdef DOT11_EHT_BE
	/* For BW320, pass eht_cen_ch to FW*/
	if (SwChCfg.Bw == BW_320)
		pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = SwChCfg.eht_cen_ch;
	else
#endif /* DOT11_EHT_BE */
		pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = SwChCfg.CentralChannel;

	pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh2 = SwChCfg.ControlChannel2;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucTxStreamNum = SwChCfg.TxStream;
#if defined(CONFIG_ATE)
	if (ATE_ON(pAd)) {
		/* transform from bitwise to total */
		for (ant_seq = 0 ; ant_seq < MCS_NSS_CAP(pAd)->max_nss ; ant_seq++)
			if (SwChCfg.RxStream & (0x1 << ant_seq))
				rx_stream_num++;

		pCmdChanSwitchTlv->rChanSwitchInfo.ucRxStreamNum = rx_stream_num;
	} else
#endif	/* CONFIG_ATE */
	{
		pCmdChanSwitchTlv->rChanSwitchInfo.ucRxStreamNum = SwChCfg.RxStream;
	}
	pCmdChanSwitchTlv->rChanSwitchInfo.ucDbdcIdx = SwChCfg.BandIdx;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucBW = GetCfgBw2RawBw(SwChCfg.Bw);
	pCmdChanSwitchTlv->rChanSwitchInfo.ucBand = SwChCfg.Channel_Band;
	pCmdChanSwitchTlv->rChanSwitchInfo.u4OutBandFreq = cpu2le32(SwChCfg.OutBandFreq);
	pCmdChanSwitchTlv->rChanSwitchInfo.ucAPBW = GetCfgBw2RawBw(SwChCfg.ap_bw);
	pCmdChanSwitchTlv->rChanSwitchInfo.ucAPCentralCh = SwChCfg.ap_central_channel;
#ifdef COMPOS_TESTMODE_WIN

	if (SwChCfg.isMCC) {
		/* MCC */
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_INTERNAL_USED_BY_FW_3;
	} else
#endif
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_BY_NORMAL_TX_RX;

	if (SwChCfg.bScan)
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_SCAN_BYPASS_DPD;
#ifdef MT_DFS_SUPPORT
	else {
		if (SwChCfg.bDfsCheck)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;

		if (doNotCal && (*ch_stat == DFS_INB_CH_INIT || *ch_stat == DFS_OUTB_CH_CAC)
		&& pDfsParam->bDedicatedZeroWaitSupport == TRUE)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;

		if (SwChCfg.bDnlCal)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_MP_LINE_DNL_CAL;
	}
#endif
#ifdef DFS_ADJ_BW_ZERO_WAIT
	/* while BW160 zero-wait case, althought BW is 80, we need to set BW160 for listen RDD */
	if (IS_ADJ_BW_ZERO_WAIT_TX80RX160(pAd->CommonCfg.DfsParameter.BW160ZeroWaitState)
	&& (pCmdChanSwitchTlv->rChanSwitchInfo.ucBW == GetCfgBw2RawBw(BW_80))) {
		pCmdChanSwitchTlv->rChanSwitchInfo.ucBW = GetCfgBw2RawBw(BW_160);
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;
		if (IS_CH_BETWEEN(SwChCfg.ControlChannel, 36, 64))
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = 50;
		else if (IS_CH_BETWEEN(SwChCfg.ControlChannel, 100, 128))
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = 114;

		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_NOTICE,
			"[RDM]SW ZW-DFS available, change ucCentralCh=%d, ucBW=%d\n",
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh, pCmdChanSwitchTlv->rChanSwitchInfo.ucBW);
	}
#endif
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, ucDebugLevel,
		"TXStream=%d, RXStream=%d, ap_bw=%d, ap_central_channel=%d, reason=%d\n",
		SwChCfg.TxStream, SwChCfg.RxStream, SwChCfg.ap_bw, SwChCfg.ap_central_channel,
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason);

	/* check Tx Power setting from UI. */
	if ((pAd->CommonCfg.ucTxPowerPercentage > 90) &&
		(pAd->CommonCfg.ucTxPowerPercentage < 100))
		TxPowerDrop = 0;
	else if ((pAd->CommonCfg.ucTxPowerPercentage > 60) &&
			 (pAd->CommonCfg.ucTxPowerPercentage <= 90))
		TxPowerDrop = 1;  /* reduce Pwr for 1 dB. */
	else if ((pAd->CommonCfg.ucTxPowerPercentage > 30) &&
			 (pAd->CommonCfg.ucTxPowerPercentage <= 60))
		TxPowerDrop = 3;  /* reduce Pwr for 3 dB. */
	else if ((pAd->CommonCfg.ucTxPowerPercentage > 15) &&
			 (pAd->CommonCfg.ucTxPowerPercentage <= 30))
		TxPowerDrop = 6;  /* reduce Pwr for 6 dB. */
	else if ((pAd->CommonCfg.ucTxPowerPercentage > 9) &&
			 (pAd->CommonCfg.ucTxPowerPercentage <= 15))
		TxPowerDrop = 9;  /* reduce Pwr for 9 dB. */
	else if ((pAd->CommonCfg.ucTxPowerPercentage > 0) &&
			 (pAd->CommonCfg.ucTxPowerPercentage <= 9))
		TxPowerDrop = 12;  /* reduce Pwr for 12 dB. */

	pCmdChanSwitchTlv->rChanSwitchInfo.cTxPowerDrop = TxPowerDrop;
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_DEBUG,
		" TxPowerDrop = 0x%x, ucTxPath:%u\n",
		pCmdChanSwitchTlv->rChanSwitchInfo.cTxPowerDrop, ucTxPath);

	for (SKUIdx = 0; SKUIdx < SKU_SIZE; SKUIdx++)
		pCmdChanSwitchTlv->rChanSwitchInfo.acTxPowerSKU[SKUIdx] = 0x3F;

#ifdef SINGLE_SKU_V2

	if (SwChCfg.Channel_Band == 0) { /* Not 802.11j */
		if (SwChCfg.ControlChannel <= 14)
			fg5Gband = 0;
		else
			fg5Gband = 1;
	} else
		fg5Gband = 1;

	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_DEBUG, " fg5Gband = 0x%x\n", fg5Gband);

	for (SKUIdx = 0; SKUIdx < SKU_TOTAL_SIZE; SKUIdx++)
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_DEBUG,
			"CmdChanSwitch.aucTxPowerSKU[%d]: 0x%x\n", SKUIdx,
			pCmdChanSwitchTlv->rChanSwitchInfo.acTxPowerSKU[SKUIdx]);

	os_move_mem(pAd->TxPowerSKU, pCmdChanSwitchTlv->rChanSwitchInfo.acTxPowerSKU, SKU_SIZE);

	for (SKUIdx = 0; SKUIdx < SKU_SIZE; SKUIdx++)
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_DEBUG,
			"pAd->TxPowerSKU[%d]: 0x%x\n", SKUIdx, pAd->TxPowerSKU[SKUIdx]);
#endif /* SINGLE_SKU_V2 */

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	/* Send out CMD */
	//call_fw_cmd_notifieriers(WO_CMD_BSS_INFO, pAd, msg->net_pkt);
	ret = AndesSendCmdMsg(pAd, msg);


#ifdef NEW_SET_RX_STREAM
	/* TODO: temporary to keep channel setting */
	os_move_mem(&CurrentSwChCfg[SwChCfg.BandIdx], &SwChCfg, sizeof(MT_SWITCH_CHANNEL_CFG));
#endif
#ifdef BACKGROUND_SCAN_SUPPORT
	/* Backup switch channel configuration for background scan */
	os_move_mem(&pAd->BgndScanCtrl.CurrentSwChCfg[SwChCfg.BandIdx], &SwChCfg, sizeof(MT_SWITCH_CHANNEL_CFG));
#endif
	//ret = chip_cmd_tx(pAd, msg);
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_DEBUG, "(ret = %d)\n", ret);
	return ret;
}

INT UniCmdSetTxRxPath(struct _RTMP_ADAPTER *pAd, MT_SWITCH_CHANNEL_CFG SwChCfg)
{
	struct cmd_msg *msg;
	struct UNI_CMD_CHAN_SWITCH_T *pCmdChanSwitch = NULL;
	struct UNI_CMD_CHAN_SWITCH_TLV_T *pCmdChanSwitchTlv = NULL;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	INT32 ret = 0, i = 0;
	USHORT doNotCal = 0;
	RTMP_CHIP_OP *chip_ops = hc_get_chip_ops(pAd->hdev_ctrl);
	P_ENUM_DFS_INB_CH_SWITCH_STAT_T ch_stat = &pAd->CommonCfg.DfsParameter.inband_ch_stat;
	PDFS_PARAM pDfsParam = &pAd->CommonCfg.DfsParameter;
	struct _CMD_ATTRIBUTE attr = {0};
	MT_SWITCH_CHANNEL_CFG *pSwChCfg = &SwChCfg;
	UCHAR RxPath = 0;
	RTMP_CHIP_CAP *pChipCap = hc_get_chip_cap(pAd->hdev_ctrl);
	UCHAR ucDebugLevel = DBG_LVL_NOTICE;

	if (pSwChCfg->CentralChannel == 0) {
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_ERROR,
			"CentralChannel 0 is invalid\n");
		return -1;
	}

	/*if in scan change debug log level to info*/
	if (scan_in_run_state(pAd, NULL)) {
		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_INFO,
				 "in scan change log level to info\n");
		ucDebugLevel = DBG_LVL_INFO;
	}

	/*if 0x1A5[6]=1 , ch36~ch48 do not calibration at boot up*/
	chip_ops->eeread(pAd, PRECAL_INDICATION_BYTE, &doNotCal);
	doNotCal = doNotCal & (1 << 6);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_CHAN_SWITCH_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdChanSwitch = (struct UNI_CMD_CHAN_SWITCH_T *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

    /* Step 4: Filled in parameters of CMD_CHAN_SWITCH_T*/
	pCmdChanSwitchTlv = (struct UNI_CMD_CHAN_SWITCH_TLV_T *) pNextHeadBuf;
	os_zero_mem(pCmdChanSwitchTlv, sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T));
	pCmdChanSwitchTlv->u2Tag = UNI_CMD_CHAN_SWITCH_STREAM_PATH;
	pCmdChanSwitchTlv->u2Length = sizeof(struct UNI_CMD_CHAN_SWITCH_TLV_T);

	/*for normal case*/
	if ((pSwChCfg->Bw == BW_160 || pSwChCfg->Bw == BW_8080) &&
		!IS_PHY_CAPS(pChipCap->phy_caps, fPHY_CAP_BW160C_STD)) {
		/*if bw 160, 1 stream use WIFI (0,2), 2 stream use WIFI (0,1,2,3)*/
		RxPath = (SwChCfg.RxStream > 1) ? 0xf : 0x5;
		/*bw160 & 80+80 should always apply 4 TxStream*/
		pSwChCfg->TxStream = 4;
	} else {
		for (i = 0; i < SwChCfg.RxStream; i++) {
			if (IS_MT7915(pAd) ||
				(pChipCap->phy_caps & fPHY_CAP_DUALPHY) == fPHY_CAP_DUALPHY)
				RxPath |= (1 << i);
#ifdef CONFIG_ATE
			else if (!ATE_ON(pAd))
				RxPath |= (1 << (i + (SwChCfg.BandIdx * (2))));
#endif
		}
	}
#ifdef DOT11_EHT_BE
	/* For BW320, pass eht_cen_ch to FW*/
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, ucDebugLevel,
		"control_chl=%d, control_ch2=%d, central_chl=%d, eht_cen_ch=%d, BW=%d.\n",
		pSwChCfg->ControlChannel, pSwChCfg->ControlChannel2, pSwChCfg->CentralChannel,
		pSwChCfg->eht_cen_ch, pSwChCfg->Bw);
	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, ucDebugLevel,
		"RXPath=%x, BandIdx=%d, scan=%d, Channel_Band=%d, TXStream=%d, RXStream=%d.\n",
		RxPath, pSwChCfg->BandIdx, pSwChCfg->bScan, pSwChCfg->Channel_Band,
		pSwChCfg->TxStream, pSwChCfg->RxStream);
#endif /* DOT11_EHT_BE */

	/* Step 5: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CHAN_SWITCH);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);
	//os_zero_mem(&CmdChanSwitch, sizeof(CmdChanSwitch));
	pCmdChanSwitchTlv->rChanSwitchInfo.ucPrimCh = pSwChCfg->ControlChannel;
#ifdef DOT11_EHT_BE
	/* For BW320, pass eht_cen_ch to FW*/
	if (SwChCfg.Bw == BW_320)
		pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = pSwChCfg->eht_cen_ch;
	else
#endif /* DOT11_EHT_BE */
		pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = pSwChCfg->CentralChannel;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh2 = pSwChCfg->ControlChannel2;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucTxStreamNum = pSwChCfg->TxStream;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucAPBW = GetCfgBw2RawBw(SwChCfg.ap_bw);
	/* For normal mode, use rx path which means rx stream capability.
	   For test mode, use rx path with bit wise.
	   Need to modiy tx/rx path and set channel flow here.
	 */
#ifdef CONFIG_ATE
	if (ATE_ON(pAd))
		pCmdChanSwitchTlv->rChanSwitchInfo.ucRxStreamNum = pSwChCfg->RxStream;
	else
#endif /*CONFIG_ATE*/
		pCmdChanSwitchTlv->rChanSwitchInfo.ucRxStreamNum = RxPath;

	pCmdChanSwitchTlv->rChanSwitchInfo.ucDbdcIdx = pSwChCfg->BandIdx;
	pCmdChanSwitchTlv->rChanSwitchInfo.ucBW = GetCfgBw2RawBw(pSwChCfg->Bw);
	pCmdChanSwitchTlv->rChanSwitchInfo.ucBand = pSwChCfg->Channel_Band;
	pCmdChanSwitchTlv->rChanSwitchInfo.u2CacCase = 0;
#ifdef COMPOS_TESTMODE_WIN

	if (SwChCfg.isMCC) {
		/* MCC */
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_INTERNAL_USED_BY_FW_3;
	} else
#endif
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_BY_NORMAL_TX_RX;

	if (SwChCfg.bScan)
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_SCAN_BYPASS_DPD;
#ifdef MT_DFS_SUPPORT
	else {
		if (SwChCfg.bDfsCheck)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;

		if (doNotCal && (*ch_stat == DFS_INB_CH_INIT || *ch_stat == DFS_OUTB_CH_CAC)
		&& pDfsParam->bDedicatedZeroWaitSupport == TRUE)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;

		if (SwChCfg.bDnlCal)
			pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_MP_LINE_DNL_CAL;
	}

#endif
	pCmdChanSwitchTlv->rChanSwitchInfo.u2CacCase = cpu2le16(pCmdChanSwitchTlv->rChanSwitchInfo.u2CacCase);

#ifdef DFS_ADJ_BW_ZERO_WAIT
	/* while BW160 zero-wait case, althought BW is 80, we need to set BW160 for listen RDD */
	if (IS_ADJ_BW_ZERO_WAIT_TX80RX160(pAd->CommonCfg.DfsParameter.BW160ZeroWaitState)
	&& (pCmdChanSwitchTlv->rChanSwitchInfo.ucBW == GetCfgBw2RawBw(BW_80))) {
		pCmdChanSwitchTlv->rChanSwitchInfo.ucBW = GetCfgBw2RawBw(BW_160);
		pCmdChanSwitchTlv->rChanSwitchInfo.ucSwitchReason = CH_SWITCH_DFS;
		if (IS_CH_BETWEEN(SwChCfg.ControlChannel, 36, 64))
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = 50;
		else if (IS_CH_BETWEEN(SwChCfg.ControlChannel, 100, 128))
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh = 114;

		MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_CHN, DBG_LVL_NOTICE,
			"[RDM]SW ZW-DFS available, change ucCentralCh=%d, ucBW=%d\n",
			pCmdChanSwitchTlv->rChanSwitchInfo.ucCentralCh, pCmdChanSwitchTlv->rChanSwitchInfo.ucBW);
	}
#endif

    /* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

    /* Send out CMD */
    //call_fw_cmd_notifieriers(WO_CMD_BSS_INFO, pAd, msg->net_pkt);
	ret = AndesSendCmdMsg(pAd, msg);
	//ret = chip_cmd_tx(pAd, msg);
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG, "(ret = %d)\n", ret);
	return ret;
}

static INT32 UniCmdBandCfgRadioOnOff(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_RADIO_ONOFF_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_RADIO_ONOFF_T pBandCfgRadioOnOff =
					(P_UNI_CMD_BAND_CONFIG_RADIO_ONOFF_T)pHandle;

	pBandCfgRadioOnOff->u2Tag = UNI_CMD_BAND_CONFIG_RADIO_ONOFF;
	pBandCfgRadioOnOff->u2Length = sizeof(UNI_CMD_BAND_CONFIG_RADIO_ONOFF_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgRadioOnOff->u2Tag = cpu2le16(pBandCfgRadioOnOff->u2Tag);
	pBandCfgRadioOnOff->u2Length = cpu2le16(pBandCfgRadioOnOff->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgRadioOnOff->fgRadioOn = pParam->fgRadioOn;

	return Ret;
}

static INT32 UniCmdBandCfgRXVCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_RXV_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_RXV_CTRL_T pBandCfgRxvCtrl =
					(P_UNI_CMD_BAND_CONFIG_RXV_CTRL_T)pHandle;

	pBandCfgRxvCtrl->u2Tag = UNI_CMD_BAND_CONFIG_RXV_CTRL;
	pBandCfgRxvCtrl->u2Length = sizeof(UNI_CMD_BAND_CONFIG_RXV_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgRxvCtrl->u2Tag = cpu2le16(pBandCfgRxvCtrl->u2Tag);
	pBandCfgRxvCtrl->u2Length = cpu2le16(pBandCfgRxvCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgRxvCtrl->ucRxvOfRxEnable = pParam->ucRxvOfRxEnable;
	pBandCfgRxvCtrl->ucRxvOfTxEnable = pParam->ucRxvOfTxEnable;

	return Ret;
}

static INT32 UniCmdBandCfgSetRxFilter(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_SET_RX_FILTER_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_SET_RX_FILTER_T pBandCfgSetRxFilter =
					(P_UNI_CMD_BAND_CONFIG_SET_RX_FILTER_T)pHandle;

	pBandCfgSetRxFilter->u2Tag = UNI_CMD_BAND_CONFIG_SET_RX_FILTER;
	pBandCfgSetRxFilter->u2Length = sizeof(UNI_CMD_BAND_CONFIG_SET_RX_FILTER_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgSetRxFilter->u2Tag = cpu2le16(pBandCfgSetRxFilter->u2Tag);
	pBandCfgSetRxFilter->u2Length = cpu2le16(pBandCfgSetRxFilter->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgSetRxFilter->u4RxPacketFilter = cpu2le32(pParam->u4RxPacketFilter);

	return Ret;
}

static INT32 UniCmdBandCfgDropCtrlFrame(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME_T pBandCfgDropCtrlFrame =
				(P_UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME_T)pHandle;

	pBandCfgDropCtrlFrame->u2Tag = UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME;
	pBandCfgDropCtrlFrame->u2Length = sizeof(UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgDropCtrlFrame->u2Tag = cpu2le16(pBandCfgDropCtrlFrame->u2Tag);
	pBandCfgDropCtrlFrame->u2Length = cpu2le16(pBandCfgDropCtrlFrame->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgDropCtrlFrame->ucDropRts = pParam->ucDropRts;
	pBandCfgDropCtrlFrame->ucDropCts = pParam->ucDropCts;
	pBandCfgDropCtrlFrame->ucDropUnwantedCtrl = pParam->ucDropUnwantedCtrl;

	return Ret;
}

static INT32 UniCmdBandCfgAGGACLimit(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T pBandCfgAGGAcLimit =
					(P_UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T)pHandle;

	pBandCfgAGGAcLimit->u2Tag = UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT;
	pBandCfgAGGAcLimit->u2Length = sizeof(UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgAGGAcLimit->u2Tag = cpu2le16(pBandCfgAGGAcLimit->u2Tag);
	pBandCfgAGGAcLimit->u2Length = cpu2le16(pBandCfgAGGAcLimit->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgAGGAcLimit->ucWmmIdx = pParam->ucWmmIdx;
	pBandCfgAGGAcLimit->ucAc = pParam->ucAc;
	pBandCfgAGGAcLimit->ucAggLimit = pParam->ucAggLimit;

	return Ret;
}

static INT32 UniCmdBandCfgEDCCAEnable(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_EDCCA_ENABLE_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_EDCCA_ENABLE_CTRL_T pBandCfgEDCCAEnable =
					(P_UNI_CMD_BAND_CONFIG_EDCCA_ENABLE_CTRL_T)pHandle;

	pBandCfgEDCCAEnable->u2Tag = UNI_CMD_BAND_CONFIG_EDCCA_ENABLE;
	pBandCfgEDCCAEnable->u2Length = sizeof(UNI_CMD_BAND_CONFIG_EDCCA_ENABLE_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgEDCCAEnable->u2Tag = cpu2le16(pBandCfgEDCCAEnable->u2Tag);
	pBandCfgEDCCAEnable->u2Length = cpu2le16(pBandCfgEDCCAEnable->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgEDCCAEnable->fgEDCCAEnable = pParam->fgEDCCAEnable;
	pBandCfgEDCCAEnable->fgEDCCAStd = pParam->fgEDCCAStd;

	return Ret;
}

static INT32 UniCmdBandCfgEDCCAThreshold(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD_CTRL_T pBandCfgEDCCAThreshold =
							(P_UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD_CTRL_T)pHandle;
	UINT32 i;

	pBandCfgEDCCAThreshold->u2Tag = UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD;
	pBandCfgEDCCAThreshold->u2Length = sizeof(UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgEDCCAThreshold->u2Tag = cpu2le16(pBandCfgEDCCAThreshold->u2Tag);
	pBandCfgEDCCAThreshold->u2Length = cpu2le16(pBandCfgEDCCAThreshold->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgEDCCAThreshold->fginit = pParam->fginit;
	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
		pBandCfgEDCCAThreshold->u1EDCCAThreshold[i] = pParam->u1EDCCAThreshold[i];

	return Ret;
}

static INT32 UniCmdBandCfgRTSSigEn(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN_T *pBandCfgRTSSigEn =
							(struct UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN_T *)pHandle;

	pBandCfgRTSSigEn->u2Tag = UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN;
	pBandCfgRTSSigEn->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgRTSSigEn->u2Tag = cpu2le16(pBandCfgRTSSigEn->u2Tag);
	pBandCfgRTSSigEn->u2Length = cpu2le16(pBandCfgRTSSigEn->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgRTSSigEn->Enable = pParam->Enable;

	return Ret;
}

static INT32 UniCmdBandCfgSchDetDis(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_SCH_DET_DIS_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;

	struct UNI_CMD_BAND_CONFIG_SCH_DET_DIS_T *pBandCfgSchDetDis =
							(struct UNI_CMD_BAND_CONFIG_SCH_DET_DIS_T *)pHandle;

	pBandCfgSchDetDis->u2Tag = UNI_CMD_BAND_CONFIG_SCH_DET_DIS;
	pBandCfgSchDetDis->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_SCH_DET_DIS_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgSchDetDis->u2Tag = cpu2le16(pBandCfgSchDetDis->u2Tag);
	pBandCfgSchDetDis->u2Length = cpu2le16(pBandCfgSchDetDis->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgSchDetDis->Disable = pParam->Disable;

	return Ret;
}

static INT32 UniCmdBandCfgRTS0PktThreshold(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;

	struct UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG_T *pBandCfgSchRTS0PktThreshold =
									(struct UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG_T *)pHandle;

	pBandCfgSchRTS0PktThreshold->u2Tag = UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG;
	pBandCfgSchRTS0PktThreshold->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgSchRTS0PktThreshold->u2Tag = cpu2le16(pBandCfgSchRTS0PktThreshold->u2Tag);
	pBandCfgSchRTS0PktThreshold->u2Length = cpu2le16(pBandCfgSchRTS0PktThreshold->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgSchRTS0PktThreshold->Enable = pParam->Enable;
	pBandCfgSchRTS0PktThreshold->u4Value = pParam->u4Value;
	pBandCfgSchRTS0PktThreshold->ucType = pParam->ucType;

	return Ret;
}

static INT32 UniCmdBandCfgAckCtsTimeout(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT_T *pBandCfgAckCtsTimeout =
					(struct UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT_T *)pHandle;

	pBandCfgAckCtsTimeout->u2Tag = UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT;
	pBandCfgAckCtsTimeout->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgAckCtsTimeout->u2Tag = cpu2le16(pBandCfgAckCtsTimeout->u2Tag);
	pBandCfgAckCtsTimeout->u2Length = cpu2le16(pBandCfgAckCtsTimeout->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgAckCtsTimeout->u1Type = pParam->u1Type;
	pBandCfgAckCtsTimeout->u4TimeoutValue = cpu2le32(pParam->u4TimeoutValue);

	return Ret;
}

static INT32 UniCmdBandCfgRtsThreshold(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_RTS_THRESHOLD_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_RTS_THRESHOLD_T *pBandCfgEDCCAThreshold =
					(struct UNI_CMD_BAND_CONFIG_RTS_THRESHOLD_T *)pHandle;

	pBandCfgEDCCAThreshold->u2Tag = UNI_CMD_BAND_CONFIG_RTS_THRESHOLD;
	pBandCfgEDCCAThreshold->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_RTS_THRESHOLD_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgEDCCAThreshold->u2Tag = cpu2le16(pBandCfgEDCCAThreshold->u2Tag);
	pBandCfgEDCCAThreshold->u2Length = cpu2le16(pBandCfgEDCCAThreshold->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgEDCCAThreshold->u4RtsPktLenThreshold = cpu2le32(pParam->u4RtsPktLenThreshold);
	pBandCfgEDCCAThreshold->u4RtsPktNumThreshold = cpu2le32(pParam->u4RtsPktNumThreshold);

	return Ret;
}

static INT32 UniCmdBandCfgMacEnableCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL_T *pBandCfgMacEnableCtrl =
					(struct UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL_T *)pHandle;

	pBandCfgMacEnableCtrl->u2Tag = UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL;
	pBandCfgMacEnableCtrl->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgMacEnableCtrl->u2Tag = cpu2le16(pBandCfgMacEnableCtrl->u2Tag);
	pBandCfgMacEnableCtrl->u2Length = cpu2le16(pBandCfgMacEnableCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgMacEnableCtrl->ucMacEnable = pParam->ucMacEnable;

	return Ret;
}

static INT32 UniCmdBandCfgLpiCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_LPI_CTRL_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_LPI_CTRL_T *pBandCfgLpiCtrl =
					(struct UNI_CMD_BAND_CONFIG_LPI_CTRL_T *)pHandle;

	pBandCfgLpiCtrl->u2Tag = UNI_CMD_BAND_CONFIG_LPI_CTRL;
	pBandCfgLpiCtrl->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_LPI_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgLpiCtrl->u2Tag = cpu2le16(pBandCfgLpiCtrl->u2Tag);
	pBandCfgLpiCtrl->u2Length = cpu2le16(pBandCfgLpiCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgLpiCtrl->ucLpiEnable = pParam->ucLpiEnable;
	pBandCfgLpiCtrl->ucPSDLimit = pParam->ucPSDLimit;

	return Ret;
}
static INT32 UniCmdBandCfgRxAckToHost(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST_T *pBandCfgRxAckToHost =
					(struct UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST_T *)pHandle;

	pBandCfgRxAckToHost->u2Tag = UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST;
	pBandCfgRxAckToHost->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgRxAckToHost->u2Tag = cpu2le16(pBandCfgRxAckToHost->u2Tag);
	pBandCfgRxAckToHost->u2Length = cpu2le16(pBandCfgRxAckToHost->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgRxAckToHost->fgEnable = pParam->fgEnable;

	return Ret;
}

static INT32 UniCmdBandCfgBarRetryLimit(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT_T *pBandCfgBarRetryLimit =
					(struct UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT_T *)pHandle;

	pBandCfgBarRetryLimit->u2Tag = UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT;
	pBandCfgBarRetryLimit->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgBarRetryLimit->u2Tag = cpu2le16(pBandCfgBarRetryLimit->u2Tag);
	pBandCfgBarRetryLimit->u2Length = cpu2le16(pBandCfgBarRetryLimit->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pBandCfgBarRetryLimit->ucBarRetryLimit = pParam->ucBarRetryLimit;

	return Ret;
}

static INT32 UniCmdBandCfgStaPauseDump(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE_T *pBandCfgStaPauseDump =
					(struct UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE_T *)pHandle;

	pBandCfgStaPauseDump->u2Tag = UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE;
	pBandCfgStaPauseDump->u2Length = sizeof(struct UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE_T);
#ifdef CFG_BIG_ENDIAN
	pBandCfgStaPauseDump->u2Tag = cpu2le16(pBandCfgStaPauseDump->u2Tag);
	pBandCfgStaPauseDump->u2Length = cpu2le16(pBandCfgStaPauseDump->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdBandCfgTab[UNI_CMD_BAND_CONFIG_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RADIO_ONOFF,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_RADIO_ONOFF_T),
		.pfHandler = UniCmdBandCfgRadioOnOff
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RXV_CTRL,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_RXV_CTRL_T),
		.pfHandler = UniCmdBandCfgRXVCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_SET_RX_FILTER,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_SET_RX_FILTER_T),
		.pfHandler = UniCmdBandCfgSetRxFilter
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME_T),
		.pfHandler = UniCmdBandCfgDropCtrlFrame
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T),
		.pfHandler = UniCmdBandCfgAGGACLimit
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_EDCCA_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_EDCCA_ENABLE_CTRL_T),
		.pfHandler = UniCmdBandCfgEDCCAEnable
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD,
		.u4StructSize = sizeof(UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD_CTRL_T),
		.pfHandler = UniCmdBandCfgEDCCAThreshold
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT_T),
		.pfHandler = UniCmdBandCfgAckCtsTimeout
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RTS_THRESHOLD,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_RTS_THRESHOLD_T),
		.pfHandler = UniCmdBandCfgRtsThreshold
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN_T),
		.pfHandler = UniCmdBandCfgRTSSigEn
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_SCH_DET_DIS,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_SCH_DET_DIS_T),
		.pfHandler = UniCmdBandCfgSchDetDis
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG_T),
		.pfHandler = UniCmdBandCfgRTS0PktThreshold
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL_T),
		.pfHandler = UniCmdBandCfgMacEnableCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_LPI_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_LPI_CTRL_T),
		.pfHandler = UniCmdBandCfgLpiCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST_T),
		.pfHandler = UniCmdBandCfgRxAckToHost
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT_T),
		.pfHandler = UniCmdBandCfgBarRetryLimit
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_DUAL_CTS_CFG,
		.u4StructSize = 0, /* TBD */
		.pfHandler = NULL /* TBD */
	},
	{
		.u8CmdFeature = UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE,
		.u4StructSize = sizeof(struct UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE_T),
		.pfHandler = UniCmdBandCfgStaPauseDump
	},
};

INT32 UniCmdBandConfig(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_BAND_CFG_PARAM_T pParamCtrl)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	P_UNI_CMD_BAND_CONFIG_T	pCmdBandCfg = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_BAND_CONFIG_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_BAND_CONFIG_MAX_NUM; i++) {
		if (pParamCtrl->BandCfgTagValid[i])
			u4CmdNeedMaxBufSize += UniCmdBandCfgTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdBandCfg = (P_UNI_CMD_BAND_CONFIG_T)pNextHeadBuf;
	pCmdBandCfg->ucDbdcIdx = pParamCtrl->ucDbdcIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_BAND_CONFIG_MAX_NUM; i++) {
		if (pParamCtrl->BandCfgTagValid[i]) {
			switch (i) {
			case UNI_CMD_BAND_CONFIG_RADIO_ONOFF:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RADIO_ONOFF_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRadioOnOff, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_RXV_CTRL:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RXV_CTRL_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRXVCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_SET_RX_FILTER:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_SET_RX_FILTER_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgSetRxFilter, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_DROP_CTRL_FRAME_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgDropCtrlFrame, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_AGG_AC_LIMIT_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgAGGAcLimit, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_EDCCA_ENABLE:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_EDCCA_ENABLE_CTRL_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgEDCCAEnable, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_EDCCA_THRESHOLD_CTRL_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgEDCCAThreshold, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_ACK_CTS_TIMEOUT_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgACKCTSTimeout, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_RTS_THRESHOLD:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RTS_THRESHOLD_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRTSThreshold, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;
			case UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RTS_SIGTA_EN_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRtsSigtaen, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_SCH_DET_DIS:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_SCH_DET_DIS_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgSCHDetDis, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RTS0_PKT_THRESHOLD_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRTS0PktThreshold, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_MAC_ENABLE_CTRL_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgMacEnableCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_LPI_CTRL:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_LPI_CTRL_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgLpiCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_RX_ACK_TO_HOST_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgRxAckToHost, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_BAR_RETRY_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgBarRetryLimit, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;
			/*
				TBD:
			case UNI_CMD_BAND_CONFIG_DUAL_CTS_CFG:
				break;
			*/
			case UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE:
				if (UniCmdBandCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_BAND_CFG_DUMP_STA_PAUSE_HANDLE)(UniCmdBandCfgTab[i].pfHandler))(pAd, &pParamCtrl->BandCfgStaPauseDump, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdBandCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdBandCfgTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdBandCfgTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BAND_CONFIG);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (pParamCtrl->bQuery) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					if (pParamCtrl->BandCfgTagValid[UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT]) {
						SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, &pParamCtrl->BandCfgACKCTSTimeout.u4TimeoutValue);
						SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(pParamCtrl->BandCfgACKCTSTimeout.u4TimeoutValue));
					} else {
						SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					}
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventBandConfigHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				if (pParamCtrl->bQuery)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

/*********************************************
 * UNI_CMD_BAND_CONFIG_RADIO_ONOFF (Tag 0x00)
 *********************************************/
INT32 UniCmdRadioOnOff(struct _RTMP_ADAPTER *pAd, MT_PMSTAT_CTRL_T PmStatCtrl)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = PmStatCtrl.DbdcIdx;
	if (PmStatCtrl.PmState == EXIT_PM_STATE)
		BandCfgParam.BandCfgRadioOnOff.fgRadioOn = TRUE;
	else
		BandCfgParam.BandCfgRadioOnOff.fgRadioOn = FALSE;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RADIO_ONOFF] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

/*********************************************
 * UNI_CMD_BAND_CONFIG_RXV_CTRL (Tag 0x01)
 *********************************************/
INT32 UniCmdRxvCtrl(struct _RTMP_ADAPTER *pAd, UINT8 ucDbdcIdx, UINT8 TxRx, UINT8 ucEnable)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	if ((TxRx < ASIC_MAC_TXRX_RXV) || (TxRx > ASIC_MAC_RX_RXV))
		return NDIS_STATUS_INVALID_DATA;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = ucDbdcIdx;
	if (TxRx == ASIC_MAC_RXV) {
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfTxEnable = ucEnable;
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfRxEnable = pAd->RxvOfRxEnable;
		pAd->RxvOfTxEnable = ucEnable;
	} else if (TxRx == ASIC_MAC_RX_RXV) {
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfRxEnable = ucEnable;
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfTxEnable = pAd->RxvOfTxEnable;
		pAd->RxvOfRxEnable = ucEnable;
	} else if (TxRx == ASIC_MAC_TXRX_RXV) {
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfRxEnable = ucEnable;
		BandCfgParam.BandCfgRXVCtrl.ucRxvOfTxEnable = ucEnable;
		pAd->RxvOfTxEnable = ucEnable;
		pAd->RxvOfRxEnable = ucEnable;
	}

	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RXV_CTRL] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_RXPHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdSetEDCCAThreshold(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1edcca_threshold[],
	UINT8 u1BandIdx,
	BOOLEAN bInit
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	INT32 status = TRUE;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;
	UINT32 i;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = u1BandIdx;
	BandCfgParam.BandCfgEDCCAThreshold.fginit = bInit;
	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
		BandCfgParam.BandCfgEDCCAThreshold.u1EDCCAThreshold[i] = u1edcca_threshold[i];
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret != NDIS_STATUS_SUCCESS)
		status = FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return status;
}

INT32 UniCmdGetEDCCAThreshold(struct _RTMP_ADAPTER *pAd, UINT8 u1BandIdx, BOOLEAN bInit)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	INT status = TRUE;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = u1BandIdx;
	BandCfgParam.bQuery = TRUE;
	BandCfgParam.BandCfgEDCCAThreshold.fginit = bInit;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_EDCCA_THRESHOLD] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret != NDIS_STATUS_SUCCESS)
		status = FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return status;
}

INT32 UniCmdSetEDCCAEnable(struct _RTMP_ADAPTER *pAd, UINT8 u1EDCCACtrl, UINT8 u1BandIdx, UINT8 u1EDCCAStd)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	INT32 status = TRUE;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = u1BandIdx;
	BandCfgParam.BandCfgEDCCAEnable.fgEDCCAEnable = u1EDCCACtrl;
	BandCfgParam.BandCfgEDCCAEnable.fgEDCCAStd = u1EDCCAStd;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_EDCCA_ENABLE] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret != NDIS_STATUS_SUCCESS)
		status = FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return status;
}

INT32 UniCmdGetEDCCAEnable(struct _RTMP_ADAPTER *pAd, UINT8 u1BandIdx)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	INT32 status = TRUE;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = u1BandIdx;
	BandCfgParam.bQuery = TRUE;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_EDCCA_ENABLE] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret != NDIS_STATUS_SUCCESS)
		status = FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return status;
}

#ifdef ACK_CTS_TIMEOUT_SUPPORT
INT32 UniCmdACKCTSTimeoutRead(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	UINT8 Type,
	UINT32 *Value)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.bQuery = TRUE;
	BandCfgParam.BandCfgACKCTSTimeout.u1Type = Type;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret == NDIS_STATUS_SUCCESS)
		*Value = BandCfgParam.BandCfgACKCTSTimeout.u4TimeoutValue;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}
#endif /* ACK_CTS_TIMEOUT_SUPPORT */

INT32 UniCmdUpdateRTSThreshold(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	UCHAR pkt_num,
	UINT32 length)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));

	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.bQuery = FALSE;
	BandCfgParam.BandCfgRTSThreshold.u4RtsPktLenThreshold = length;
	BandCfgParam.BandCfgRTSThreshold.u4RtsPktNumThreshold = pkt_num;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RTS_THRESHOLD] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdConfigSetRtsSignalEn(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	BOOLEAN enable)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.BandCfgRtsSigtaen.Enable = enable;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RTS_SIGTA_EN] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdConfigSetSchDetDis(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	BOOLEAN enable)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.BandCfgSCHDetDis.Disable = enable;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_SCH_DET_DIS] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetRTS0PktThresholdCfg(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	UINT32 value)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.BandCfgRTS0PktThreshold.u4Value = value;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RTS0_PKT_THRESHOLD_CFG] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdSetMacTxRx(
	struct _RTMP_ADAPTER *pAd,
	UINT8 BandIdx,
	UINT8 ucMacEnable)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = BandIdx;
	BandCfgParam.BandCfgMacEnableCtrl.ucMacEnable = ucMacEnable;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_MAC_ENABLE_CTRL] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdSetRxAckToHost(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	BOOLEAN Enable)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);
	BandCfgParam.BandCfgRxAckToHost.fgEnable = Enable;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_RX_ACK_TO_HOST] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdSetBarRetry(
	struct _RTMP_ADAPTER *pAd,
	UINT8 CntLimit)
{
	INT32 ret;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = hc_get_hw_band_idx(pAd);
	BandCfgParam.BandCfgBarRetryLimit.ucBarRetryLimit = CntLimit;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_BAR_RETRY_LIMIT] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdGetStaPause(struct _RTMP_ADAPTER *pAd, UINT8 u1BandIdx)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	INT32 status = TRUE;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = u1BandIdx;
	BandCfgParam.bQuery = TRUE;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_DUMP_STA_PAUSE] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	if (ret != NDIS_STATUS_SUCCESS)
		status = FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return status;
}

static INT32 UniCmdFwLogCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_FW_LOG_CTRL_BASIC_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_FW_LOG_CTRL_BASIC_T *pFwLogCtrl =
			(struct UNI_CMD_FW_LOG_CTRL_BASIC_T *)pHandle;

	pFwLogCtrl->u2Tag = UNI_CMD_WSYS_CONFIG_FW_LOG_CTRL;
	pFwLogCtrl->u2Length = sizeof(struct UNI_CMD_FW_LOG_CTRL_BASIC_T);
#ifdef CFG_BIG_ENDIAN
	pFwLogCtrl->u2Tag = cpu2le16(pFwLogCtrl->u2Tag);
	pFwLogCtrl->u2Length = cpu2le16(pFwLogCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFwLogCtrl->ucFwLog2HostCtrl = pParam->ucFwLog2HostCtrl;
	pFwLogCtrl->ucFwLog2HostInterval = pParam->ucFwLog2HostInterval;

	return Ret;
}

static INT32 UniCmdFwDbgCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_FW_DBG_CTRL_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_FW_DBG_CTRL_T *pFwDbgCtrl =
			(struct UNI_CMD_FW_DBG_CTRL_T *)pHandle;

	pFwDbgCtrl->u2Tag = UNI_CMD_WSYS_CONFIG_FW_DBG_CTRL;
	pFwDbgCtrl->u2Length = sizeof(struct UNI_CMD_FW_DBG_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pFwDbgCtrl->u2Tag = cpu2le16(pFwDbgCtrl->u2Tag);
	pFwDbgCtrl->u2Length = cpu2le16(pFwDbgCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFwDbgCtrl->u4DbgModuleIdx = cpu2le32(pParam->u4DbgModuleIdx);
	pFwDbgCtrl->ucDbgClass = pParam->ucDbgClass;

	return Ret;
}

static INT32 UniCmdFwLogUICtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL_T *pFwLogUICtrl =
			(struct UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL_T *)pHandle;

	pFwLogUICtrl->u2Tag = UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL;
	pFwLogUICtrl->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pFwLogUICtrl->u2Tag = cpu2le16(pFwLogUICtrl->u2Tag);
	pFwLogUICtrl->u2Length = cpu2le16(pFwLogUICtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFwLogUICtrl->ucVersion = cpu2le32(pParam->ucVersion);
	pFwLogUICtrl->ucLogLevel = cpu2le32(pParam->ucLogLevel);

	return Ret;
}

static INT32 UniCmdFwBasicConfig(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T *pFwBasicConfig =
			(struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T *)pHandle;

	pFwBasicConfig->u2Tag = UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG;
	pFwBasicConfig->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T);
#ifdef CFG_BIG_ENDIAN
	pFwBasicConfig->u2Tag = cpu2le16(pFwBasicConfig->u2Tag);
	pFwBasicConfig->u2Length = cpu2le16(pFwBasicConfig->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFwBasicConfig->u2RxChecksum = cpu2le16(pParam->u2RxChecksum);
	pFwBasicConfig->u2TxChecksum = cpu2le16(pParam->u2TxChecksum);
	pFwBasicConfig->ucCtrlFlagAssertPath = pParam->ucCtrlFlagAssertPath;

	return Ret;
}

static INT32 UniCmdHostReportTxLatencyConfig(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_HOSTREPORT_TX_LATENCY_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_HOSTREPORT_TX_LATENCY_T *pHostReportTxLantencyCfg =
		(struct UNI_CMD_WSYS_CONFIG_HOSTREPORT_TX_LATENCY_T *)pHandle;

	pHostReportTxLantencyCfg->u2Tag = UNI_CMD_HOSTREPORT_TX_LATENCY_CONFIG;
	pHostReportTxLantencyCfg->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_HOSTREPORT_TX_LATENCY_T);
#ifdef CFG_BIG_ENDIAN
	pHostReportTxLantencyCfg->u2Tag = cpu2le16(pHostReportTxLantencyCfg->u2Tag);
	pHostReportTxLantencyCfg->u2Length = cpu2le16(pHostReportTxLantencyCfg->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pHostReportTxLantencyCfg->ucActive = pParam->ucActive;

	return Ret;
}

static INT32 UniCmdFwLogBufferCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL_T *pFwLogBufferCtrl =
		(struct UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL_T *)pHandle;

	pFwLogBufferCtrl->u2Tag = UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL;
	pFwLogBufferCtrl->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pFwLogBufferCtrl->u2Tag = cpu2le16(pFwLogBufferCtrl->u2Tag);
	pFwLogBufferCtrl->u2Length = cpu2le16(pFwLogBufferCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	/* TODO */

	return Ret;
}

static INT32 UniCmdCertCfgCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_CERT_CFG_CTRL *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_CERT_CFG_CTRL *pCertCfgCtrl =
		(struct UNI_CMD_WSYS_CONFIG_CERT_CFG_CTRL *)pHandle;

	pCertCfgCtrl->u2Tag = UNI_CMD_CERT_CFG;
	pCertCfgCtrl->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_CERT_CFG_CTRL);
#ifdef CFG_BIG_ENDIAN
	pCertCfgCtrl->u2Tag = cpu2le16(pCertCfgCtrl->u2Tag);
	pCertCfgCtrl->u2Length = cpu2le16(pCertCfgCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pCertCfgCtrl->ucActive = pParam->ucActive;

	return Ret;
}

static INT32 UniCmdFwTimeSync(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_WSYS_CONFIG_FW_TIME_SYNC *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CONFIG_FW_TIME_SYNC *pFwTimeSync =
		(struct UNI_CMD_WSYS_CONFIG_FW_TIME_SYNC *)pHandle;

	pFwTimeSync->u2Tag = UNI_CMD_FW_TIME_SYNC;
	pFwTimeSync->u2Length = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_TIME_SYNC);
	pFwTimeSync->u4Second = pParam->u4Second;
	pFwTimeSync->u4Usecond = pParam->u4Usecond;
#ifdef CFG_BIG_ENDIAN
	pFwTimeSync->u2Tag = cpu2le16(pFwTimeSync->u2Tag);
	pFwTimeSync->u2Length = cpu2le16(pFwTimeSync->u2Length);
	pFwTimeSync->u4Second = cpu2le32(pFwTimeSync->u4Second);
	pFwTimeSync->u4Usecond = cpu2le32(pFwTimeSync->u4Usecond);
#endif /* CFG_BIG_ENDIAN */

	return Ret;
}


static INT32 UniCmdFwDup11vMbssBcn(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_FW_DUP_MBSS_BCN_T *pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_FW_DUP_MBSS_BCN_T *pFw11vMbssCtrl =
		(struct UNI_CMD_FW_DUP_MBSS_BCN_T *)pHandle;

	pFw11vMbssCtrl->u2Tag = UNI_CMD_WSYS_CONFIG_FW_DUP_MBSS_BCN;
	pFw11vMbssCtrl->u2Length = sizeof(struct UNI_CMD_FW_DUP_MBSS_BCN_T);

#ifdef CFG_BIG_ENDIAN
	pFw11vMbssCtrl->u2Tag = cpu2le16(pFw11vMbssCtrl->u2Tag);
	pFw11vMbssCtrl->u2Length = cpu2le16(pFw11vMbssCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFw11vMbssCtrl->fgEnable = pParam->fgEnable;

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_NOTICE,
			"WM DUP BCN = %d\n",
			pFw11vMbssCtrl->fgEnable);

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdWsysCfgTab[UNI_CMD_WSYS_CONFIG_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_LOG_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_FW_LOG_CTRL_BASIC_T),
		.pfHandler = UniCmdFwLogCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_DBG_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_FW_DBG_CTRL_T),
		.pfHandler = UniCmdFwDbgCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL_T),
		.pfHandler = UniCmdFwLogUICtrl
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T),
		.pfHandler = UniCmdFwBasicConfig
	},
	{
		.u8CmdFeature = UNI_CMD_HOSTREPORT_TX_LATENCY_CONFIG,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG_T),
		.pfHandler = UniCmdHostReportTxLatencyConfig
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL_T),
		.pfHandler = UniCmdFwLogBufferCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_CERT_CFG,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_CERT_CFG_CTRL),
		.pfHandler = UniCmdCertCfgCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_FW_TIME_SYNC,
		.u4StructSize = sizeof(struct UNI_CMD_WSYS_CONFIG_FW_TIME_SYNC),
		.pfHandler = UniCmdFwTimeSync
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_PLUSH_PS_PLE,
		.u4StructSize = 0, /* TODO  */
		.pfHandler = NULL
	},
	{
		.u8CmdFeature = UNI_CMD_WSYS_CONFIG_FW_DUP_MBSS_BCN,
		.u4StructSize = sizeof(struct UNI_CMD_FW_DUP_MBSS_BCN_T),
		.pfHandler = UniCmdFwDup11vMbssBcn
	},
};

INT32 UniCmdWsysConfig(struct _RTMP_ADAPTER *pAd, struct UNI_CMD_WSYS_CFG_PARAM_T *pParamCtrl)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	struct UNI_CMD_WSYS_CONFIG_T *pCmdWsysCfg = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_WSYS_CONFIG_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_WSYS_CONFIG_MAX_NUM; i++) {
		if (pParamCtrl->WsysCfgTagValid[i])
			u4CmdNeedMaxBufSize += UniCmdWsysCfgTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdWsysCfg = (struct UNI_CMD_WSYS_CONFIG_T *)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_WSYS_CONFIG_MAX_NUM; i++) {
		if (pParamCtrl->WsysCfgTagValid[i]) {
			switch (i) {
			case UNI_CMD_WSYS_CONFIG_FW_LOG_CTRL:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_FW_LOG_CTRL_BASIC_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysFwLogCtrlBasic, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_WSYS_CONFIG_FW_DBG_CTRL:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_FW_DBG_CTRL_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysFwDbgCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_WSYS_CONFIG_FW_LOG_UI_CTRL:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_FW_LOG_UI_CTRL_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgFwLogUICtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_FW_BASIC_CONFIG_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgFwFwBasicConfig, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_HOSTREPORT_TX_LATENCY_CONFIG:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_CONFIG_HOSTREPORT_TX_LATENCY_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgHostReportTxLatency, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_WSYS_CONFIG_FW_LOG_BUFFER_CTRL:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_ONFIG_FW_LOG_BUFFER_CTRL_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgFwLogBufferCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_CERT_CFG:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_CONFIG_CERT_CFG_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgCertCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_FW_TIME_SYNC:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_CONFIG_FW_TIME_SYNC_HANDLE)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgFwTimeSync, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_WSYS_CONFIG_FW_DUP_MBSS_BCN:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_WSYS_CONFIG_FW_DUP_MBSS_BCN_T)(UniCmdWsysCfgTab[i].pfHandler))(pAd, &pParamCtrl->WsysCfgFw11vBcnCrtl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdWsysCfgTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdWsysCfgTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdWsysCfgTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			if (pParamCtrl->WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_LOG_CTRL]) {
				if (pParamCtrl->McuDest == HOST2CR4)
					SET_CMD_ATTR_MCU_DEST(attr, pParamCtrl->McuDest);
				else
					SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			} else {
				SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			}
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_WSYS_CONFIG);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			if (pParamCtrl->McuDest != 0) {
				if (pParamCtrl->McuDest < HOST2WO) {
					Ret = chip_cmd_tx(pAd, msg);
				} else {
					Ret = call_fw_cmd_notifieriers(WO_CMD_FW_LOG_CTRL, pAd, msg->net_pkt);
					AndesFreeCmdMsg(msg);
				}
			} else {
				Ret = chip_cmd_tx(pAd, msg);
			}

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdAccessRegBasic(
	struct _RTMP_ADAPTER *pAd,
	RTMP_REG_PAIR *RegPair,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_ACCESS_REG_BASIC_T pAccessReg = (P_UNI_CMD_ACCESS_REG_BASIC_T)pHandle;

	pAccessReg->u2Tag = UNI_CMD_ACCESS_REG_BASIC;
	pAccessReg->u2Length = sizeof(UNI_CMD_ACCESS_REG_BASIC_T);
#ifdef CFG_BIG_ENDIAN
	pAccessReg->u2Tag = cpu2le16(pAccessReg->u2Tag);
	pAccessReg->u2Length = cpu2le16(pAccessReg->u2Length);
#endif
	pAccessReg->u4Addr = cpu2le32(RegPair->Register);
	pAccessReg->u4Value = cpu2le32(RegPair->Value);

	return Ret;
}

static INT32 UniCmdAccessRfRegBasic(
	struct _RTMP_ADAPTER *pAd,
	MT_RF_REG_PAIR *RfRegPair,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_ACCESS_RF_REG_BASIC_T pAccessReg = (P_UNI_CMD_ACCESS_RF_REG_BASIC_T)pHandle;

	pAccessReg->u2Tag = UNI_CMD_ACCESS_RF_REG_BASIC;
	pAccessReg->u2Length = sizeof(UNI_CMD_ACCESS_RF_REG_BASIC_T);
#ifdef CFG_BIG_ENDIAN
	pAccessReg->u2Tag = cpu2le16(pAccessReg->u2Tag);
	pAccessReg->u2Length = cpu2le16(pAccessReg->u2Length);
#endif
	pAccessReg->u2WifiStream = RfRegPair->WiFiStream;
	pAccessReg->u2WifiStream = cpu2le16(pAccessReg->u2WifiStream);
	pAccessReg->u4Addr = cpu2le32(RfRegPair->Register);
	pAccessReg->u4Value = cpu2le32(RfRegPair->Value);

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdAccessRegTab[UNI_CMD_ACCESS_REG_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_ACCESS_REG_BASIC,
		.u4StructSize = sizeof(UNI_CMD_ACCESS_REG_BASIC_T),
		.pfHandler = UniCmdAccessRegBasic
	},
	{
		.u8CmdFeature = UNI_CMD_ACCESS_RF_REG_BASIC,
		.u4StructSize = sizeof(UNI_CMD_ACCESS_RF_REG_BASIC_T),
		.pfHandler = UniCmdAccessRfRegBasic
	},
};

INT32 UniCmdAccessReg(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_ACCESS_REG_PARAM_T pParamCtrl)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0, j = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_ACCESS_REG_T	pCmdAccessReg = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_ACCESS_REG_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_ACCESS_REG_MAX_NUM; i++) {
		if (pParamCtrl->AccessRegTagValid[i])
			u4CmdNeedMaxBufSize += (UniCmdAccessRegTab[i].u4StructSize * pParamCtrl->RegNum[i]);
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdAccessReg = (P_UNI_CMD_ACCESS_REG_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_ACCESS_REG_MAX_NUM; i++) {
		if (!pParamCtrl->AccessRegTagValid[i])
			continue;
		switch (i) {
		case UNI_CMD_ACCESS_REG_BASIC:
			if (UniCmdAccessRegTab[i].pfHandler != NULL) {
				for (j = 0 ; j < pParamCtrl->RegNum[UNI_CMD_ACCESS_REG_BASIC]; j++) {
					Ret = ((PFN_ACCESS_REG_BASIC_HANDLE)(UniCmdAccessRegTab[i].pfHandler))(pAd, &pParamCtrl->RegPair[j], pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdAccessRegTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
			}
			break;

		case UNI_CMD_ACCESS_RF_REG_BASIC:
			if (UniCmdAccessRegTab[i].pfHandler != NULL) {
				for (j = 0 ; j < pParamCtrl->RegNum[UNI_CMD_ACCESS_RF_REG_BASIC]; j++) {
					Ret = ((PFN_ACCESS_RF_REG_BASIC_HANDLE)(UniCmdAccessRegTab[i].pfHandler))(pAd, &pParamCtrl->RfRegPair[j], pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdAccessRegTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_SUCCESS;
			MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
				"The hanlder of tag (0x%llx) not support!\n", UniCmdAccessRegTab[i].u8CmdFeature);
			break;
		}

		if (Ret != NDIS_STATUS_SUCCESS)
			MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
				"The hanlder of tag (0x%llx) return fail!\n", UniCmdAccessRegTab[i].u8CmdFeature);
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}
			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_ACCESS_REG);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (pParamCtrl->bQueryMode) {
					if (pParamCtrl->AccessRegTagValid[UNI_CMD_ACCESS_REG_BASIC])
						SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pParamCtrl->RegPair);
					else if (pParamCtrl->AccessRegTagValid[UNI_CMD_ACCESS_RF_REG_BASIC])
						SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pParamCtrl->RfRegPair);
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventAccessRegHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				if (pParamCtrl->bQueryMode)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdMultipleMacRegAccessRead(struct _RTMP_ADAPTER *pAd, struct _RTMP_REG_PAIR *RegPair, UINT32 Num)
{
	UNI_CMD_ACCESS_REG_PARAM_T AccessRegParam;

	os_zero_mem(&AccessRegParam, sizeof(AccessRegParam));

	AccessRegParam.bQueryMode = TRUE;
	AccessRegParam.RegPair = RegPair;
	AccessRegParam.RegNum[UNI_CMD_ACCESS_REG_BASIC] = Num;
	AccessRegParam.AccessRegTagValid[UNI_CMD_ACCESS_REG_BASIC] = TRUE;

	return UniCmdAccessReg(pAd, &AccessRegParam);
}

INT32 UniCmdMultipleMacRegAccessWrite(struct _RTMP_ADAPTER *pAd, struct _RTMP_REG_PAIR *RegPair, UINT32 Num)
{
	UNI_CMD_ACCESS_REG_PARAM_T AccessRegParam;

	os_zero_mem(&AccessRegParam, sizeof(AccessRegParam));

	AccessRegParam.bQueryMode = FALSE;
	AccessRegParam.RegPair = RegPair;
	AccessRegParam.RegNum[UNI_CMD_ACCESS_REG_BASIC] = Num;
	AccessRegParam.AccessRegTagValid[UNI_CMD_ACCESS_REG_BASIC] = TRUE;

	return UniCmdAccessReg(pAd, &AccessRegParam);
}

INT32 UniCmdMultipleRfRegAccessRead(struct _RTMP_ADAPTER *pAd, struct _MT_RF_REG_PAIR *RegPair, UINT32 Num)
{
	UNI_CMD_ACCESS_REG_PARAM_T AccessRegParam;

	os_zero_mem(&AccessRegParam, sizeof(AccessRegParam));

	AccessRegParam.bQueryMode = TRUE;
	AccessRegParam.RfRegPair = RegPair;
	AccessRegParam.RegNum[UNI_CMD_ACCESS_RF_REG_BASIC] = Num;
	AccessRegParam.AccessRegTagValid[UNI_CMD_ACCESS_RF_REG_BASIC] = TRUE;

	return UniCmdAccessReg(pAd, &AccessRegParam);
}

INT32 UniCmdMultipleRfRegAccessWrite(struct _RTMP_ADAPTER *pAd, struct _MT_RF_REG_PAIR *RegPair, UINT32 Num)
{
	UNI_CMD_ACCESS_REG_PARAM_T AccessRegParam;

	os_zero_mem(&AccessRegParam, sizeof(AccessRegParam));

	AccessRegParam.bQueryMode = FALSE;
	AccessRegParam.RfRegPair = RegPair;
	AccessRegParam.RegNum[UNI_CMD_ACCESS_RF_REG_BASIC] = Num;
	AccessRegParam.AccessRegTagValid[UNI_CMD_ACCESS_RF_REG_BASIC] = TRUE;

	return UniCmdAccessReg(pAd, &AccessRegParam);
}

INT32 UniCmdRFRegAccessRead(struct _RTMP_ADAPTER *pAd, UINT32 RFIdx, UINT32 Offset, UINT32 *Value)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	MT_RF_REG_PAIR RfRegPair;
	os_zero_mem(&RfRegPair, sizeof(RfRegPair));
	RfRegPair.WiFiStream = (UINT8)RFIdx;
	RfRegPair.Register = Offset;
	Ret = UniCmdMultipleRfRegAccessRead(pAd, &RfRegPair, 1);
	if (Ret == NDIS_STATUS_SUCCESS)
		*Value = RfRegPair.Value;
	return Ret;
}

INT32 UniCmdRFRegAccessWrite(struct _RTMP_ADAPTER *pAd, UINT32 RFIdx, UINT32 Offset, UINT32 Value)
{
	MT_RF_REG_PAIR RegPair;

	os_zero_mem(&RegPair, sizeof(RegPair));

	RegPair.WiFiStream = (UINT8)RFIdx;
	RegPair.Register = Offset;
	RegPair.Value = Value;

	return UniCmdMultipleRfRegAccessWrite(pAd, &RegPair, 1);
}

INT32 UniCmdRestartDLReqNoRsp(struct _RTMP_ADAPTER *pAd)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_ID_POWER_CTRL_T UniCmdPowerCtrl;
	UNI_CMD_POWER_OFF_T UniCmdPowerOff;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdPowerCtrl);
	os_zero_mem(&UniCmdPowerCtrl, u4ComCmdSize);
	os_zero_mem(&UniCmdPowerOff, sizeof(UniCmdPowerOff));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdPowerOff);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9); /* MUST be only to N9 */
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_POWER_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerCtrl, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdPowerOff.u2Tag = UNI_CMD_POWER_OFF;
	UniCmdPowerOff.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdPowerOff.u2Tag = cpu2le16(UniCmdPowerOff.u2Tag);
	UniCmdPowerOff.u2Length = cpu2le16(UniCmdPowerOff.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdPowerOff.ucPowerMode = 1;
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerOff, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			 "(ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdClockSwitchDisable(RTMP_ADAPTER *pAd, UINT8 isDisable)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_ID_POWER_CTRL_T UniCmdPowerCtrl;
	struct UNI_CMD_POWER_CLOCK_SWITCH_DISABLE_T UniCmdPowerClockSwitchDisable;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
		 "isDisable = %d\n", isDisable);

	u4ComCmdSize = sizeof(UniCmdPowerCtrl);
	os_zero_mem(&UniCmdPowerCtrl, u4ComCmdSize);
	os_zero_mem(&UniCmdPowerClockSwitchDisable, sizeof(UniCmdPowerClockSwitchDisable));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdPowerClockSwitchDisable);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_POWER_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerCtrl, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdPowerClockSwitchDisable.u2Tag = UNI_CMD_POWER_CLOCK_SWITCH_DISABLE;
	UniCmdPowerClockSwitchDisable.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdPowerClockSwitchDisable.u2Tag = cpu2le16(UniCmdPowerClockSwitchDisable.u2Tag);
	UniCmdPowerClockSwitchDisable.u2Length = cpu2le16(UniCmdPowerClockSwitchDisable.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdPowerClockSwitchDisable.fgDisable = isDisable;
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerClockSwitchDisable, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			 "(ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdWifiHifCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 ucDbdcIdx,
	UINT8 ucHifCtrlId,
	VOID *pRsult)
{
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			 "(ret = %d)\n", ret);
	return ret;
}

#ifdef GREENAP_SUPPORT
INT32 UniCmdGreenAPOnOffCtrl(
	struct _RTMP_ADAPTER *pAd,
	MT_GREENAP_CTRL_T GreenAPCtrl)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_ID_POWER_CTRL_T UniCmdPowerCtrl;
	struct UNI_CMD_POWER_GREEN_AP_CTRL_T UniCmdPowerGreenApCtrl;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdPowerCtrl);
	os_zero_mem(&UniCmdPowerCtrl, u4ComCmdSize);
	os_zero_mem(&UniCmdPowerGreenApCtrl, sizeof(UniCmdPowerGreenApCtrl));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdPowerGreenApCtrl);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_POWER_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerCtrl, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdPowerGreenApCtrl.u2Tag = UNI_CMD_POWER_GREEN_AP_CTRL;
	UniCmdPowerGreenApCtrl.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdPowerGreenApCtrl.u2Tag = cpu2le16(UniCmdPowerGreenApCtrl.u2Tag);
	UniCmdPowerGreenApCtrl.u2Length = cpu2le16(UniCmdPowerGreenApCtrl.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdPowerGreenApCtrl.ucBandIdx = GreenAPCtrl.ucDbdcIdx;
	UniCmdPowerGreenApCtrl.fgGreenApOn = GreenAPCtrl.ucGreenAPOn;
	AndesAppendCmdMsg(msg, (char *)&UniCmdPowerGreenApCtrl, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			 "(ret = %d)\n", ret);
	return ret;
}
#endif /* GREENAP_SUPPORT */

INT32 UniCmdCfgInfoUpdate(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	ENUM_CFG_FEATURE eFeature,
	VOID *param)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT8 i, ucAction = 0;
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;
	P_UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T pUniCmdBandCfgAGGAcLimit = NULL;
	P_EXT_CMD_CFG_SET_ACK_CTS_T prExtCmdAckCTSCfg = NULL;

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = HcGetBandByWdev(wdev);

	for (i = 0; i < EXT_CMD_CFG_MAX_NUM; i++) {
		if (eFeature & (1 << i)) {
			switch (i) {
			case EXT_CMD_CFGINFO_HOSTREPORT_TX_LATENCY:
				ucAction = *((UINT8 *)param);
				WsysCfgParam.WsysCfgHostReportTxLatency.ucActive = ucAction;
				WsysCfgParam.WsysCfgTagValid[UNI_CMD_HOSTREPORT_TX_LATENCY_CONFIG] = TRUE;
				break;
			case EXT_CMD_CFGINFO_CHECKSUM:
				/* TODO */
				break;
			case EXT_CMD_CFGINFO_RX_FILTER_DROP_CTRL_FRAME:
				ucAction = *((UINT8 *)param);
				BandCfgParam.BandCfgDropCtrlFrame.ucDropRts = (ucAction & CFGINFO_DROP_CTS_CTRL_FRAME) ? 1 : 0;
				BandCfgParam.BandCfgDropCtrlFrame.ucDropCts = (ucAction & CFGINFO_DROP_CTS_CTRL_FRAME) ? 1 : 0;
				BandCfgParam.BandCfgDropCtrlFrame.ucDropUnwantedCtrl = (ucAction & CFGINFO_DROP_UNWANTED_CTRL_FRAME) ? 1 : 0;
				BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_DROP_CTRL_FRAME] = TRUE;
				break;
			case EXT_CMD_CFGINFO_AGG_AC_LIMIT:
				pUniCmdBandCfgAGGAcLimit = (P_UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT_T)param;
				BandCfgParam.BandCfgAGGAcLimit.ucWmmIdx = pUniCmdBandCfgAGGAcLimit->ucWmmIdx;
				BandCfgParam.BandCfgAGGAcLimit.ucAc = pUniCmdBandCfgAGGAcLimit->ucAc;
				BandCfgParam.BandCfgAGGAcLimit.ucAggLimit = pUniCmdBandCfgAGGAcLimit->ucAggLimit;
				BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_AGG_AC_LIMIT] = TRUE;
				break;
			case EXT_CMD_CFGINFO_CERT_CFG:
				ucAction = *((UINT8 *)param);
				WsysCfgParam.WsysCfgCertCtrl.ucActive = ucAction;
				WsysCfgParam.WsysCfgTagValid[UNI_CMD_CERT_CFG] = TRUE;
				break;
			case EXT_CMD_CFGINFO_ACK_CTS:
				prExtCmdAckCTSCfg = (P_EXT_CMD_CFG_SET_ACK_CTS_T)param;
				BandCfgParam.BandCfgACKCTSTimeout.u1Type = prExtCmdAckCTSCfg->u1Type;
				BandCfgParam.BandCfgACKCTSTimeout.u4TimeoutValue = prExtCmdAckCTSCfg->u4TimeoutValue;
				BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_ACK_CTS_TIMEOUT] = TRUE;
				break;
			case EXT_CMD_CFGINFO_11V_BCN_DUP_CFG:
				ucAction = *((UINT8 *)param);
				WsysCfgParam.WsysCfgFw11vBcnCrtl.fgEnable = (BOOLEAN)ucAction;
				WsysCfgParam.WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_DUP_MBSS_BCN] = TRUE;
				break;
			}
		}
	}

	for (i = 0; i < UNI_CMD_WSYS_CONFIG_MAX_NUM; i++) {
		if (WsysCfgParam.WsysCfgTagValid[i]) {
			Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);
			break;
		}
	}
	if (Ret != NDIS_STATUS_SUCCESS)
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
			"%d => UniCmdWsysConfig return fail!\n", i);

	for (i = 0; i < UNI_CMD_BAND_CONFIG_MAX_NUM; i++) {
		if (BandCfgParam.BandCfgTagValid[i]) {
			Ret = UniCmdBandConfig(pAd, &BandCfgParam);
			break;
		}
	}
	if (Ret != NDIS_STATUS_SUCCESS)
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
			"%d => UniCmdBandConfig return fail!\n", i);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef CONFIG_3_WIRE_SUPPORT
INT32 UniCmd3wireFunctionSet(
	struct _RTMP_ADAPTER *pAd,
	UINT8 threeWire_function_enable)
{
	struct cmd_msg *msg;
	INT32 ret;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_3WIRE_EXT_T UniCmd3WireExt;
	struct UNI_CMD_3WIRE_EXT_EN_T *prUniCmd3WireExtEn = NULL;
	UINT32 u4CmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	u4CmdSize = sizeof(UniCmd3WireExt);
	os_zero_mem(&UniCmd3WireExt, u4CmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4CmdSize + sizeof(struct UNI_CMD_3WIRE_EXT_EN_T);

	/* Step 2: Allocate memory space */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4CmdSize;

	/* Step 3: Filled in parameters of P_UNI_CMD_3WIRE_EXT_EN_T */
	prUniCmd3WireExtEn = (struct UNI_CMD_3WIRE_EXT_EN_T *) pNextHeadBuf;

	prUniCmd3WireExtEn->u2Tag = UNI_CMD_3WIRE_EXT_EN;
	prUniCmd3WireExtEn->u2Length = sizeof(struct UNI_CMD_3WIRE_EXT_EN_T);
#ifdef CFG_BIG_ENDIAN
	prUniCmd3WireExtEn->u2Tag = cpu2le16(prUniCmd3WireExtEn->u2Tag);
	prUniCmd3WireExtEn->u2Length = cpu2le16(prUniCmd3WireExtEn->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prUniCmd3WireExtEn->uc3WireExtEn = threeWire_function_enable;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_3WIRE_EXT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
		"(ret = %d)\n", ret);
	return ret;
}
#endif

INT32 MtUniCmdFwLog2Host(struct _RTMP_ADAPTER *pAd, UINT8 McuDest, UINT32 FWLog2HostCtrl)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	char *Dest[] = {
		"HOST2N9(WM)",
		"CR42N9",
		"HOST2CR4(WA)",
		"HOST2CR4N9",
		"HOST2WO",
	};
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;

	MTWF_PRINT("%s: McuDest(%d): %s\n", __func__, McuDest, Dest[McuDest]);

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	WsysCfgParam.McuDest = McuDest;
	WsysCfgParam.WsysFwLogCtrlBasic.ucFwLog2HostCtrl = (UINT8)FWLog2HostCtrl;
	WsysCfgParam.WsysFwLogCtrlBasic.ucFwLog2HostInterval = 0;
	WsysCfgParam.WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_LOG_CTRL] = TRUE;

	Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);

	MTWF_PRINT("%s: %s (ret = %d)\n", __func__, Dest[McuDest], Ret);

	return Ret;
}

INT32 MtUniCmdFwDbgCtrl(struct _RTMP_ADAPTER *pAd, UINT32 DbgClass, UINT32 ModuleIdx)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	WsysCfgParam.WsysFwDbgCtrl.u4DbgModuleIdx = ModuleIdx;
	WsysCfgParam.WsysFwDbgCtrl.ucDbgClass = (UINT8)DbgClass;
	WsysCfgParam.WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_DBG_CTRL] = TRUE;

	Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);

	MTWF_PRINT("%s: ret = %d\n", __func__, Ret);

	return Ret;
}

INT32 MtUniCmdFwBasicConfig(struct _RTMP_ADAPTER *pAd)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	WsysCfgParam.WsysCfgFwFwBasicConfig.u2TxChecksum = 0x0011;
	WsysCfgParam.WsysCfgFwFwBasicConfig.u2RxChecksum = 0x000f;
	WsysCfgParam.WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_BASIC_CONFIG] = TRUE;

	Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);

	MTWF_DBG(NULL, DBG_CAT_AP, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(Ret = %d)\n", Ret);

	return Ret;
}

INT32 MtUniCmdFwTimeSync(struct _RTMP_ADAPTER *pAd, UINT32 second, UINT32 usecond)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	WsysCfgParam.WsysCfgFwTimeSync.u4Second = second;
	WsysCfgParam.WsysCfgFwTimeSync.u4Usecond = usecond;
	WsysCfgParam.WsysCfgTagValid[UNI_CMD_FW_TIME_SYNC] = TRUE;

	Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", Ret);

	return Ret;
}

INT32 MtUniCmdFwMbssBcnDup(struct _RTMP_ADAPTER *pAd, BOOLEAN bWMDup)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_WSYS_CFG_PARAM_T WsysCfgParam;

	os_zero_mem(&WsysCfgParam, sizeof(WsysCfgParam));
	WsysCfgParam.WsysCfgFw11vBcnCrtl.fgEnable = bWMDup;
	WsysCfgParam.WsysCfgTagValid[UNI_CMD_WSYS_CONFIG_FW_DUP_MBSS_BCN] = TRUE;

	Ret = UniCmdWsysConfig(pAd, &WsysCfgParam);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_NOTICE,
			 "(Ret = %d, bWMDup=%d)\n", Ret, bWMDup);

	return Ret;
}


#ifdef AIR_MONITOR
INT32 MtUniCmdSmeshConfigSet(struct _RTMP_ADAPTER *pAd, UCHAR *pdata, P_UNI_CMD_SMESH_PARAM_T prSmeshResult)
{
	struct cmd_msg			*msg = NULL;
	INT32					Ret = NDIS_STATUS_SUCCESS;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4ComCmdSize = 0;
	UNI_CMD_SMESH_T			CmdSmesh = {0};
	UNI_CMD_SMESH_PARAM_T	CmdSmeshParam = {0};
	struct _CMD_ATTRIBUTE	attr = {0};
	EXT_CMD_SMESH_T 		*pCfgSmesh = (EXT_CMD_SMESH_T *)pdata;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdSmesh);
	os_zero_mem(&CmdSmesh, u4ComCmdSize);
	os_zero_mem(&CmdSmeshParam, sizeof(CmdSmeshParam));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdSmeshParam);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CFG_SMESH);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	if (pCfgSmesh->ucAccessMode) {
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	} else {
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prSmeshResult);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniEventSmeshInfoRsp);
	}
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdSmesh.ucBand = pCfgSmesh->ucBand;
	AndesAppendCmdMsg(msg, (char *)&CmdSmesh, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	CmdSmeshParam.u2Tag = UNI_CMD_SMESH_PARAM;
	CmdSmeshParam.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	CmdSmeshParam.u2Tag = cpu2le16(CmdSmeshParam.u2Tag);
	CmdSmeshParam.u2Length = cpu2le16(CmdSmeshParam.u2Length);
#endif /* CFG_BIG_ENDIAN */
	CmdSmeshParam.ucEntryEnable = pCfgSmesh->ucSmeshEn;
	CmdSmeshParam.fgSmeshRxA2 = pCfgSmesh->fgSmeshRxA2;
	CmdSmeshParam.fgSmeshRxA1 = pCfgSmesh->fgSmeshRxA1;
	CmdSmeshParam.fgSmeshRxData = pCfgSmesh->fgSmeshRxData;
	CmdSmeshParam.fgSmeshRxMgnt = pCfgSmesh->fgSmeshRxMgnt;
	CmdSmeshParam.fgSmeshRxCtrl = pCfgSmesh->fgSmeshRxCtrl;
	AndesAppendCmdMsg(msg, (char *)&CmdSmeshParam, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			"ucEntryEnable(%d), fgSmeshRxA2(%d), fgSmeshRxA1(%d), fgSmeshRxData(%d), fgSmeshRxMgnt(%d), fgSmeshRxCtrl(%d)\n",
			  CmdSmeshParam.ucEntryEnable, CmdSmeshParam.fgSmeshRxA2, CmdSmeshParam.fgSmeshRxA1, CmdSmeshParam.fgSmeshRxData,
			  CmdSmeshParam.fgSmeshRxMgnt, CmdSmeshParam.fgSmeshRxCtrl);

	Ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", Ret);

	return Ret;
}
#endif /* AIR_MONITOR */

static INT32 UniCmdRxHdrTranEnable(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_RX_HDR_TRAN_ENABLE_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_RX_HDR_TRAN_ENABLE_T pRxHdrTranEnable = (P_UNI_CMD_RX_HDR_TRAN_ENABLE_T)pHandle;

	pRxHdrTranEnable->u2Tag = UNI_CMD_RX_HDR_TRAN_ENABLE;
	pRxHdrTranEnable->u2Length = sizeof(UNI_CMD_RX_HDR_TRAN_ENABLE_T);
#ifdef CFG_BIG_ENDIAN
	pRxHdrTranEnable->u2Tag = cpu2le16(pRxHdrTranEnable->u2Tag);
	pRxHdrTranEnable->u2Length = cpu2le16(pRxHdrTranEnable->u2Length);
#endif
	pRxHdrTranEnable->fgEnable = pParam->fgEnable;
	pRxHdrTranEnable->fgCheckBssid = pParam->fgCheckBssid;
	pRxHdrTranEnable->ucTranslationMode = pParam->ucTranslationMode;

	return Ret;
}

static INT32 UniCmdRxHdrTranVlanConfig(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_RX_HDR_TRAN_VLAN_T pParam,
	VOID *pHandle)

{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_RX_HDR_TRAN_VLAN_T pRxHdrTranVlan = (P_UNI_CMD_RX_HDR_TRAN_VLAN_T)pHandle;

	pRxHdrTranVlan->u2Tag = UNI_CMD_RX_HDR_TRAN_VLAN_CONFIG;
	pRxHdrTranVlan->u2Length = sizeof(UNI_CMD_RX_HDR_TRAN_VLAN_T);
#ifdef CFG_BIG_ENDIAN
	pRxHdrTranVlan->u2Tag = cpu2le16(pRxHdrTranVlan->u2Tag);
	pRxHdrTranVlan->u2Length = cpu2le16(pRxHdrTranVlan->u2Length);
#endif
	pRxHdrTranVlan->fgInsertVlan = pParam->fgInsertVlan;
	pRxHdrTranVlan->fgRemoveVlan = pParam->fgRemoveVlan;
	pRxHdrTranVlan->fgUseQosTid = pParam->fgUseQosTid;

	return Ret;
}

static INT32 UniCmdRxHdrTranBlackListConfig(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_RX_HDR_TRAN_BLACKLIST_T pParam,
	VOID *pHandle)

{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_RX_HDR_TRAN_BLACKLIST_T pRxHdrTranBlackList = (P_UNI_CMD_RX_HDR_TRAN_BLACKLIST_T)pHandle;

	pRxHdrTranBlackList->u2Tag = UNI_CMD_RX_HDR_TRAN_BLACKLIST_CONFIG;
	pRxHdrTranBlackList->u2Length = sizeof(UNI_CMD_RX_HDR_TRAN_BLACKLIST_T);
#ifdef CFG_BIG_ENDIAN
	pRxHdrTranBlackList->u2Tag = cpu2le16(pRxHdrTranBlackList->u2Tag);
	pRxHdrTranBlackList->u2Length = cpu2le16(pRxHdrTranBlackList->u2Length);
#endif
	pRxHdrTranBlackList->fgEnable = pParam->fgEnable;
	pRxHdrTranBlackList->ucBlackListIdx = pParam->ucBlackListIdx;
	pRxHdrTranBlackList->u2EtherType = cpu2le16(pParam->u2EtherType);

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdRxHdrTransTab[UNI_CMD_RX_HDR_TRAN_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_RX_HDR_TRAN_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_RX_HDR_TRAN_ENABLE_T),
		.pfHandler = UniCmdRxHdrTranEnable
	},
	{
		.u8CmdFeature = UNI_CMD_RX_HDR_TRAN_VLAN_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_RX_HDR_TRAN_VLAN_T),
		.pfHandler = UniCmdRxHdrTranVlanConfig
	},
	{
		.u8CmdFeature = UNI_CMD_RX_HDR_TRAN_BLACKLIST_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_RX_HDR_TRAN_BLACKLIST_T),
		.pfHandler = UniCmdRxHdrTranBlackListConfig
	},
};

INT32 UniCmdRxHdrTrans(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_RX_HDR_TRAN_PARAM_T pParamCtrl)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_RX_HDR_TRAN_T	pCmdRxHdrTran = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_RX, CATRX_RXINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_RX_HDR_TRAN_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_RX_HDR_TRAN_MAX_NUM; i++) {
		if (pParamCtrl->RxHdrTranValid[i])
			u4CmdNeedMaxBufSize += UniCmdRxHdrTransTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdRxHdrTran = (P_UNI_CMD_RX_HDR_TRAN_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_RX_HDR_TRAN_MAX_NUM; i++) {
		if (pParamCtrl->RxHdrTranValid[i]) {
			switch (i) {
			case UNI_CMD_RX_HDR_TRAN_ENABLE:
				if (UniCmdRxHdrTransTab[i].pfHandler != NULL) {
					Ret = ((PFN_RX_HDR_TRAN_ENABLE_HANDLE)(UniCmdRxHdrTransTab[i].pfHandler))(pAd, &pParamCtrl->RxHdrTranEnable, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdRxHdrTransTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_RX_HDR_TRAN_VLAN_CONFIG:
				if (UniCmdRxHdrTransTab[i].pfHandler != NULL) {
					Ret = ((PFN_RX_HDR_TRAN_VLAN_HANDLE)(UniCmdRxHdrTransTab[i].pfHandler))(pAd, &pParamCtrl->RxHdrTranVlan, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdRxHdrTransTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_RX_HDR_TRAN_BLACKLIST_CONFIG:
				if (UniCmdRxHdrTransTab[i].pfHandler != NULL) {
					Ret = ((PFN_RX_HDR_TRAN_BLACKLIST_HANDLE)(UniCmdRxHdrTransTab[i].pfHandler))(pAd, &pParamCtrl->RxHdrTranBlackList, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdRxHdrTransTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_RX, CATRX_RXINFO, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdRxHdrTransTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_RX, CATRX_RXINFO, DBG_LVL_DEBUG,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdRxHdrTransTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_RX, CATRX_RXINFO, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RX_HDR_TRAN);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_RX, CATRX_RXINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdSERSetQuery(
	struct _RTMP_ADAPTER *pAd,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SER_QUERY_T pSerSetQuery = (P_UNI_CMD_SER_QUERY_T)pHandle;

	pSerSetQuery->u2Tag = UNI_CMD_SER_QUERY;
	pSerSetQuery->u2Length = sizeof(UNI_CMD_SER_QUERY_T);
#ifdef CFG_BIG_ENDIAN
	pSerSetQuery->u2Tag = cpu2le16(pSerSetQuery->u2Tag);
	pSerSetQuery->u2Length = cpu2le16(pSerSetQuery->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return Ret;
}

static INT32 UniCmdSERSetEnable(
	struct _RTMP_ADAPTER *pAd,
	BOOLEAN fgEnable,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SER_ENABLE_T pSerSetEnable = (P_UNI_CMD_SER_ENABLE_T)pHandle;

	pSerSetEnable->u2Tag = UNI_CMD_SER_ENABLE;
	pSerSetEnable->u2Length = sizeof(UNI_CMD_SER_ENABLE_T);
#ifdef CFG_BIG_ENDIAN
	pSerSetEnable->u2Tag = cpu2le16(pSerSetEnable->u2Tag);
	pSerSetEnable->u2Length = cpu2le16(pSerSetEnable->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSerSetEnable->fgEnable = fgEnable;

	return Ret;
}

static INT32 UniCmdSERSetEnableMask(
	struct _RTMP_ADAPTER *pAd,
	UINT32 u4EnableMask,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SER_SET_T pSerSetEnableMask = (P_UNI_CMD_SER_SET_T)pHandle;

	pSerSetEnableMask->u2Tag = UNI_CMD_SER_SET;
	pSerSetEnableMask->u2Length = sizeof(UNI_CMD_SER_SET_T);
#ifdef CFG_BIG_ENDIAN
	pSerSetEnableMask->u2Tag = cpu2le16(pSerSetEnableMask->u2Tag);
	pSerSetEnableMask->u2Length = cpu2le16(pSerSetEnableMask->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSerSetEnableMask->u4EnableMask = cpu2le32(u4EnableMask);

	return Ret;
}

static INT32 UniCmdSERSetTrigger(
	struct _RTMP_ADAPTER *pAd,
	UINT8 ucTriggerMethod,
	UINT8 ucDbdcIdx,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SER_TRIGGER_T pSerSetTrigger = (P_UNI_CMD_SER_TRIGGER_T)pHandle;

	pSerSetTrigger->u2Tag = UNI_CMD_SER_TRIGGER;
	pSerSetTrigger->u2Length = sizeof(UNI_CMD_SER_TRIGGER_T);
#ifdef CFG_BIG_ENDIAN
	pSerSetTrigger->u2Tag = cpu2le16(pSerSetTrigger->u2Tag);
	pSerSetTrigger->u2Length = cpu2le16(pSerSetTrigger->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSerSetTrigger->ucTriggerMethod = ucTriggerMethod;
	pSerSetTrigger->ucDbdcIdx = ucDbdcIdx;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdSerTab[UNI_CMD_SER_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_SER_ACTION_SET_QUERY,
		.u4StructSize = sizeof(UNI_CMD_SER_QUERY_T),
		.pfHandler = UniCmdSERSetQuery
	},
	{
		.u8CmdFeature = UNI_SER_ACTION_SET_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_SER_ENABLE_T),
		.pfHandler = UniCmdSERSetEnable
	},
	{
		.u8CmdFeature = UNI_SER_ACTION_SET_ENABLE_MASK,
		.u4StructSize = sizeof(UNI_CMD_SER_SET_T),
		.pfHandler = UniCmdSERSetEnableMask
	},
	{
		.u8CmdFeature = UNI_SER_ACTION_SET_TRIGGER,
		.u4StructSize = sizeof(UNI_CMD_SER_TRIGGER_T),
		.pfHandler = UniCmdSERSetTrigger
	},
};

INT32 UniCmdSER(struct _RTMP_ADAPTER *pAd, UINT32 u4Action, UINT32 u4SetValue, UINT8 ucDbdcIdx)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	UINT64					u8CmdFeature = (UINT64)u4Action;
	P_UNI_CMD_SER_T			pCmdSer = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);
	BOOLEAN					bQueryOnly = FALSE;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_SER, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_SER_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_SER_MAX_NUM; i++) {
		if (u8CmdFeature & UniCmdSerTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdSerTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdSer = (P_UNI_CMD_SER_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_SER_MAX_NUM; i++) {
		switch (u8CmdFeature & UniCmdSerTab[i].u8CmdFeature) {
		case UNI_SER_ACTION_SET_QUERY:
			if (UniCmdSerTab[i].pfHandler != NULL) {
				Ret = ((PFN_SER_QUERY_HANDLE)(UniCmdSerTab[i].pfHandler))(pAd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdSerTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case UNI_SER_ACTION_SET_ENABLE:
			if (UniCmdSerTab[i].pfHandler != NULL) {
				BOOLEAN bEnable = (u4SetValue == SER_SET_ENABLE)?TRUE:FALSE;
				Ret = ((PFN_SER_ENABLE_HANDLE)(UniCmdSerTab[i].pfHandler))(pAd, bEnable, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdSerTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case UNI_SER_ACTION_SET_ENABLE_MASK:
			if (UniCmdSerTab[i].pfHandler != NULL) {
				Ret = ((PFN_SER_ENABLE_MASK_HANDLE)(UniCmdSerTab[i].pfHandler))(pAd, u4SetValue, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdSerTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		case UNI_SER_ACTION_SET_TRIGGER:
			if (UniCmdSerTab[i].pfHandler != NULL) {
				Ret = ((PFN_SER_TRIGGER_HANDLE)(UniCmdSerTab[i].pfHandler))(pAd, (UINT8)u4SetValue, ucDbdcIdx, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdSerTab[i].u4StructSize;
					u2TLVNumber++;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_SUCCESS;
			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_SER, DBG_LVL_INFO,
				"The hanlder of tag (0x%08x) not support!\n", u4Action);
			break;
		}

		if (Ret != NDIS_STATUS_SUCCESS)
			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_SER, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdSerTab[i].u8CmdFeature);
	}

	if ((u2TLVNumber == 1) && (u4Action & UNI_SER_ACTION_SET_QUERY))
		bQueryOnly = TRUE;

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_SER, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SER);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (bQueryOnly) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventSERHandler);
				} else {
					if ((u4Action & UNI_SER_ACTION_SET_TRIGGER) &&
						((u4SetValue == SER_SET_L1_RECOVER) || (u4SetValue == SER_SET_ETH_HANDLER_RECOVER))) {
						SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
						SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
						SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					} else {
						SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
						SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
						SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
					}
				}
			} else {
				if (bQueryOnly)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_SER, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef DOT11_HE_AX
#ifdef WIFI_TWT_SUPPORT
INT32 UniCmdTwtAgrtUpdate(
	struct _RTMP_ADAPTER *pAd,
	struct MT_TWT_AGRT_PARA_T *AgrtPara)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TWT_T UniCmdTWT;
	UNI_CMD_TWT_ARGT_UPDATE_T UniCmdTwtArgtPara;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 i;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdTWT);
	os_zero_mem(&UniCmdTWT, u4ComCmdSize);
	os_zero_mem(&UniCmdTwtArgtPara, sizeof(UniCmdTwtArgtPara));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdTwtArgtPara);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TWT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);

	/* Step 3: Fill and append common parameters here */
	UniCmdTWT.ucBssInfoIdx = AgrtPara->bss_idx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdTWT, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdTwtArgtPara.u2Tag = UNI_CMD_TWT_AGRT_UPDATE;
	UniCmdTwtArgtPara.u2Length = sizeof(UniCmdTwtArgtPara);
#ifdef CFG_BIG_ENDIAN
	UniCmdTwtArgtPara.u2Tag = cpu2le16(UniCmdTwtArgtPara.u2Tag);
	UniCmdTwtArgtPara.u2Length = cpu2le16(UniCmdTwtArgtPara.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdTwtArgtPara.ucAgrtTblIdx = AgrtPara->agrt_tbl_idx;
	UniCmdTwtArgtPara.ucAgrtCtrlFlag = AgrtPara->agrt_ctrl_flag;
	UniCmdTwtArgtPara.ucOwnMacId = AgrtPara->own_mac_idx;
	UniCmdTwtArgtPara.ucFlowId = AgrtPara->flow_id;
	UniCmdTwtArgtPara.u2PeerIdGrpId = cpu2le16(AgrtPara->peer_id_grp_id);
	UniCmdTwtArgtPara.ucAgrtSpDuration = AgrtPara->agrt_sp_duration;
	UniCmdTwtArgtPara.ucBssIndex = AgrtPara->bss_idx;
	UniCmdTwtArgtPara.u4AgrtSpStartTsf_low = cpu2le32(AgrtPara->agrt_sp_start_tsf_low);
	UniCmdTwtArgtPara.u4AgrtSpStartTsf_high = cpu2le32(AgrtPara->agrt_sp_start_tsf_high);
	UniCmdTwtArgtPara.u2AgrtSpWakeIntvlMantissa = cpu2le16(AgrtPara->agrt_sp_wake_intvl_mantissa);
	UniCmdTwtArgtPara.ucAgrtSpWakeIntvlExponent = AgrtPara->agrt_sp_wake_intvl_exponent;
	UniCmdTwtArgtPara.fgIsRoleAp = AgrtPara->is_role_ap;
	UniCmdTwtArgtPara.ucAgrtParaBitmap = AgrtPara->agrt_para_bitmap;
	UniCmdTwtArgtPara.ucPersistence = AgrtPara->persistence;
	UniCmdTwtArgtPara.u2NtbttBeforeReject = cpu2le16(AgrtPara->ntbtt_before_reject);
	UniCmdTwtArgtPara.ucGrpMemberCnt = AgrtPara->grp_member_cnt;
	UniCmdTwtArgtPara.ucAgrtTblIdxH = AgrtPara->agrt_tbl_idx_h;
#ifdef DOT11_EHT_BE
	UniCmdTwtArgtPara.ucTidDlBitmap = AgrtPara->tid_dl_bitmap;
	UniCmdTwtArgtPara.ucTidUlBitmap = AgrtPara->tid_ul_bitmap;
#else
	UniCmdTwtArgtPara.u2Reserved_d = cpu2le16(AgrtPara->reserved_d);
#endif /* DOT11_EHT_BE */
	for (i = 0; i < TWT_HW_BTWT_MAX_MEMBER_CNT; i++)
		UniCmdTwtArgtPara.au2StaList[i] = cpu2le16(AgrtPara->sta_list[i]);

	AndesAppendCmdMsg(msg, (char *)&UniCmdTwtArgtPara, sizeof(UniCmdTwtArgtPara));

	ret = chip_cmd_tx(pAd, msg);
	return ret;

error:
	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_ERROR,
			"ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdTwtAgrtMgmt(
	struct _RTMP_ADAPTER *pAd,
	struct MT_TWT_AGRT_PARA_T *AgrtPara,
	struct MT_TWT_AGRT_MGMT_T *AgrtMgmt)
{
#ifdef TWT_AGRT_ALLOC_SIM
	static UINT16 hw_res;
	UINT8 i = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
		"ctrl_flag=%d\n", AgrtPara->agrt_ctrl_flag);

	if (AgrtPara->agrt_ctrl_flag == TWT_AGRT_CTRL_AGRT_ALLOC) {
		for (i = 0; i < TWT_HW_AGRT_MAX_NUM; i++) {
			if ((hw_res & (1 << i)) == 0) {
				hw_res |= (1 << i);
				break;
			}
		}

		if (i == TWT_HW_AGRT_MAX_NUM) {
			AgrtMgmt->sts = 1;
			AgrtMgmt->wcid = AgrtPara->peer_id_grp_id;
			AgrtMgmt->res_id = 0xffff;
			ret = NDIS_STATUS_FAILURE;
		} else {
			AgrtMgmt->sts = 0;
			AgrtMgmt->wcid = AgrtPara->peer_id_grp_id;
			AgrtMgmt->res_id = i;
			ret = NDIS_STATUS_SUCCESS;
		}

		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
			"twt_agrt_alloc:peer_grp_id=0x%x,res_id=%d\n",
			AgrtPara->peer_id_grp_id, AgrtMgmt->res_id);
	} else if (AgrtPara->agrt_ctrl_flag == TWT_AGRT_CTRL_AGRT_FREE) {
		if (AgrtPara->agrt_tbl_idx < TWT_HW_AGRT_MAX_NUM)
			hw_res &= ~(1 << AgrtPara->agrt_tbl_idx);
		ret = NDIS_STATUS_SUCCESS;
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
			"twt_agrt_free:peer_grp_id=0x%x,res_id=%d\n",
			AgrtPara->peer_id_grp_id, AgrtPara->agrt_tbl_idx);
	} else
		ret = NDIS_STATUS_FAILURE;

	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
		"ret=%d,hw_res=0x%x,i=%d\n", ret, hw_res, i);

	return ret;
#else
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TWT_T UniCmdTWT;
	UNI_CMD_TWT_ARGT_UPDATE_T UniCmdTwtArgtPara;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 i;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdTWT);
	os_zero_mem(&UniCmdTWT, u4ComCmdSize);
	os_zero_mem(&UniCmdTwtArgtPara, sizeof(UniCmdTwtArgtPara));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdTwtArgtPara);

	/* Step 2: Allocate memory space */
	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TWT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, AgrtMgmt);
	if (AgrtPara->agrt_ctrl_flag == TWT_AGRT_CTRL_AGRT_ALLOC) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTwtAgrtMgmtRsp);
	} else if (AgrtPara->agrt_ctrl_flag == TWT_AGRT_CTRL_AGRT_FREE) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	} else {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	AndesInitCmdMsg(msg, attr);

	/* Step 3: Fill and append common parameters here */
	UniCmdTWT.ucBssInfoIdx = AgrtPara->bss_idx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdTWT, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdTwtArgtPara.u2Tag = UNI_CMD_TWT_AGRT_UPDATE;
	UniCmdTwtArgtPara.u2Length = sizeof(UniCmdTwtArgtPara);
#ifdef CFG_BIG_ENDIAN
	UniCmdTwtArgtPara.u2Tag = cpu2le16(UniCmdTwtArgtPara.u2Tag);
	UniCmdTwtArgtPara.u2Length = cpu2le16(UniCmdTwtArgtPara.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdTwtArgtPara.ucAgrtTblIdx = AgrtPara->agrt_tbl_idx;
	UniCmdTwtArgtPara.ucAgrtCtrlFlag = AgrtPara->agrt_ctrl_flag;
	UniCmdTwtArgtPara.ucOwnMacId = AgrtPara->own_mac_idx;
	UniCmdTwtArgtPara.ucFlowId = AgrtPara->flow_id;
	UniCmdTwtArgtPara.u2PeerIdGrpId = cpu2le16(AgrtPara->peer_id_grp_id);
	UniCmdTwtArgtPara.ucAgrtSpDuration = AgrtPara->agrt_sp_duration;
	UniCmdTwtArgtPara.ucBssIndex = AgrtPara->bss_idx;
	UniCmdTwtArgtPara.u4AgrtSpStartTsf_low = cpu2le32(AgrtPara->agrt_sp_start_tsf_low);
	UniCmdTwtArgtPara.u4AgrtSpStartTsf_high = cpu2le32(AgrtPara->agrt_sp_start_tsf_high);
	UniCmdTwtArgtPara.u2AgrtSpWakeIntvlMantissa = cpu2le16(AgrtPara->agrt_sp_wake_intvl_mantissa);
	UniCmdTwtArgtPara.ucAgrtSpWakeIntvlExponent = AgrtPara->agrt_sp_wake_intvl_exponent;
	UniCmdTwtArgtPara.fgIsRoleAp = AgrtPara->is_role_ap;
	UniCmdTwtArgtPara.ucAgrtParaBitmap = AgrtPara->agrt_para_bitmap;
	UniCmdTwtArgtPara.ucPersistence = AgrtPara->persistence;
	UniCmdTwtArgtPara.u2NtbttBeforeReject = cpu2le16(AgrtPara->ntbtt_before_reject);
	UniCmdTwtArgtPara.ucGrpMemberCnt = AgrtPara->grp_member_cnt;
	UniCmdTwtArgtPara.ucAgrtTblIdxH = AgrtPara->agrt_tbl_idx_h;
#ifdef DOT11_EHT_BE
	UniCmdTwtArgtPara.ucTidDlBitmap = AgrtPara->tid_dl_bitmap;
	UniCmdTwtArgtPara.ucTidUlBitmap = AgrtPara->tid_ul_bitmap;
#else
	UniCmdTwtArgtPara.u2Reserved_d = cpu2le16(AgrtPara->reserved_d);
#endif /* DOT11_EHT_BE */
	for (i = 0; i < TWT_HW_BTWT_MAX_MEMBER_CNT; i++)
		UniCmdTwtArgtPara.au2StaList[i] = cpu2le16(AgrtPara->sta_list[i]);

	AndesAppendCmdMsg(msg, (char *)&UniCmdTwtArgtPara, sizeof(UniCmdTwtArgtPara));

	ret = chip_cmd_tx(pAd, msg);
	return ret;

error:
	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_ERROR,
			"ret = %d)\n", ret);
	return ret;
#endif
}

INT32 UniCmdTwtMgmtFrameOffload(
	struct _RTMP_ADAPTER *pAd,
	struct MT_MGMT_FRAME_OFFLOAD_T *OffloadPara)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TWT_T UniCmdTWT;
	struct UNI_CMD_TWT_MGMT_FRAME_OFFLOAD_T UniCmdOffloadPara;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 temp_len = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdTWT);
	os_zero_mem(&UniCmdTWT, u4ComCmdSize);
	os_zero_mem(&UniCmdOffloadPara, sizeof(UniCmdOffloadPara));

	/* Step 1: Count maximum buffer size from per TLV */
	temp_len = OffloadPara->len;
	temp_len = temp_len + ((temp_len % 4) ? (4 - (temp_len % 4)) : 0);
	/*4=aucVal[0]->mgmt_len*/
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdOffloadPara) + 4 + temp_len;
	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
		"u4CmdNeedMaxBufSize=%d+%d+%d+%d=%d, len=%d, sizeof(OffloadPara->len)=%d\n",
		u4ComCmdSize,
		(UINT32)sizeof(UniCmdOffloadPara),
		4,
		temp_len,
		u4CmdNeedMaxBufSize,
		OffloadPara->len,
		(UINT32)sizeof(OffloadPara->len));

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TWT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);

	/* Step 3: Fill and append common parameters here */
	UniCmdTWT.ucBssInfoIdx = OffloadPara->bssinfo_idx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdTWT, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here, 4=aucVal[0]->mgmt_len, temp_len=4B alignment */
	UniCmdOffloadPara.u2Tag = cpu2le16(UNI_CMD_TWT_MGMT_FRAME_OFFLOAD);
	UniCmdOffloadPara.u2Length = cpu2le16(sizeof(UniCmdOffloadPara) + 4 + temp_len);
	UniCmdOffloadPara.u2Wcid = cpu2le16(OffloadPara->wcid);
	UniCmdOffloadPara.ucToken = OffloadPara->token;
	UniCmdOffloadPara.ucMloEn = OffloadPara->mlo_en;
	UniCmdOffloadPara.u2MldStaIndx = cpu2le16(OffloadPara->mld_sta_idx);
	UniCmdOffloadPara.ucActionLinkid = OffloadPara->action_linkid;
	UniCmdOffloadPara.u2AllLinkidBitmap = cpu2le16(OffloadPara->all_linkid_bitmap);
	AndesAppendCmdMsg(msg, (char *)&UniCmdOffloadPara, sizeof(UniCmdOffloadPara));

	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_TWT, DBG_LVL_INFO,
		"BssIdx=%d,T=%d,L=%d,wcid=%d,token=%d,mlo_en=%d,mld_sta_idx=%d,action_linkid=%d,all_linkid_bitmap=0x%x\n",
		UniCmdTWT.ucBssInfoIdx,
		UniCmdOffloadPara.u2Tag,
		UniCmdOffloadPara.u2Length,
		UniCmdOffloadPara.u2Wcid,
		UniCmdOffloadPara.ucToken,
		UniCmdOffloadPara.ucMloEn,
		UniCmdOffloadPara.u2MldStaIndx,
		UniCmdOffloadPara.ucActionLinkid,
		UniCmdOffloadPara.u2AllLinkidBitmap);

	if (OffloadPara->len && OffloadPara->buf) {
		/* append: mgmt len = 4B */
		AndesAppendCmdMsg(msg, (char *)&OffloadPara->len, sizeof(OffloadPara->len));
		/* append: mgmt buf[]= mgmt + 0~3 zero padding */
		AndesAppendCmdMsg(msg, (char *)OffloadPara->buf, temp_len);
	}

	/*dump_hex_content(GET_OS_PKT_DATAPTR(msg->net_pkt), GET_OS_PKT_LEN(msg->net_pkt));*/

	ret = chip_cmd_tx(pAd, msg);
	if (OffloadPara->buf)
		os_free_mem(OffloadPara->buf);

	return ret;

error:
	if (OffloadPara->buf)
		os_free_mem(OffloadPara->buf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATPROTO_TWT, DBG_LVL_ERROR,
			"ret = %d)\n", ret);
	return ret;
}
#endif /* WIFI_TWT_SUPPORT */
#endif /* DOT11_HE_AX */

/*********************************************
 * UNI_CMD_ID_REPT_MUAR (0x09)
 * UNI_CMD_ID_NORM_MUAR (0x0A)
 *********************************************/
INT32 UniCmdMuarConfigSet(
	struct _RTMP_ADAPTER *pAd,
	UCHAR *pdata,
	BOOLEAN bSmesh,
	BOOLEAN bEntryAdd)
{
	struct cmd_msg          		*msg = NULL;
	EXT_CMD_MUAR_T 					*pconfig_muar = (EXT_CMD_MUAR_T *)pdata;
	UINT8							ucEntryCnt = pconfig_muar->ucEntryCnt;
	UINT32							u4CmdNeedMaxBufSize = 0;
	UINT32							u4RealUseBufSize = 0;
	UINT32							u4SendBufSize = 0;
	UINT32							u4RemainingPayloadSize = 0;
	INT32							Ret = NDIS_STATUS_SUCCESS;
	UINT32							u4ComCmdSize = 0;
	UINT16                 			u2TLVNumber = 0;
	UINT8							i = 0;
	PUCHAR							pTempBuf = NULL;
	PUCHAR							pNextHeadBuf = NULL;
	PUCHAR							pExtCmdBuf = pdata;
	P_UNI_CMD_MUAR_T 				pUniCmdMuar = NULL;
	P_UNI_CMD_MUAR_ENTRY_T 			pUniCmdMuarEntry = NULL;
	P_EXT_CMD_MUAR_MULTI_ENTRY_T 	pExtCmdMuarEntry = NULL;
	RTMP_CHIP_CAP					*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_CMD, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_MUAR_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + (ucEntryCnt * sizeof(UNI_CMD_MUAR_ENTRY_T));

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pUniCmdMuar = (P_UNI_CMD_MUAR_T)pNextHeadBuf;
	pUniCmdMuar->ucBand = pconfig_muar->ucBand;
	pNextHeadBuf += sizeof(UNI_CMD_MUAR_T);

	/* Step 4: Fill all tags here */
	pExtCmdBuf += sizeof(EXT_CMD_MUAR_T);
	for (i = 0; i < ucEntryCnt; i++) {
		pExtCmdMuarEntry = (P_EXT_CMD_MUAR_MULTI_ENTRY_T)pExtCmdBuf;
		pUniCmdMuarEntry = (P_UNI_CMD_MUAR_ENTRY_T) pNextHeadBuf;

		pUniCmdMuarEntry->u2Tag = cpu2le16(UNI_CMD_MUAR_ENTRY);
		pUniCmdMuarEntry->u2Length = cpu2le16(sizeof(UNI_CMD_MUAR_ENTRY_T));
		pUniCmdMuarEntry->fgSmesh = bSmesh;
		pUniCmdMuarEntry->ucHwBssIndex = pExtCmdMuarEntry->ucBssid;
		pUniCmdMuarEntry->ucMuarIdx = pExtCmdMuarEntry->ucMuarIdx;
		pUniCmdMuarEntry->ucEntryAdd = bEntryAdd;
		NdisCopyMemory(pUniCmdMuarEntry->aucMacAddr, pExtCmdMuarEntry->aucMacAddr, sizeof(pUniCmdMuarEntry->aucMacAddr));

		MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_CMD, DBG_LVL_DEBUG,
			"u2Tag = %d, u2Length = %d, fgSmesh = %d, ucHwBssIndex = %d, ucMuarIdx = %d, ucEntryAdd = %d, pUniCmdMuarEntry->aucMacAddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
			le2cpu16(pUniCmdMuarEntry->u2Tag),
			le2cpu16(pUniCmdMuarEntry->u2Length),
			pUniCmdMuarEntry->fgSmesh,
			pUniCmdMuarEntry->ucHwBssIndex,
			pUniCmdMuarEntry->ucMuarIdx,
			pUniCmdMuarEntry->ucEntryAdd,
			PRINT_MAC(pUniCmdMuarEntry->aucMacAddr));

		pExtCmdBuf += sizeof(EXT_CMD_MUAR_MULTI_ENTRY_T);
		pNextHeadBuf += sizeof(UNI_CMD_MUAR_ENTRY_T);
		u2TLVNumber++;
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_CMD, DBG_LVL_INFO,
			"BAND = %d, TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			pUniCmdMuar->ucBand, u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			if (pconfig_muar->ucMuarModeSel == MUAR_REPEATER)
				SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_REPT_MUAR);
			else
				SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_NORM_MUAR);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_CMD, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", Ret);

	return Ret;
}

/*********************************************
 * UNI_CMD_ID_ECC_OPER (0x18)
 *********************************************/
static struct _EC_GROUP_LENGTH_MAP_T ec_group_map[] = {
	{ECDH_GROUP_ID_256BIT, ECDH_LENGTH_256BIT},
	{ECDH_GROUP_ID_384BIT, ECDH_LENGTH_384BIT},
	{ECDH_GROUP_ID_521BIT, ECDH_LENGTH_521BIT},
	{ECDH_GROUP_ID_192BIT, ECDH_LENGTH_192BIT},
	{ECDH_GROUP_ID_224BIT, ECDH_LENGTH_224BIT},
	{0, 0}
};

#define SIZE_EC_GROUP_MAP   (sizeof(ec_group_map) / sizeof(struct _EC_GROUP_LENGTH_MAP_T))

INT32 UniCmdCalculateECC(struct _RTMP_ADAPTER *pAd, UINT32 oper, UINT32 group, UINT8 *scalar, UINT8 *point_x, UINT8 *point_y)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_ECC_OP_T	 UniCmdEccOp;
	UNI_CMD_ECC_OP_CAL_T UniCmdEccOpCal;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 size = 0, i, element_len = 0, cal_mode = ECC_CAL_DG_MODE;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UINT32 offset = 0;
	static UINT8 ecc_cmd_id;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_SEC, CATSEC_ECC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdEccOp);
	os_zero_mem(&UniCmdEccOp, u4ComCmdSize);
	os_zero_mem(&UniCmdEccOpCal, sizeof(UniCmdEccOpCal));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdEccOpCal);

	MTWF_DBG(pAd, DBG_CAT_SEC, CATSEC_ECC, DBG_LVL_INFO,
		"oper = %d, group = %d\n", oper, group);

	for (i = 0; i < SIZE_EC_GROUP_MAP; i++) {
		if (group == ec_group_map[i].group_id) {
			element_len = ec_group_map[i].element_len;
			break;
		}

		if (ec_group_map[i].group_id == 0) {
			ret = NDIS_STATUS_INVALID_DATA;
			goto error;
		}
	}

	if (scalar)
		size += element_len;
	else {
		ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	if ((point_x) && (point_y)) {
		size += (element_len * 2);
		cal_mode = ECC_CAL_DQ_MODE;
	} else if (((point_x) && (point_y == NULL)) ||
		((point_x == NULL) && (point_y))) {
		/*we don't support pass x or y coordinate only. need to pass whole x & y coordingnates.*/
		ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}
	u4CmdNeedMaxBufSize += size;

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_ECC_OPER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	AndesAppendCmdMsg(msg, (char *)&UniCmdEccOp, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdEccOpCal.u2Tag = UNI_CMD_ECC_OP_CAL_GROUP_POINT;
	UniCmdEccOpCal.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdEccOpCal.ucGroupID = group;
	UniCmdEccOpCal.ucDataLength = size;
	UniCmdEccOpCal.ucDataType = cal_mode;
	UniCmdEccOpCal.ucEccCmdId = ecc_cmd_id;
	ecc_cmd_id++;
	NdisMoveMemory(&(UniCmdEccOpCal.aucBuffer[offset]), scalar, element_len);
	offset += element_len;

	if (cal_mode == ECC_CAL_DQ_MODE) {
		NdisMoveMemory(&(UniCmdEccOpCal.aucBuffer[offset]), point_x, element_len);
		offset += element_len;
		NdisMoveMemory(&(UniCmdEccOpCal.aucBuffer[offset]), point_y, element_len);
		offset += element_len;
	}

#ifdef CFG_BIG_ENDIAN
	UniCmdEccOpCal.u2Tag 	= cpu2le16(UniCmdEccOpCal.u2Tag);
	UniCmdEccOpCal.u2Length = cpu2le16(UniCmdEccOpCal.u2Length);
#endif
	AndesAppendCmdMsg(msg, (char *)&UniCmdEccOpCal, sizeof(UniCmdEccOpCal));
	AndesAppendCmdMsg(msg, (char *)&UniCmdEccOpCal.aucBuffer[0], offset);

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_SEC, CATSEC_ECC, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}

#ifdef MT_DFS_SUPPORT
INT32 UniCmdRddCtrl(
	struct _RTMP_ADAPTER *pAd,
	UCHAR ucDfsCtrl,
	UCHAR ucRddIdex,
	UCHAR ucRddRxSel,
	UCHAR ucSetVal)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	 UniCmdRDD;
	UNI_CMD_RDD_ON_OFF_CTRL_PARM_T UniCmdRDDOnOffCtrl;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UINT16 timeOut;
	PDFS_PARAM pDfsParam = &pAd->CommonCfg.DfsParameter;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdRDDOnOffCtrl, sizeof(UniCmdRDDOnOffCtrl));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdRDDOnOffCtrl);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	/*extend the timeout limit of CAC_END because this command will do calibration*/
	if (ucDfsCtrl == CAC_END) {
		timeOut = 10000;
	} else
		timeOut = 0;

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, timeOut);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdRDDOnOffCtrl.u2Tag = UNI_CMD_RDD_ON_OFF_CTRL_PARM;
	UniCmdRDDOnOffCtrl.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdRDDOnOffCtrl.u2Tag	= cpu2le16(UniCmdRDDOnOffCtrl.u2Tag);
	UniCmdRDDOnOffCtrl.u2Length = cpu2le16(UniCmdRDDOnOffCtrl.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdRDDOnOffCtrl.u1DfsCtrl = ucDfsCtrl;
	UniCmdRDDOnOffCtrl.u1RddIdx = ucRddIdex;
	UniCmdRDDOnOffCtrl.u1RddRxSel = ucRddRxSel;
	UniCmdRDDOnOffCtrl.u1SetVal = ucSetVal;
	UniCmdRDDOnOffCtrl.u1DisTm = pDfsParam->ucDisTm;

	AndesAppendCmdMsg(msg, (char *)&UniCmdRDDOnOffCtrl, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdSetRddIpiHist(
	struct _RTMP_ADAPTER *pAd,
	struct _UNI_CMD_RDD_IPI_HIST_T *pData)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	 UniCmdRDD;
	struct _UNI_CMD_RDD_IPI_HIST_T  UniCmdRDDIpiHist;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;
	UINT8 *pUniCmdRDDIpiHist = (UINT8 *)&UniCmdRDDIpiHist;

	NdisCopyMemory(pUniCmdRDDIpiHist, pData, sizeof(struct _UNI_CMD_RDD_IPI_HIST_T));
	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");
	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdRDDIpiHist, sizeof(UniCmdRDDIpiHist));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdRDDIpiHist);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdRDDIpiHist.u2Tag = UNI_CMD_RDD_IPI_HIST_SET_PARM;
	UniCmdRDDIpiHist.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdRDDIpiHist.ipi_hist_idx = pData->ipi_hist_idx;

#ifdef CFG_BIG_ENDIAN
	UniCmdRDDIpiHist.u2Tag	= cpu2le16(UniCmdRDDIpiHist.u2Tag);
	UniCmdRDDIpiHist.u2Length = cpu2le16(UniCmdRDDIpiHist.u2Length);
#endif /* CFG_BIG_ENDIAN */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDDIpiHist, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdGetRddIpiHist(
	PRTMP_ADAPTER pAd,
	UINT8 rdd_ipi_hist_idx,
	struct UNI_EVENT_RDD_IPI_HIST *p_rdd_ipi_hist_rlt)

{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	 UniCmdRDD;
	struct _UNI_CMD_RDD_IPI_HIST_T  UniCmdRDDIpiHist;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");
	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdRDDIpiHist, sizeof(UniCmdRDDIpiHist));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdRDDIpiHist);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, p_rdd_ipi_hist_rlt);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventRDDGetIpiHist);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdRDDIpiHist.u2Tag = UNI_CMD_RDD_IPI_HIST_GET_PARM;
	UniCmdRDDIpiHist.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdRDDIpiHist.u2Tag	= cpu2le16(UniCmdRDDIpiHist.u2Tag);
	UniCmdRDDIpiHist.u2Length = cpu2le16(UniCmdRDDIpiHist.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdRDDIpiHist.ipi_hist_idx = rdd_ipi_hist_idx;
	UniCmdRDDIpiHist.band_idx = p_rdd_ipi_hist_rlt->u1BandIdx;

	AndesAppendCmdMsg(msg, (char *)&UniCmdRDDIpiHist, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

#ifdef IPI_MAINRADIO_SCAN_SUPPORT

INT32 UniCmdSetRddIpiScan(
	PRTMP_ADAPTER pAd,
	struct _UNI_CMD_RDD_IPI_SCAN_T *p_cmd_rdd_ipi_scan)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	UniCmdRDD;
	struct _UNI_CMD_RDD_IPI_SCAN_T	UniCmdRDDIpiScan;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
					"dispath CMD start\n");
	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdRDDIpiScan, sizeof(UniCmdRDDIpiScan));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdRDDIpiScan);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdRDDIpiScan.u2Tag = UNI_CMD_RDD_IPI_SCAN_SET_PARM;
	UniCmdRDDIpiScan.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdRDDIpiScan.u1Band = p_cmd_rdd_ipi_scan->u1Band;
	UniCmdRDDIpiScan.u1pdSetting = p_cmd_rdd_ipi_scan->u1pdSetting;

#ifdef CFG_BIG_ENDIAN
	UniCmdRDDIpiScan.u2Tag	= cpu2le16(UniCmdRDDIpiScan.u2Tag);
	UniCmdRDDIpiScan.u2Length = cpu2le16(UniCmdRDDIpiScan.u2Length);
#endif /* CFG_BIG_ENDIAN */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDDIpiScan, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
				"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdGetRddIpiScan(
	PRTMP_ADAPTER pAd,
	struct _UNI_CMD_RDD_IPI_SCAN_T *p_cmd_rdd_ipi_scan,
	struct _UNI_EVENT_RDD_IPI_SCAN_T *p_event_rdd_ipi_scan)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	 UniCmdRDD;
	struct _UNI_CMD_RDD_IPI_SCAN_T	UniCmdRDDIpiScan;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
					"dispath CMD start\n");
	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdRDDIpiScan, sizeof(UniCmdRDDIpiScan));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdRDDIpiScan);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, p_event_rdd_ipi_scan);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventRDDGetIpiScan);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdRDDIpiScan.u2Tag = UNI_CMD_RDD_IPI_SCAN_GET_PARM;
	UniCmdRDDIpiScan.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdRDDIpiScan.u2Tag	= cpu2le16(UniCmdRDDIpiScan.u2Tag);
	UniCmdRDDIpiScan.u2Length = cpu2le16(UniCmdRDDIpiScan.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdRDDIpiScan.u1pdSetting = p_cmd_rdd_ipi_scan->u1pdSetting;
	UniCmdRDDIpiScan.u1Band = p_cmd_rdd_ipi_scan->u1Band;

	AndesAppendCmdMsg(msg, (char *)&UniCmdRDDIpiScan, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
				"(ret = %d)\n", ret);
	return ret;

}


#endif

INT32 UniCmdSetFcc5MinIpn(
	struct _RTMP_ADAPTER *pAd,
	UINT16 min_lpn_update)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T	 UniCmdRDD;
	struct UNI_RDM_FCC5_LPN_UPDATE_T cmd_set_lpn_update;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&cmd_set_lpn_update, sizeof(cmd_set_lpn_update));

	cmd_set_lpn_update.fcc_lpn_min = min_lpn_update;
	cmd_set_lpn_update.tag = ENUM_RDM_FCC5_LPN_UPDATE;

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_lpn_update);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	cmd_set_lpn_update.u2Tag = UNI_CMD_SET_RDM_RADAR_THRES;
	cmd_set_lpn_update.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_set_lpn_update.u2Tag	= cpu2le16(cmd_set_lpn_update.u2Tag);
	cmd_set_lpn_update.u2Length = cpu2le16(cmd_set_lpn_update.u2Length);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&cmd_set_lpn_update, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetRadarThresParam(
	struct _RTMP_ADAPTER *pAd,
	P_CMD_RDM_RADAR_THRESHOLD_UPDATE_T p_radar_threshold)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T UniCmdRDD = {0};
	struct RDM_RDR_THRES_UPDATE_T cmd_radar_thres_update = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&cmd_radar_thres_update, sizeof(struct RDM_RDR_THRES_UPDATE_T));
	NdisCopyMemory(&cmd_radar_thres_update.tag, p_radar_threshold, sizeof(CMD_RDM_RADAR_THRESHOLD_UPDATE_T));
	cmd_radar_thres_update.tag = ENUM_RDM_RADAR_THRESHOLD_UPDATE;
#ifdef CFG_BIG_ENDIAN
	cmd_radar_thres_update.tag
		= cpu2le32(cmd_radar_thres_update.tag);
	cmd_radar_thres_update.radar_type_idx
		= cpu2le16(cmd_radar_thres_update.radar_type_idx);
	cmd_radar_thres_update.rt_pri_max
		= cpu2le32(cmd_radar_thres_update.rt_pri_max);
	cmd_radar_thres_update.rt_pri_min
		= cpu2le32(cmd_radar_thres_update.rt_pri_min);
	cmd_radar_thres_update.rt_stg_pri_diff_min
		= cpu2le32(cmd_radar_thres_update.rt_stg_pri_diff_min);
#endif

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_radar_thres_update);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}


	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_radar_thres_update.u2Tag = UNI_CMD_SET_RDM_RADAR_THRES;
	cmd_radar_thres_update.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_radar_thres_update.u2Tag	= cpu2le16(cmd_radar_thres_update.u2Tag);
	cmd_radar_thres_update.u2Length = cpu2le16(cmd_radar_thres_update.u2Length);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&cmd_radar_thres_update, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetPlsThresParam(
	RTMP_ADAPTER * pAd,
	P_CMD_RDM_PULSE_THRESHOLD_UPDATE_T p_pls_threshold)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T UniCmdRDD = {0};
	struct UNI_RDM_PLS_THRES_UPDATE_T cmd_set_pls_thres_update = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&cmd_set_pls_thres_update.tag, sizeof(struct UNI_RDM_PLS_THRES_UPDATE_T));
	NdisCopyMemory(&cmd_set_pls_thres_update, p_pls_threshold, sizeof(struct _RDM_PULSE_THRESHOLD_UPDATE_T));
	cmd_set_pls_thres_update.tag = ENUM_RDM_PULSE_THRESHOLD_UPDATE;
#ifdef CFG_BIG_ENDIAN
	cmd_set_pls_thres_update.tag
		= cpu2le32(cmd_set_pls_thres_update.tag);
	cmd_set_pls_thres_update.prd_pls_width_max
		= cpu2le32(cmd_set_pls_thres_update.prd_pls_width_max);
	cmd_set_pls_thres_update.pls_pwr_max
		= cpu2le32(cmd_set_pls_thres_update.pls_pwr_max);
	cmd_set_pls_thres_update.pls_pwr_min
		= cpu2le32(cmd_set_pls_thres_update.pls_pwr_min);
	cmd_set_pls_thres_update.pri_max_cr
		= cpu2le32(cmd_set_pls_thres_update.pri_max_cr);
	cmd_set_pls_thres_update.pri_min_cr
		= cpu2le32(cmd_set_pls_thres_update.pri_min_cr);
	cmd_set_pls_thres_update.pri_max_stgr
		= cpu2le32(cmd_set_pls_thres_update.pri_max_stgr);
	cmd_set_pls_thres_update.pri_min_stgr
		= cpu2le32(cmd_set_pls_thres_update.pri_min_stgr);
#endif
	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_pls_thres_update);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}


	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_set_pls_thres_update.u2Tag = UNI_CMD_SET_RDM_RADAR_THRES;
	cmd_set_pls_thres_update.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_set_pls_thres_update.u2Tag	= cpu2le16(cmd_set_pls_thres_update.u2Tag);
	cmd_set_pls_thres_update.u2Length = cpu2le16(cmd_set_pls_thres_update.u2Length);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&cmd_set_pls_thres_update, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetRddLogConfig(
	IN RTMP_ADAPTER * pAd,
	IN UINT8 hw_rdd_log_en,
	IN UINT8 sw_rdd_log_en,
	IN UINT8 sw_rdd_log_cond)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T UniCmdRDD = {0};
	struct UNI_RDM_RDD_LOG_CONFIG_UPDATE_T cmd_set_rdd_log_config = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&cmd_set_rdd_log_config, sizeof(struct UNI_RDM_RDD_LOG_CONFIG_UPDATE_T));

	cmd_set_rdd_log_config.tag = ENUM_RDM_RDD_LOG_CONFIG_UPDATE;
#ifdef CFG_BIG_ENDIAN
	cmd_set_rdd_log_config.tag = cpu2le16(cmd_set_rdd_log_config.tag);
#endif
	cmd_set_rdd_log_config.hw_rdd_log_en = hw_rdd_log_en;
	cmd_set_rdd_log_config.sw_rdd_log_en = sw_rdd_log_en;
	cmd_set_rdd_log_config.sw_rdd_log_cond = sw_rdd_log_cond;

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_rdd_log_config);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_set_rdd_log_config.u2Tag = UNI_CMD_SET_RDM_RADAR_THRES;
	cmd_set_rdd_log_config.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_set_rdd_log_config.u2Tag	= cpu2le16(cmd_set_rdd_log_config.u2Tag);
	cmd_set_rdd_log_config.u2Length = cpu2le16(cmd_set_rdd_log_config.u2Length);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&cmd_set_rdd_log_config, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdTestRadarPattern(
	IN struct _RTMP_ADAPTER *pAd,
	IN struct _EXT_CMD_RDM_TEST_RADAR_PATTERN_T *pls_pattern)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_RDD_T UniCmdRDD;
	struct UNI_RDM_RDD_TEST_RADAR_PATTERN_T  UniCmdPulsePattern;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
#ifdef CFG_BIG_ENDIAN
	INT8 i = 0;
#endif
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdRDD);
	os_zero_mem(&UniCmdRDD, u4ComCmdSize);
	os_zero_mem(&UniCmdPulsePattern, sizeof(struct UNI_RDM_RDD_TEST_RADAR_PATTERN_T));

	UniCmdPulsePattern.pls_num = pls_pattern->pls_num;
	NdisCopyMemory(&(UniCmdPulsePattern.prd_pls_buff[0]), &(pls_pattern->prd_pls_buff[0]), (PPB_SIZE * sizeof(struct UNI_RDM_RDD_PERIODIC_PULSE_BUFFER_T)));

#ifdef CFG_BIG_ENDIAN
	for (i = 0; i < UniCmdPulsePattern.pls_num; i++) {
		UniCmdPulsePattern.prd_pls_buff[i].prd_strt_time
			= cpu2le32(UniCmdPulsePattern.prd_pls_buff[i].prd_strt_time);
		UniCmdPulsePattern.prd_pls_buff[i].prd_pls_wdth
			= cpu2le16(UniCmdPulsePattern.prd_pls_buff[i].prd_pls_wdth);
		UniCmdPulsePattern.prd_pls_buff[i].prd_pls_pwr
			= cpu2le16(UniCmdPulsePattern.prd_pls_buff[i].prd_pls_pwr);
	}
#endif

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdPulsePattern);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RDD_ON_OFF_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdRDD, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdPulsePattern.u2Tag = UNI_CMD_SET_RDM_TEST_PATTERN;
	UniCmdPulsePattern.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdPulsePattern.u2Tag	= cpu2le16(UniCmdPulsePattern.u2Tag);
	UniCmdPulsePattern.u2Length = cpu2le16(UniCmdPulsePattern.u2Length);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&UniCmdPulsePattern, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}
#endif /* MT_DFS_SUPPORT */

INT32 UniCmdOffChScan(
	IN struct _RTMP_ADAPTER *pAd,
	IN struct _EXT_CMD_OFF_CH_SCAN_CTRL_T *ext_cmd_param)

{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_OFF_CH_SCAN_T	 UniCmdOffChScan;
	UNI_CMD_OFF_CH_SCAN_CTRL_PARM_T  UniCmdOffChScanCtrl;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
				"dispath CMD start\n");
	u4ComCmdSize = sizeof(UniCmdOffChScan);
	os_zero_mem(&UniCmdOffChScan, u4ComCmdSize);
	os_zero_mem(&UniCmdOffChScanCtrl, sizeof(UniCmdOffChScanCtrl));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdOffChScanCtrl);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_OFF_CH_SCAN_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdOffChScan, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdOffChScanCtrl.u2Tag = UNI_CMD_OFF_CH_SCAN_CTRL;
	UniCmdOffChScanCtrl.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdOffChScanCtrl.u2Tag	= cpu2le16(UniCmdOffChScanCtrl.u2Tag);
	UniCmdOffChScanCtrl.u2Length = cpu2le16(UniCmdOffChScanCtrl.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdOffChScanCtrl.u1MonitorPrimCh = ext_cmd_param->mntr_prim_ch;
	UniCmdOffChScanCtrl.u1MonitorCentralCh = ext_cmd_param->mntr_cntrl_ch;
	UniCmdOffChScanCtrl.u1MonitorBW = ext_cmd_param->mntr_bw;
	UniCmdOffChScanCtrl.u1MonitorTxStreamPath = ext_cmd_param->mntr_tx_strm_pth;
	UniCmdOffChScanCtrl.u1MonitorRxStreamPath = ext_cmd_param->mntr_rx_strm_pth;
	UniCmdOffChScanCtrl.u1WorkPrimCh = ext_cmd_param->work_prim_ch;
	UniCmdOffChScanCtrl.u1WorkCentralCh = ext_cmd_param->work_cntrl_ch;
	UniCmdOffChScanCtrl.u1WorkBW = ext_cmd_param->work_bw;
	UniCmdOffChScanCtrl.u1WorkTxStreamPath = ext_cmd_param->work_tx_strm_pth;
	UniCmdOffChScanCtrl.u1WorkRxStreamPath = ext_cmd_param->work_rx_strm_pth;
	UniCmdOffChScanCtrl.u1DbdcIdx = ext_cmd_param->dbdc_idx;
	UniCmdOffChScanCtrl.u1ScanMode = ext_cmd_param->scan_mode;
	UniCmdOffChScanCtrl.u1Band = ext_cmd_param->is_aband;
	UniCmdOffChScanCtrl.u1OffChScanType = ext_cmd_param->off_ch_scn_type;

	AndesAppendCmdMsg(msg, (char *)&UniCmdOffChScanCtrl, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

#ifdef ZERO_PKT_LOSS_SUPPORT
INT32 UniCmdZeroLossEnable(
	IN struct _RTMP_ADAPTER *pAd,
	INT enable)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SCSA_T UniCmdSCSA;
	struct _UNI_CMD_SET_ZERO_PKT_LOSS_VARIABLE_T UniCmdZeroLoss;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdSCSA);
	os_zero_mem(&UniCmdSCSA, u4ComCmdSize);
	os_zero_mem(&UniCmdZeroLoss, sizeof(UniCmdZeroLoss));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdZeroLoss);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SCSA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdZeroLoss, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdZeroLoss.u2Tag = UNI_CMD_SET_ZERO_PKT_LOSS_VARIABLE;
	UniCmdZeroLoss.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdZeroLoss.u1ZeroPktLossVariable = enable;
#ifdef CFG_BIG_ENDIAN
	UniCmdZeroLoss.u2Tag	= cpu2le16(UniCmdZeroLoss.u2Tag);
	UniCmdZeroLoss.u2Length = cpu2le16(UniCmdZeroLoss.u2Length);
	UniCmdZeroLoss.u1ZeroPktLossVariable = cpu2le16(enable);
#endif /* CFG_BIG_ENDIAN */

	AndesAppendCmdMsg(msg, (char *)&UniCmdZeroLoss, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_PRINT("(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdMacTxEnable(
	IN struct _RTMP_ADAPTER *pAd,
	BOOLEAN enable, UCHAR BandIdx)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SCSA_T UniCmdSCSA;
	struct _UNI_CMD_SET_MAC_TX_ENABLE_T UniCmdMacTx;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdSCSA);
	os_zero_mem(&UniCmdSCSA, u4ComCmdSize);
	os_zero_mem(&UniCmdMacTx, sizeof(UniCmdMacTx));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdMacTx);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SCSA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMacTx, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmdMacTx.u2Tag = UNI_CMD_SET_MAC_TX_ENABLE;
	UniCmdMacTx.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmdMacTx.fgMacTXEnable = enable;
	UniCmdMacTx.ucBandIdx = BandIdx;
#ifdef CFG_BIG_ENDIAN
	UniCmdMacTx.u2Tag	= cpu2le16(UniCmdMacTx.u2Tag);
	UniCmdMacTx.u2Length = cpu2le16(UniCmdMacTx.u2Length);
	UniCmdMacTx.fgMacTXEnable = cpu2le16(enable);
	UniCmdMacTx.ucBandIdx = cpu2le16(BandIdx);
#endif /* CFG_BIG_ENDIAN */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMacTx, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_PRINT("(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdWcidSkipTx(
	IN struct _RTMP_ADAPTER *pAd,
	UINT_16 WlanIdx, UINT_8	Operation, BOOLEAN WtblSkipTXEnable, UINT32 *prSkipTxResult)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SCSA_T UniCmdSCSA;
	struct _UNI_CMD_SET_WTBL_SKIP_TX_ENABLE_T UniCmSkipTx;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdSCSA);
	os_zero_mem(&UniCmdSCSA, u4ComCmdSize);
	os_zero_mem(&UniCmSkipTx, sizeof(UniCmSkipTx));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmSkipTx);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SCSA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	if (Operation == WTBL_OPERATION_QUERY) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prSkipTxResult);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct _UNI_EVENT_WTBL_SKIP_TX_STATUS_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_wcid_skip_tx_status_handler);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	}
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmSkipTx, (u4ComCmdSize));

	/* Step 4: Fill and append TLV parameters here */
	UniCmSkipTx.u2Tag = UNI_CMD_SET_WTBL_SKIP_TX_ENABLE;
	UniCmSkipTx.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	UniCmSkipTx.u2WlanIdx = WlanIdx;
	UniCmSkipTx.ucOperation = Operation;
	UniCmSkipTx.fgWtblSkipTXEnable = WtblSkipTXEnable;

#ifdef CFG_BIG_ENDIAN
	UniCmSkipTx.u2Tag	= cpu2le16(UniCmSkipTx.u2Tag);
	UniCmSkipTx.u2Length = cpu2le16(UniCmSkipTx.u2Length);
	UniCmSkipTx.u2WlanIdx = cpu2le16(WlanIdx;)
	UniCmSkipTx.ucOperation = cpu2le16(Operation);
	UniCmSkipTx.fgWtblSkipTXEnable = cpu2le16(WtblSkipTXEnable);
#endif /* CFG_BIG_ENDIAN */
	AndesAppendCmdMsg(msg, (char *)&UniCmSkipTx, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_PRINT("(ret = %d)\n", ret);
	return ret;

}
#endif /* ZERO_PKT_LOSS_SUPPORT */

INT32 UniCmdGetTsfTime(
	struct _RTMP_ADAPTER *pAd,
	UCHAR HwBssidIdx,
	TSF_RESULT_T *pTsfResult)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_GET_MAC_INFO_T UniCmdGetMacInfo;
	UNI_CMD_MAC_INFO_TSF_T UniCmdMacInfoTsf;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	struct wifi_dev *wdev = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	wdev = wdev_search_by_omac_idx(pAd, HwBssidIdx);
	if (!wdev) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdGetMacInfo);
	os_zero_mem(&UniCmdGetMacInfo, u4ComCmdSize);
	os_zero_mem(&UniCmdMacInfoTsf, sizeof(UniCmdMacInfoTsf));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdMacInfoTsf);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_GET_MAC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, (VOID *)pTsfResult);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventMACInfoHandler);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdGetMacInfo, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdMacInfoTsf.u2Tag = UNI_CMD_MAC_INFO_TSF;
	UniCmdMacInfoTsf.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdMacInfoTsf.u2Tag = cpu2le16(UniCmdMacInfoTsf.u2Tag);
	UniCmdMacInfoTsf.u2Length = cpu2le16(UniCmdMacInfoTsf.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdMacInfoTsf.ucDbdcIdx = wdev->DevInfo.BandIdx;
	UniCmdMacInfoTsf.ucHwBssidIndex = HwBssidIdx;

	AndesAppendCmdMsg(msg, (char *)&UniCmdMacInfoTsf, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdGetTsfDiffTime(
	struct _RTMP_ADAPTER *pAd,
	UINT8 BssIdx0,
	UINT8 BssIdx1,
	struct TSF_DIFF_RESULT_T *pTsfDiffResult)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_GET_MAC_INFO_T UniCmdGetMacInfo;
	struct UNI_CMD_MAC_INFO_TSF_DIFF_T UniCmdMacInfoTsfDiff;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdGetMacInfo);
	os_zero_mem(&UniCmdGetMacInfo, u4ComCmdSize);
	os_zero_mem(&UniCmdMacInfoTsfDiff, sizeof(UniCmdMacInfoTsfDiff));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdMacInfoTsfDiff);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_GET_MAC_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, (VOID *)pTsfDiffResult);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventMACInfoHandler);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdGetMacInfo, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdMacInfoTsfDiff.u2Tag = UNI_CMD_MAC_INFO_TSF_DIFF;
	UniCmdMacInfoTsfDiff.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdMacInfoTsfDiff.u2Tag = cpu2le16(UniCmdMacInfoTsfDiff.u2Tag);
	UniCmdMacInfoTsfDiff.u2Length = cpu2le16(UniCmdMacInfoTsfDiff.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdMacInfoTsfDiff.ucBssIdx0 = BssIdx0;
	UniCmdMacInfoTsfDiff.ucBssIdx1 = BssIdx1;

	AndesAppendCmdMsg(msg, (char *)&UniCmdMacInfoTsfDiff, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_DBGLOG, DBG_LVL_DEBUG,
			"%s:(ret = %d)\n", __func__, ret);
	return ret;
}

#ifdef CFG_SUPPORT_FALCON_TXCMD_DBG

static INT32 UniCmdSetTxCmdCommon(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_SET_TXCMD_DBG_CTRL_ENTRY_T pParam, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T pSetTxCmdDbgCtrl = (P_UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T)pHandle;

	pSetTxCmdDbgCtrl->u2Tag = pParam->u2Tag;
	pSetTxCmdDbgCtrl->u2Length = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T) + pParam->u4DataLen;
#ifdef CFG_BIG_ENDIAN
	pSetTxCmdDbgCtrl->u2Tag = cpu2le16(pSetTxCmdDbgCtrl->u2Tag);
	pSetTxCmdDbgCtrl->u2Length = cpu2le16(pSetTxCmdDbgCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSetTxCmdDbgCtrl->ucUserIndex = pParam->ucUserIndex;
	pSetTxCmdDbgCtrl->ucDlUlidx = pParam->ucDlUlidx;
	if (pParam->u4DataLen > 0)
		os_move_mem(pSetTxCmdDbgCtrl->aucBuffer, pParam->pData, pParam->u4DataLen);

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdTxCmdDbgTab[UNI_CMD_TXCMD_CTRL_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_CTRL,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_CLEAR,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_GLOBAL,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_PROTECT,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_PROTECT_RUINFO,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_TXDATA,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_TXDATA_USER_INFO,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_TRIGDATA,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_TRIGDATA_USER_ACK_INFO,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_TF_TXD,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_TF_BASIC,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_TF_BASIC_USER,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_SW_FID,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SXN_SW_FID_INFO,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SW_FID_TXD,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_STATUS,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SXN_GLOBAL,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SXN_PROTECT,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SXN_TXDATA,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SXN_TRIGDATA,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_TF_TXD,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_TF_BASIC,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SXN_SW_FID,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_GET_TXCMD_DBG_SW_FID_TXD,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
	{
		.u8CmdFeature = UNI_CMD_SET_TXCMD_DBG_SOP,
		.u4StructSize = sizeof(UNI_CMD_SET_TXCMD_DBG_CMD_CTRL_T),
		.pfHandler = UniCmdSetTxCmdCommon
	},
};

INT32 UniCmdTxCmdDbgCtrl(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_TXCMD_DBG_CTRL_PARAM_T pParamCtrl)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_TXCMD_CTRL_T	pCmdTxCmdCtrl = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CFG, CATCFG_TX, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_TXCMD_CTRL_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_TXCMD_CTRL_MAX_NUM; i++) {
		if (pParamCtrl->TxCmdDbgCtrlValid[i])
			u4CmdNeedMaxBufSize += (UniCmdTxCmdDbgTab[i].u4StructSize + pParamCtrl->SetTxCmdDbgEntry[i].u4DataLen);
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdTxCmdCtrl = (P_UNI_CMD_TXCMD_CTRL_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_TXCMD_CTRL_MAX_NUM; i++) {
		if (pParamCtrl->TxCmdDbgCtrlValid[i]) {
			switch (i) {
			case UNI_CMD_SET_TXCMD_DBG_CTRL:
			case UNI_CMD_SET_TXCMD_DBG_CLEAR:
			case UNI_CMD_SET_TXCMD_DBG_SXN_GLOBAL:
			case UNI_CMD_SET_TXCMD_DBG_SXN_PROTECT:
			case UNI_CMD_SET_TXCMD_DBG_SXN_PROTECT_RUINFO:
			case UNI_CMD_SET_TXCMD_DBG_SXN_TXDATA:
			case UNI_CMD_SET_TXCMD_DBG_SXN_TXDATA_USER_INFO:
			case UNI_CMD_SET_TXCMD_DBG_SXN_TRIGDATA:
			case UNI_CMD_SET_TXCMD_DBG_SXN_TRIGDATA_USER_ACK_INFO:
			case UNI_CMD_SET_TXCMD_DBG_TF_TXD:
			case UNI_CMD_SET_TXCMD_DBG_TF_BASIC:
			case UNI_CMD_SET_TXCMD_DBG_TF_BASIC_USER:
			case UNI_CMD_SET_TXCMD_DBG_SXN_SW_FID:
			case UNI_CMD_SET_TXCMD_DBG_SXN_SW_FID_INFO:
			case UNI_CMD_SET_TXCMD_DBG_SW_FID_TXD:
			case UNI_CMD_GET_TXCMD_DBG_STATUS:
			case UNI_CMD_GET_TXCMD_DBG_SXN_GLOBAL:
			case UNI_CMD_GET_TXCMD_DBG_SXN_PROTECT:
			case UNI_CMD_GET_TXCMD_DBG_SXN_TXDATA:
			case UNI_CMD_GET_TXCMD_DBG_SXN_TRIGDATA:
			case UNI_CMD_GET_TXCMD_DBG_TF_TXD:
			case UNI_CMD_GET_TXCMD_DBG_TF_BASIC:
			case UNI_CMD_GET_TXCMD_DBG_SXN_SW_FID:
			case UNI_CMD_GET_TXCMD_DBG_SW_FID_TXD:
			case UNI_CMD_SET_TXCMD_DBG_SOP:
				if (UniCmdTxCmdDbgTab[i].pfHandler != NULL) {
					Ret = ((PFN_SET_TXCMD_DBG_CTRL_HANDLE)(UniCmdTxCmdDbgTab[i].pfHandler))(pAd, &pParamCtrl->SetTxCmdDbgEntry[i], pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += (UniCmdTxCmdDbgTab[i].u4StructSize + pParamCtrl->SetTxCmdDbgEntry[i].u4DataLen);
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_TX, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdTxCmdDbgTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_TX, DBG_LVL_DEBUG,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdTxCmdDbgTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_TX, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}
			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXCMD_CTRL);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (pParamCtrl->bQuery) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTxCmdDbgHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				if (pParamCtrl->bQuery)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CFG, CATCFG_TX, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* CFG_SUPPORT_FALCON_TXCMD_DBG */

#ifdef SMART_CARRIER_SENSE_SUPPORT
static INT32 UniCmdSCSEventSendData(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_SMART_CARRIER_SENSE_CTRL_DATA_FW_VER2 pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SMART_CARRIER_SENSE_CTRL_DATA_FW_VER2 pSCSEventSendData =
		(P_UNI_CMD_SMART_CARRIER_SENSE_CTRL_DATA_FW_VER2)pHandle;

	pSCSEventSendData->u2Tag = pParam->u2Tag;
	pSCSEventSendData->u2Length = sizeof(UNI_CMD_SMART_CARRIER_SENSE_CTRL_DATA_FW_VER2);
#ifdef CFG_BIG_ENDIAN
	pSCSEventSendData->u2Tag = cpu2le16(pSCSEventSendData->u2Tag);
	pSCSEventSendData->u2Length = cpu2le16(pSCSEventSendData->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSCSEventSendData->u2ActiveSTA = cpu2le16(pParam->u2ActiveSTA);
	pSCSEventSendData->u2eTput = cpu2le16(pParam->u2eTput);
	pSCSEventSendData->fgRxOnly = pParam->fgRxOnly;
	pSCSEventSendData->fgPDreset = pParam->fgPDreset;
	pSCSEventSendData->i1SCSMinRSSI = pParam->i1SCSMinRSSI;
	pSCSEventSendData->ucReserved = pParam->ucReserved;

	return Ret;
}

static INT32 UniCmdSCSGetGloAddrCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_SCS_GET_GLO_ADDR_CTRL pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SCS_GET_GLO_ADDR_CTRL pSCSGetGloAddrCtrl =
		(P_UNI_CMD_SCS_GET_GLO_ADDR_CTRL)pHandle;

	pSCSGetGloAddrCtrl->u2Tag = pParam->u2Tag;
	pSCSGetGloAddrCtrl->u2Length = sizeof(UNI_CMD_SCS_GET_GLO_ADDR_CTRL);
#ifdef CFG_BIG_ENDIAN
	pSCSGetGloAddrCtrl->u2Tag = cpu2le16(pSCSGetGloAddrCtrl->u2Tag);
	pSCSGetGloAddrCtrl->u2Length = cpu2le16(pSCSGetGloAddrCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return Ret;
}

static INT32 UniCmdSCSEventSetPDThrRange(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_SET_SCS_PD_THR_RANGE pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SET_SCS_PD_THR_RANGE pSCSSetPDThrRange =
		(P_UNI_CMD_SET_SCS_PD_THR_RANGE)pHandle;

	pSCSSetPDThrRange->u2Tag = pParam->u2Tag;
	pSCSSetPDThrRange->u2Length = sizeof(UNI_CMD_SET_SCS_PD_THR_RANGE);
#ifdef CFG_BIG_ENDIAN
	pSCSSetPDThrRange->u2Tag = cpu2le16(pSCSSetPDThrRange->u2Tag);
	pSCSSetPDThrRange->u2Length = cpu2le16(pSCSSetPDThrRange->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSCSSetPDThrRange->u2CckPdThrMax = cpu2le16(pParam->u2CckPdThrMax);
	pSCSSetPDThrRange->u2OfdmPdThrMax = cpu2le16(pParam->u2OfdmPdThrMax);
	pSCSSetPDThrRange->u2CckPdThrMin = cpu2le16(pParam->u2CckPdThrMin);
	pSCSSetPDThrRange->u2OfdmPdThrMin = cpu2le16(pParam->u2OfdmPdThrMin);

	return Ret;
}

static INT32 UniCmdSCSSmartCarrierEnable(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_SMART_CARRIER_ENABLE pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_SMART_CARRIER_ENABLE pSCSEnable =
		(P_UNI_CMD_SMART_CARRIER_ENABLE)pHandle;

	pSCSEnable->u2Tag = pParam->u2Tag;
	pSCSEnable->u2Length = sizeof(UNI_CMD_SMART_CARRIER_ENABLE);
#ifdef CFG_BIG_ENDIAN
	pSCSEnable->u2Tag = cpu2le16(pSCSEnable->u2Tag);
	pSCSEnable->u2Length = cpu2le16(pSCSEnable->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pSCSEnable->u1SCSEnable = pParam->u1SCSEnable;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdSCSTab[UNI_CMD_SCS_MAX_EVENT] = {
	{
		.u8CmdFeature = UNI_CMD_SCS_EVENT_SEND_DATA,
		.u4StructSize = sizeof(UNI_CMD_SMART_CARRIER_SENSE_CTRL_DATA_FW_VER2),
		.pfHandler = UniCmdSCSEventSendData
	},
	{
		.u8CmdFeature = UNI_CMD_SCS_EVENT_GET_GLO_ADDR,
		.u4StructSize = sizeof(UNI_CMD_SCS_GET_GLO_ADDR_CTRL),
		.pfHandler = UniCmdSCSGetGloAddrCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_SCS_EVENT_SET_PD_THR_RANGE,
		.u4StructSize = sizeof(UNI_CMD_SET_SCS_PD_THR_RANGE),
		.pfHandler = UniCmdSCSEventSetPDThrRange
	},
	{
		.u8CmdFeature = UNI_CMD_SCS_EVENT_SCS_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_SMART_CARRIER_ENABLE),
		.pfHandler = UniCmdSCSSmartCarrierEnable
	},
};

INT32 UniCmdSCS(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_SCS_PARAM_T pParamCtrl)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	P_UNI_CMD_SCS_T	pCmdSCS = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_SCS, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_BAND_CONFIG_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_SCS_MAX_EVENT; i++) {
		if (pParamCtrl->SCSTagValid[i])
			u4CmdNeedMaxBufSize += UniCmdSCSTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdSCS = (P_UNI_CMD_SCS_T)pNextHeadBuf;
	pCmdSCS->ubandid = pParamCtrl->ucDbdcIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_SCS_MAX_EVENT; i++) {
		if (pParamCtrl->SCSTagValid[i]) {
			switch (i) {
			case UNI_CMD_SCS_EVENT_SEND_DATA:
				if (UniCmdSCSTab[i].pfHandler != NULL) {
					Ret = ((PFN_SCS_SEND_DATA_HANDLE)(UniCmdSCSTab[i].pfHandler))(pAd, &pParamCtrl->SCSSendData, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdSCSTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_SCS_EVENT_GET_GLO_ADDR:
				if (UniCmdSCSTab[i].pfHandler != NULL) {
					Ret = ((PFN_SCS_GET_GLO_ADDR_CTRL_HANDLE)(UniCmdSCSTab[i].pfHandler))(pAd, &pParamCtrl->SCSGetGloAddrCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdSCSTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_SCS_EVENT_SET_PD_THR_RANGE:
				if (UniCmdSCSTab[i].pfHandler != NULL) {
					Ret = ((PFN_SCS_PD_THR_RANGE_HANDLE)(UniCmdSCSTab[i].pfHandler))(pAd, &pParamCtrl->SCSPDThrRange, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdSCSTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_SCS_EVENT_SCS_ENABLE:
				if (UniCmdSCSTab[i].pfHandler != NULL) {
					Ret = ((PFN_SCS_SMART_CARRIER_ENABLE_HANDLE)(UniCmdSCSTab[i].pfHandler))(pAd, &pParamCtrl->SCSEnable, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdSCSTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_SCS, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdSCSTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_SCS, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdSCSTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_SCS, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SCS);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (pParamCtrl->bQuery) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventSCSHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				if (pParamCtrl->bQuery)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_CHN, CATCHN_SCS, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* SMART_CARRIER_SENSE_SUPPORT */

#ifdef WIFI_MODULE_DVT
INT32 UniCmdMDVT(struct _RTMP_ADAPTER *pAd, UINT16 u2ModuleId, UINT16 u2CaseId, UINT8 u1CapId)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_DVT_CONFIG_T UniCmdDVT;
	UNI_CMD_MDVT_SET_PARA_T UniCmdMDVTSetPara;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_MDVT, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdDVT);
	os_zero_mem(&UniCmdDVT, u4ComCmdSize);
	os_zero_mem(&UniCmdMDVTSetPara, sizeof(UniCmdMDVTSetPara));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdMDVTSetPara);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_DVT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdDVT.ucTestType = UNI_CMD_MODULE_DVT;
	AndesAppendCmdMsg(msg, (char *)&UniCmdDVT, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdMDVTSetPara.u2Tag = UNI_CMD_MDVT_SET_PARA;
	UniCmdMDVTSetPara.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdMDVTSetPara.u2Tag = cpu2le16(UniCmdMDVTSetPara.u2Tag);
	UniCmdMDVTSetPara.u2Length = cpu2le16(UniCmdMDVTSetPara.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdMDVTSetPara.u2ModuleId = cpu2le16(u2ModuleId);
	UniCmdMDVTSetPara.u2CaseId = cpu2le16(u2CaseId);
	UniCmdMDVTSetPara.u1CapId = cpu2le16(u1CapId);

	AndesAppendCmdMsg(msg, (char *)&UniCmdMDVTSetPara, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_MDVT, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}
#endif /* WIFI_MODULE_DVT */

/*****************************************
 *	UNI_CMD_ID_MIB (0x22)
 *****************************************/
INT32 UniCmdMib(struct _RTMP_ADAPTER *pAd, UCHAR ChIdx, RTMP_MIB_PAIR *RegPair, UINT32 Num)
{
	struct cmd_msg 			*msg;
	P_UNI_CMD_MIB_T 		pUniCmdMib = NULL;
	P_UNI_CMD_MIB_DATA_T 	pUniCmdMibData = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	UINT32 					Index;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_MIB_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	u4CmdNeedMaxBufSize += (sizeof(UNI_CMD_MIB_DATA_T) * Num);

	if ((Num >= UNI_CMD_MIB_MAX_PAIR) || (Num == 0)) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"!!!ERROR!!! Num=%u\n", Num);
		ASSERT(0);
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pUniCmdMib = (P_UNI_CMD_MIB_T)pNextHeadBuf;
	pUniCmdMib->ucBand = ChIdx;
	pNextHeadBuf += u4ComCmdSize;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO, "ucBand=%d\n", pUniCmdMib->ucBand);

	/* Step 4: Traverse all regs */
	for (Index = 0; Index < Num; Index++) {
		pUniCmdMibData = (P_UNI_CMD_MIB_DATA_T)pNextHeadBuf;
		pUniCmdMibData->u2Tag = UNI_CMD_MIB_DATA;
		pUniCmdMibData->u2Length = sizeof(UNI_CMD_MIB_DATA_T);
#ifdef CFG_BIG_ENDIAN
		pUniCmdMibData->u2Tag = cpu2le16(pUniCmdMibData->u2Tag);
		pUniCmdMibData->u2Length = cpu2le16(pUniCmdMibData->u2Length);
#endif /* CFG_BIG_ENDIAN */
		pUniCmdMibData->u4Counter = cpu2le32(RegPair[Index].Counter);
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO, "Tag=%d, Length=%d, Counter=%d\n",
				pUniCmdMibData->u2Tag, pUniCmdMibData->u2Length, pUniCmdMibData->u4Counter);
		u2TLVNumber++;
		pNextHeadBuf += sizeof(UNI_CMD_MIB_DATA_T);
	}
	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);


	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}
			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MIB);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, (VOID *)RegPair);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				 /*
				 * leverage the first buffer to record the Total Tag Num
				 * for UniEventMibHandler() sanity
				 */
				RegPair[0].Counter = u2TLVNumber;
				SET_CMD_ATTR_RSP_HANDLER(attr, UniEventMibHandler);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef CONFIG_HW_HAL_OFFLOAD
/*****************************************
 *	UNI_CMD_ID_SNIFFER_MODE (0x24) // Sniffer Mode
 *****************************************/
INT32 UniCmdSetSnifferMode(struct _RTMP_ADAPTER *pAd, struct _EXT_CMD_SNIFFER_MODE_T param)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UNI_CMD_SNIFFER_MODE_T UniCmdSnifferMode;
	UNI_CMD_SNIFFER_MODE_ENABLE_T UniCmdSnifferModeEnable;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(UniCmdSnifferMode);
	os_zero_mem(&UniCmdSnifferMode, u4ComCmdSize);
	os_zero_mem(&UniCmdSnifferModeEnable, sizeof(UniCmdSnifferModeEnable));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UniCmdSnifferModeEnable);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SNIFFER_MODE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	UniCmdSnifferMode.ucBandIdx = param.ucDbdcIdx;
	AndesAppendCmdMsg(msg, (char *)&UniCmdSnifferMode, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	UniCmdSnifferModeEnable.u2Tag = UNI_CMD_SNIFFER_MODE_ENABLE;
	UniCmdSnifferModeEnable.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	UniCmdSnifferModeEnable.u2Tag = cpu2le16(UniCmdSnifferModeEnable.u2Tag);
	UniCmdSnifferModeEnable.u2Length = cpu2le16(UniCmdSnifferModeEnable.u2Length);
#endif /* CFG_BIG_ENDIAN */
	UniCmdSnifferModeEnable.ucSNEnable = param.ucSnifferEn;

	AndesAppendCmdMsg(msg, (char *)&UniCmdSnifferModeEnable, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;
}
#endif /* CONFIG_HW_HAL_OFFLOAD */

#ifdef WIFI_GPIO_CTRL
static INT32 UniCmdGPIOEnable(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_GPIO_ENABLE_T pParam, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_GPIO_ENABLE_T pGpioEnable = (P_UNI_CMD_GPIO_ENABLE_T)pHandle;

	pGpioEnable->u2Tag = UNI_CMD_GPIO_ENABLE;
	pGpioEnable->u2Length = sizeof(UNI_CMD_GPIO_ENABLE_T);
#ifdef CFG_BIG_ENDIAN
	pGpioEnable->u2Tag = cpu2le16(pGpioEnable->u2Tag);
	pGpioEnable->u2Length = cpu2le16(pGpioEnable->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pGpioEnable->fgEnable = pParam->fgEnable;

	return Ret;
}

static INT32 UniCmdGPIOSetValue(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_GPIO_SET_VALUE_T pParam, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_GPIO_SET_VALUE_T pGpioSetValue = (P_UNI_CMD_GPIO_SET_VALUE_T)pHandle;

	pGpioSetValue->u2Tag = UNI_CMD_GPIO_SET_VALUE;
	pGpioSetValue->u2Length = sizeof(UNI_CMD_GPIO_SET_VALUE_T);
#ifdef CFG_BIG_ENDIAN
	pGpioSetValue->u2Tag = cpu2le16(pGpioSetValue->u2Tag);
	pGpioSetValue->u2Length = cpu2le16(pGpioSetValue->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pGpioSetValue->ucGpioValue = pParam->ucGpioValue;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdGPIOTab[UNI_CMD_GPIO_TAG_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_GPIO_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_GPIO_ENABLE_T),
		.pfHandler = UniCmdGPIOEnable
	},
	{
		.u8CmdFeature = UNI_CMD_GPIO_SET_VALUE,
		.u4StructSize = sizeof(UNI_CMD_GPIO_SET_VALUE_T),
		.pfHandler = UniCmdGPIOSetValue
	},
};

INT32 UniCmdGPIO(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_GPIO_CFG_PARAM_T pParamCtrl)
{
	struct cmd_msg          *msg = NULL;
	INT32                   Ret = NDIS_STATUS_SUCCESS;
	UINT32                  i = 0;
	UINT16                  u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_GPIO_CONFIG_T	pCmdGpioCfg = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_GPIO_CONFIG_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_GPIO_TAG_MAX_NUM; i++) {
		if (pParamCtrl->GpioCfgValid[i])
			u4CmdNeedMaxBufSize += UniCmdGPIOTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdGpioCfg = (P_UNI_CMD_GPIO_CONFIG_T)pNextHeadBuf;
	pCmdGpioCfg->ucGpioIdx = pParamCtrl->ucGpioIdx;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_GPIO_TAG_MAX_NUM; i++) {
		if (pParamCtrl->GpioCfgValid[i]) {
			switch (i) {
			case UNI_CMD_GPIO_ENABLE:
				if (UniCmdGPIOTab[i].pfHandler != NULL) {
					Ret = ((PFN_GPIO_ENABLE_HANDLE)(UniCmdGPIOTab[i].pfHandler))(pAd, &pParamCtrl->GpioEnable, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdGPIOTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_GPIO_SET_VALUE:
				if (UniCmdWsysCfgTab[i].pfHandler != NULL) {
					Ret = ((PFN_GPIO_SET_VALUE_HANDLE)(UniCmdGPIOTab[i].pfHandler))(pAd, &pParamCtrl->GpioSetValue, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdGPIOTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdGPIOTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdGPIOTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}
			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_GPIO);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* WIFI_GPIO_CTRL */

INT32 UniCmdEepromAccessRead(
	struct _RTMP_ADAPTER *pAd,
	UINT32 offset,
	UINT8  *pData,
	PUINT pIsValid,
	UINT32 DataLen
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_ACCESS_EEPROM *prCmdAccessEeprom;
	struct EEPROM_ACCESS_DATA_T eepromAccessData;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EEPROM_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ACCESS_EEPROM);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ACCESS_EEPROM */
	prCmdAccessEeprom = (struct UNI_CMD_ACCESS_EEPROM *) pNextHeadBuf;
	prCmdAccessEeprom->u2Tag = cpu2le16(UNI_CMD_ID_EEPROM_ACCESS);
	prCmdAccessEeprom->u2Length = cpu2le16(sizeof(struct UNI_CMD_ACCESS_EEPROM));
	os_zero_mem(&eepromAccessData, sizeof(eepromAccessData));
	eepromAccessData.pValue = (PUSHORT)pData;
	eepromAccessData.pIsValid = pIsValid;
	prCmdAccessEeprom->u4Address = offset;
	prCmdAccessEeprom->u4DataLen = DataLen;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EEPROM_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, &eepromAccessData);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EEPROM_ACCESS_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEepromHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdEepromAccessWrite(
	struct _RTMP_ADAPTER *pAd,
	UINT32 offset,
	UINT8  *pData,
	UINT32 DataLen
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_ACCESS_EEPROM *prCmdAccessEeprom;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EEPROM_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ACCESS_EEPROM);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ACCESS_EEPROM */
	prCmdAccessEeprom = (struct UNI_CMD_ACCESS_EEPROM *) pNextHeadBuf;
	prCmdAccessEeprom->u2Tag = cpu2le16(UNI_CMD_ID_EEPROM_ACCESS);
	prCmdAccessEeprom->u2Length = cpu2le16(sizeof(struct UNI_CMD_ACCESS_EEPROM));
	os_move_mem(&(prCmdAccessEeprom->aucData[0]), &(pData[0]), DataLen);
	prCmdAccessEeprom->u4Address = offset;
	prCmdAccessEeprom->u4DataLen = DataLen;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EEPROM_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EEPROM_ACCESS_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEepromAccessWrite);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEfuseAccessRead(
	struct _RTMP_ADAPTER *pAd,
	UINT16 offset,
	UINT8  *pData,
	PUINT pIsValid
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_ACCESS_EFUSE *prCmdAccessEfuse;
	EFUSE_ACCESS_DATA_T efuseAccessData;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EFUSE_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ACCESS_EFUSE);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ACCESS_EFUSE */
	prCmdAccessEfuse = (struct UNI_CMD_ACCESS_EFUSE *) pNextHeadBuf;
	prCmdAccessEfuse->u2Tag = cpu2le16(UNI_CMD_ID_EFUSE_ACCESS);
	prCmdAccessEfuse->u2Length = cpu2le16(sizeof(struct UNI_CMD_ACCESS_EFUSE));
	os_zero_mem(&efuseAccessData, sizeof(efuseAccessData));
	efuseAccessData.pValue = (PUSHORT)pData;
	efuseAccessData.pIsValid = pIsValid;
	prCmdAccessEfuse->u4Address = cpu2le32((offset / EFUSE_BLOCK_SIZE) * EFUSE_BLOCK_SIZE);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EFUSE_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, &efuseAccessData);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EFUSE_ACCESS_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEffuseHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdEfuseAccessWrite(
	struct _RTMP_ADAPTER *pAd,
	UINT16 offset,
	UINT8  *pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_ACCESS_EFUSE *prCmdAccessEfuse;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EFUSE_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ACCESS_EFUSE);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ACCESS_EFUSE */
	prCmdAccessEfuse = (struct UNI_CMD_ACCESS_EFUSE *) pNextHeadBuf;
	prCmdAccessEfuse->u2Tag = cpu2le16(UNI_CMD_ID_EFUSE_ACCESS);
	prCmdAccessEfuse->u2Length = cpu2le16(sizeof(struct UNI_CMD_ACCESS_EFUSE));
	os_move_mem(&(prCmdAccessEfuse->aucData[0]), &(pData[0]), EFUSE_BLOCK_SIZE);
	prCmdAccessEfuse->u4Address = cpu2le32((offset / EFUSE_BLOCK_SIZE) * EFUSE_BLOCK_SIZE);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EFUSE_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EFUSE_ACCESS_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEfuseAccessWrite);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEfuseFreeBlockCount(
	struct _RTMP_ADAPTER *pAd,
	PVOID pGetFreeBlock,
	PVOID pResult
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	UINT8  Version = 0;
	struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	struct UNI_CMD_EFUSE_FREE_BLOCK *prCmdEfuseFreeBlock;
	struct _EXT_CMD_EFUSE_FREE_BLOCK_T *pCmdFreeBlock = (struct _EXT_CMD_EFUSE_FREE_BLOCK_T *)pGetFreeBlock;

	Version = pCmdFreeBlock->ucVersion;


	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EFUSE_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EFUSE_FREE_BLOCK);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ID_EFUSE_FREE_BLOCK */
	prCmdEfuseFreeBlock = (struct UNI_CMD_EFUSE_FREE_BLOCK *) pNextHeadBuf;
	prCmdEfuseFreeBlock->u2Tag = cpu2le16(UNI_CMD_ID_EFUSE_FREE_BLOCK);
	prCmdEfuseFreeBlock->u2Length = cpu2le16(sizeof(struct UNI_CMD_EFUSE_FREE_BLOCK));

	if (Version == 0) {
		UINT8 *FreeBlock = pGetFreeBlock;

		prCmdEfuseFreeBlock->ucGetFreeBlock = *FreeBlock;

	} else if (Version == 1 || Version == 2) {
		prCmdEfuseFreeBlock->ucVersion = pCmdFreeBlock->ucVersion;
		prCmdEfuseFreeBlock->ucDieIndex = pCmdFreeBlock->ucDieIndex;

		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
				"Version = %x  DieIndex:%d\n",
				prCmdEfuseFreeBlock->ucVersion, prCmdEfuseFreeBlock->ucDieIndex);
	}

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EFUSE_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pResult);

	if (Version == 0) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	} else if (Version == 1) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EFUSE_FREE_BLOCK_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEffuseHandleEvent);
	} else if (Version == 2) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EFUSE_FREE_BLOCK_T)
			* cap->efuse_total_bank_num);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEfuseHandleEventV2);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEfuseBufferModeSet(
	struct _RTMP_ADAPTER *pAd,
	UINT8  EepromType
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0, cmd_size = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_EFUSE_BUFFER_MODE *prCmdEfuseBufferMode;
	union _EXT_CMD_EFUSE_BUFFER_MODE_T *CmdEfuseBufferMode = NULL;

	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
	struct _RTMP_CHIP_OP *ops = hc_get_chip_ops(pAd->hdev_ctrl);
	UINT8  total_seq = 0, cmd_seq = 0;

	if ((cap == NULL) || (ops == NULL)) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_ERROR,
				"Invalid data!\n");
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EFUSE_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EFUSE_BUFFER_MODE) + (sizeof(UCHAR) * EEPROM_BUFFER_MODE_DATA_LIMIT);

	cmd_size = sizeof(union _EXT_CMD_EFUSE_BUFFER_MODE_T);
	cmd_size += sizeof(UCHAR) * EEPROM_BUFFER_MODE_DATA_LIMIT;

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_alloc_mem(pAd, (UCHAR **)&CmdEfuseBufferMode, cmd_size);
	if (!CmdEfuseBufferMode) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ID_EFUSE_BUFFER_MODE */
	prCmdEfuseBufferMode = (struct UNI_CMD_EFUSE_BUFFER_MODE *) pNextHeadBuf;
	prCmdEfuseBufferMode->u2Tag = cpu2le16(UNI_CMD_ID_EFUSE_BUFFER_MODE);
	prCmdEfuseBufferMode->u2Length = cpu2le16(sizeof(struct UNI_CMD_EFUSE_BUFFER_MODE) + (sizeof(UCHAR) * EEPROM_BUFFER_MODE_DATA_LIMIT));

	if (EepromType == EEPROM_EFUSE)
		total_seq = 1;
	else if (EepromType == EEPROM_FLASH) {
		total_seq = cap->EFUSE_BUFFER_CONTENT_SIZE / EEPROM_BUFFER_MODE_DATA_LIMIT;
		if ((cap->EFUSE_BUFFER_CONTENT_SIZE % EEPROM_BUFFER_MODE_DATA_LIMIT) != 0)
			total_seq++;
	}

	for (cmd_seq = 0; cmd_seq < total_seq; cmd_seq++) {

		/* Step 4: Send data packet*/
		msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
		if (!msg) {
			Ret = NDIS_STATUS_RESOURCES;
			goto error;
		}

		SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
		SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EFUSE_CONTROL);
		SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 60000);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

		AndesInitCmdMsg(msg, attr);
		os_zero_mem(CmdEfuseBufferMode, cmd_size);

		if (ops->ee_gen_cmd) {
			Ret = ops->ee_gen_cmd(pAd, (VOID *)CmdEfuseBufferMode, cmd_seq, total_seq);
			if (Ret != NDIS_STATUS_SUCCESS) {
				MTWF_DBG(pAd, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_ERROR,
						"The return value is wrong!\n");
				goto error;
			}
		} else {
			MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_WARN,
				"invalid apply ops, dismissed!\n");
			goto error;
		}

		prCmdEfuseBufferMode->ucSourceMode = CmdEfuseBufferMode->v2.ucSourceMode;
		prCmdEfuseBufferMode->ucContentFormat = CmdEfuseBufferMode->v2.ucContentFormat;
		prCmdEfuseBufferMode->u2Count = cpu2le16(CmdEfuseBufferMode->v2.ucCount);

		os_move_mem(&(prCmdEfuseBufferMode->BinContent[0]), &(CmdEfuseBufferMode->v2.BinContent[0]), EEPROM_BUFFER_MODE_DATA_LIMIT);
		msg->seq = AndesGetCmdMsgSeq(pAd);

		/* Append this feature */
		AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

		Ret = chip_cmd_tx(pAd, msg);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	if (CmdEfuseBufferMode)
		os_free_mem(CmdEfuseBufferMode);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEfusBufferModeGet(
	struct _RTMP_ADAPTER *pAd,
	UINT8  EepromType,
	UINT16 dump_offset,
	UINT16 dump_size,
	UINT8  *epprom_content
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_EFUSE_BUFFER_MODE_READ *prUniCmdTlv;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EFUSE_CONTROL);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prUniCmdTlv);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ID_EFUSE_BUFFER_RD */
	prUniCmdTlv = (struct UNI_CMD_EFUSE_BUFFER_MODE_READ *) pNextHeadBuf;
	prUniCmdTlv->u2Tag = cpu2le16(UNI_CMD_ID_EFUSE_BUFFER_RD);
	prUniCmdTlv->u2Length = cpu2le16(sizeof(*prUniCmdTlv));

	switch (EepromType) {
	case EEPROM_EFUSE:
		prUniCmdTlv->u1SourceMode = EEPROM_MODE_EFUSE;
		prUniCmdTlv->u2Offset = cpu2le16(dump_offset);
		prUniCmdTlv->u2Count = cpu2le16(dump_size);
		break;
	case EEPROM_FLASH:
		prUniCmdTlv->u1SourceMode = EEPROM_MODE_BUFFER;
		prUniCmdTlv->u2Offset = cpu2le16(dump_offset);
		prUniCmdTlv->u2Count = cpu2le16(dump_size);
		break;
	default:
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EFUSE_CONTROL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 60000);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, epprom_content);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_EFUSE_BUFFER_MODE_READ_T) + prUniCmdTlv->u2Count);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEffuseHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EFUSE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

UINT8 getHWSupportByChip(struct _RTMP_ADAPTER *pAd)
{
#ifdef DOT11_EHT_BE
	struct hdev_ctrl *ctrl = pAd->hdev_ctrl;
	RTMP_CHIP_CAP *chip_cap = hc_get_chip_cap(ctrl);

	if (chip_cap->phy_caps & fPHY_CAP_EHT)
		return UNI_HW_CHIP_SUPP_EHT;
#endif /* DOT11_EHT_BE */

	return UNI_HW_CHIP_SUPP_HE;
}


INT32 UniCmdGetRuRaInfo(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg)

{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_RA_GET_RU_RA_INFO_T *prRaRuInfo;
	PCHAR pch = NULL;
	PCHAR pWlanIdx = NULL;
	PCHAR pRuIdx = NULL;
	PCHAR pDirection = NULL;
	PCHAR pDumpGroup = NULL;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pWlanIdx = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if  (pch != NULL)
		pRuIdx = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pDirection = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "");
	if (pch != NULL)
		pDumpGroup = pch;
	else {
		Ret = 0;
		goto error;
	}



	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RA_GET_RU_RA_INFO_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters */

	prRaRuInfo = (struct UNI_CMD_RA_GET_RU_RA_INFO_T *)pNextHeadBuf;
	/* Fill TLV format */
	prRaRuInfo->u2Tag = cpu2le16(UNI_CMD_RA_GET_RU_RA_INFO);
	prRaRuInfo->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_GET_RU_RA_INFO_T));

	prRaRuInfo->u2WlanIdx = (UINT16)os_str_tol(pWlanIdx, 0, 10);
	prRaRuInfo->u2RuIdx = (UINT16)os_str_tol(pRuIdx, 0, 10);
	prRaRuInfo->u2Direction = (UINT16)os_str_tol(pDirection, 0, 10);
	prRaRuInfo->u2DumpGroup = (UINT16)os_str_tol(pDumpGroup, 0, 10);

#ifdef CFG_BIG_ENDIAN
	prRaRuInfo->u2WlanIdx = cpu2le16(prRaRuInfo->u2WlanIdx);
	prRaRuInfo->u2RuIdx = cpu2le16(prRaRuInfo->u2RuIdx);
	prRaRuInfo->u2Direction = cpu2le16(prRaRuInfo->u2Direction);
	prRaRuInfo->u2DumpGroup = cpu2le16(prRaRuInfo->u2DumpGroup);
#endif

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		"WCID: %d RuIdx: %d Direction: %d DumpGroup: %d\n",
		prRaRuInfo->u2WlanIdx, prRaRuInfo->u2RuIdx, prRaRuInfo->u2Direction, prRaRuInfo->u2DumpGroup);


	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdGetHeraRelatedInfo(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_RA_GET_HERA_RELATED_INFO_T *prHeraInfo = (struct UNI_CMD_RA_GET_HERA_RELATED_INFO_T *)pHandle;

	PCHAR pch = NULL;
	PCHAR pPara1 = NULL;
	PCHAR pPara2 = NULL;
	PCHAR pPara3 = NULL;
	PCHAR pPara4 = NULL;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pPara1 = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if  (pch != NULL)
		pPara2 = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pPara3 = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "");
	if (pch != NULL)
		pPara4 = pch;
	else {
		Ret = 0;
		goto error;
	}

	/* Fill TLV format */
	prHeraInfo->u2Tag = cpu2le16(UNI_CMD_RA_GET_HERA_RELATED_INFO);
	prHeraInfo->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_GET_HERA_RELATED_INFO_T));

	prHeraInfo->u2Para1 = (UINT16)os_str_tol(pPara1, 0, 10);
	prHeraInfo->u2Para2 = (UINT16)os_str_tol(pPara2, 0, 10);
	prHeraInfo->u2Para3 = (UINT16)os_str_tol(pPara3, 0, 10);
	prHeraInfo->u2Para4 = (UINT16)os_str_tol(pPara4, 0, 10);

#ifdef CFG_BIG_ENDIAN
	prHeraInfo->u2Para1 = cpu2le16(prHeraInfo->u2Para1);
	prHeraInfo->u2Para2 = cpu2le16(prHeraInfo->u2Para2);
	prHeraInfo->u2Para3 = cpu2le16(prHeraInfo->u2Para3);
	prHeraInfo->u2Para4 = cpu2le16(prHeraInfo->u2Para4);
#endif

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
				"Para1: %d Para2: %d Para3: %d Para4: %d\n",
				prHeraInfo->u2Para1, prHeraInfo->u2Para2, prHeraInfo->u2Para3, prHeraInfo->u2Para4);
error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdSetHeraStbcPriorityCtrl(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_RA_HERA_STBC_PRIORITY_T *prStbcPriority = (struct UNI_CMD_RA_HERA_STBC_PRIORITY_T *)pHandle;

	P_CMD_HERA_STBC_PRIORITY_T prHeraStbcPriority;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	prHeraStbcPriority = (P_CMD_HERA_STBC_PRIORITY_T)arg;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"u1BandIdx=%u, u1Operation=%u, u1StbcPriority=%u\n",
			prHeraStbcPriority->u1BandIdx,
			prHeraStbcPriority->u1Operation,
			prHeraStbcPriority->u1StbcPriority);


	/* Fill TLV format */
	prStbcPriority->u2Tag = cpu2le16(UNI_CMD_RA_HERA_STBC_PRIORITY);
	prStbcPriority->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_HERA_STBC_PRIORITY_T));

	prStbcPriority->u1BandIdx = prHeraStbcPriority->u1BandIdx;
	prStbcPriority->u1Operation = prHeraStbcPriority->u1Operation;
	prStbcPriority->u1StbcPriority = prHeraStbcPriority->u1StbcPriority;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdHeraSetUseVhtRateFor2G(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_RA_SET_VHT_RATE_FOR_2G_T *prParam = (struct UNI_CMD_RA_SET_VHT_RATE_FOR_2G_T *)pHandle;

	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_SET_VHT_RATE_FOR_2G);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_SET_VHT_RATE_FOR_2G_T));
	prParam->fgUseVhtRateFor2G = pAd->CommonCfg.bUseVhtRateFor2g;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			 "Use VHT Rate for 2G = %d\n",
			 prParam->fgUseVhtRateFor2G);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdSetHeraVht1024QamSupportCtrl(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_RA_SET_VHT_1024_QAM_T *prHeraSetVht1024Qam = (struct UNI_CMD_RA_SET_VHT_1024_QAM_T *)pHandle;

	/* Fill TLV format */
	prHeraSetVht1024Qam->u2Tag = cpu2le16(UNI_CMD_RA_SET_VHT_1024_QAM);
	prHeraSetVht1024Qam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_SET_VHT_1024_QAM_T));
	prHeraSetVht1024Qam->fgVht1024QamSupport = pAd->CommonCfg.vht_1024_qam;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"Vht1024QamSupport=%u\n",
			prHeraSetVht1024Qam->fgVht1024QamSupport);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdSetHeraMuInitRateIntervalCtrl(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PCHAR pch = NULL;
	struct UNI_CMD_RA_CFG_MU_INIT_RATE_INTV_T *prParam = (struct UNI_CMD_RA_CFG_MU_INIT_RATE_INTV_T *)pHandle;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	os_zero_mem(prParam, sizeof(struct UNI_CMD_RA_CFG_MU_INIT_RATE_INTV_T));

	pch = strsep(&arg, "");
	if (pch != NULL) {
		prParam->u1IntvInUnit50Ms = os_str_toul(pch, 0, 10);
	} else {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Empty u1IntvInUnit50Ms !!\n");
		Ret = 0;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"u1IntvInUnit50Ms:%d !!\n",
			prParam->u1IntvInUnit50Ms);

	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_CFG_MU_INIT_RATE_INTV);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_CFG_MU_INIT_RATE_INTV_T));

error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdHeraSetMaxPhyRate(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PUINT16 pu2MaxPhyRate;
	struct UNI_CMD_RA_SET_MAX_PHY_RATE_T *prParam = (struct UNI_CMD_RA_SET_MAX_PHY_RATE_T *)pHandle;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	pu2MaxPhyRate = (PUINT16)arg;

	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_SET_MAX_PHY_RATE);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_SET_MAX_PHY_RATE_T));
	prParam->u2MaxPhyRate = cpu2le16(*pu2MaxPhyRate);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		 "Max Phy rate = %d\n", prParam->u2MaxPhyRate);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdSetRAOption(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PCHAR pChOption = NULL;
	PCHAR pChValue = NULL;
	struct UNI_CMD_RA_RA_OPTION_CTRL_T *prParam = (struct UNI_CMD_RA_RA_OPTION_CTRL_T *)pHandle;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}
	pChOption = strsep(&arg, ":");
	pChValue = strsep(&arg, ":");
	if ((pChOption == NULL) || (pChValue == NULL)) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"Parameter format: [Option]:[Value]\n");
		return FALSE;
	}
	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_OPTION_CTRL);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_RA_OPTION_CTRL_T));
	prParam->u1Value = os_str_tol(pChValue, 0, 10);
	prParam->u1OptionType = os_str_tol(pChOption, 0, 10);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"Option=%d, Value=%d\n", prParam->u1OptionType, prParam->u1Value);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n",  Ret);

	return Ret;
}

INT32 UniCmdHeraDbgCtrl(IN PRTMP_ADAPTER pAd, UINT8 param_num, UINT32 *param)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_RA_DBG_CTRL_T *prDbgCtrl;
	UINT8 i;

	MTWF_PRINT("param_num: %d\n", param_num);
	MTWF_PRINT("param:");

	for (i = 0; i < 20; i++)
		MTWF_PRINT(" %d", *(param + i));

	MTWF_PRINT("\n");

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RA_DBG_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters */
	prDbgCtrl = (struct UNI_CMD_RA_DBG_CTRL_T *) pNextHeadBuf;
	prDbgCtrl->u2Tag = cpu2le16(UNI_CMD_RA_DBG_CTRL);
	prDbgCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_DBG_CTRL_T));
	prDbgCtrl->u1RateCtrlFormatId = RA_DBG_CTRL;
	prDbgCtrl->u1ParamNum = param_num;
	for (i = 0 ; i < 20; i++)
		prDbgCtrl->u4Param[i] = *(param + i);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdHeraSupportRateTable(
	IN PRTMP_ADAPTER pAd,
	UINT8 tx_mode,
	UINT8 tx_nss,
	UINT8 tx_bw,
	UINT16 mcs_cap,
	BOOLEAN set
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_RA_SUPPORT_MCS_CAP_CTRL_T *prParam;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"tx_mode: %d, tx_nss: %d, tx_bw: %d, mcs_cap: %d, set: %d\n",
		tx_mode, tx_nss, tx_bw, mcs_cap, set);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RA_SUPPORT_MCS_CAP_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters */
	prParam = (struct UNI_CMD_RA_SUPPORT_MCS_CAP_CTRL_T *) pNextHeadBuf;
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_SUPPORT_MCS_CAP_CTRL);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_SUPPORT_MCS_CAP_CTRL_T));
	prParam->u1RateCtrlFormatId = SUPPORT_RATE_MCS_CAP_CTRL;
	prParam->u1TxMode = tx_mode;
	prParam->u1TxNss = tx_nss;
	prParam->u1TxBw = tx_bw;
	prParam->u2McsCap = cpu2le16(mcs_cap);
	prParam->u1Set = set;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);

	if (set) {
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	} else {
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	}
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdRAFixRateUpdateWoSta(
	IN PRTMP_ADAPTER pAd,
	UINT16 u2Wcid,
	RA_PHY_CFG_T *pFixedRateCfg,
	UINT8 u1SpeEn,
	UINT8 u1ShortPreamble)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_RA_FIX_RATE_WO_STA_UPDATE_T *prParam;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RA_FIX_RATE_WO_STA_UPDATE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters */
	prParam = (struct UNI_CMD_RA_FIX_RATE_WO_STA_UPDATE_T *) pNextHeadBuf;
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_FIX_RATE_WO_STA_UPDATE);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_FIX_RATE_WO_STA_UPDATE_T));

	prParam->MODE = pFixedRateCfg->MODE;
	prParam->Flags = pFixedRateCfg->Flags;
	prParam->STBC = pFixedRateCfg->STBC;
	prParam->ShortGI = pFixedRateCfg->ShortGI;
	prParam->BW = pFixedRateCfg->BW;
	prParam->ldpc = pFixedRateCfg->ldpc;
	prParam->MCS = pFixedRateCfg->MCS;
	prParam->VhtNss = pFixedRateCfg->VhtNss;
	prParam->HeLtf = pFixedRateCfg->he_ltf;
	prParam->u1ShortPreamble = u1ShortPreamble;
	prParam->u1SpeEn = u1SpeEn;
	WCID_SET_H_L(prParam->u1WlanIdxL, prParam->u1WlanIdxHnVer, u2Wcid);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdHeraGetAllStaStats(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_RA_GET_TX_RATE_T *prParam = (struct UNI_CMD_RA_GET_TX_RATE_T *)pHandle;
	PUINT8 pu1EventType;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	pu1EventType = (PUINT8)arg;
	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_GET_TX_RATE);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_GET_TX_RATE_T));
	prParam->u1EventType = *pu1EventType;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdHeraProtectionPerPpduDis(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PCHAR pch = NULL;
	struct UNI_CMD_RA_CFG_PTEC_PER_PPDU_T *prParam = (struct UNI_CMD_RA_CFG_PTEC_PER_PPDU_T *)pHandle;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	os_zero_mem(prParam, sizeof(struct UNI_CMD_RA_CFG_PTEC_PER_PPDU_T));

	pch = strsep(&arg, ":");

	if (pch != NULL) {
		prParam->u1BandIdx = os_str_toul(pch, 0, 10);
		/* sanity check for Band index */
		if (prParam->u1BandIdx >= CFG_WIFI_RAM_BAND_NUM) {
			MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Invalid Band Index !!\n");
			Ret = 0;
			goto error;
		}
	} else {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Invalid Band Index !!\n");
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "");
	if (pch != NULL) {
		prParam->fgPtecPerPpduDis = os_str_toul(pch, 0, 10) ? 1 : 0;
	} else {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Empty ProtectionPerPpduDis !!\n");
		Ret = 0;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"BandIdx:%d ProtectionPerPpduDis:%d !!\n",
			prParam->u1BandIdx, prParam->fgPtecPerPpduDis);

	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_CFG_PTEC_PER_PPDU);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_CFG_PTEC_PER_PPDU_T));

error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d\n", Ret);

	return Ret;
}

static INT32 UniCmdSetHeraMuDisableSwitchSu(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PCHAR pch = NULL;
	struct UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU_T *prParam = (struct UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU_T *)pHandle;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	os_zero_mem(prParam, sizeof(struct UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU_T));

	pch = strsep(&arg, "");
	if (pch != NULL) {
		prParam->fgDisSwitchSU = os_str_toul(pch, 0, 10) ? 1 : 0;
	} else {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Empty fgDisSwitchSU !!\n");
		Ret = 0;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"fgDisSwitchSU:%d !!\n",
			prParam->fgDisSwitchSU);
	/* Fill TLV format */
	prParam->u2Tag = cpu2le16(UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU);
	prParam->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU_T));

error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d\n", Ret);

	return Ret;
}

INT32 UniCmdGetMuRaInfo(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg)

{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_RA_GET_MU_RA_INFO_T *prRaMuInfo;
	PCHAR pch = NULL;
	PCHAR pMuGroupIdx = NULL;
	PCHAR pUserIdx = NULL;
	PCHAR pDirection = NULL;
	PCHAR pDumpGroup = NULL;

	if (!arg) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "Null Parameters\n");
		return FALSE;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pMuGroupIdx = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if  (pch != NULL)
		pUserIdx = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL)
		pDirection = pch;
	else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "");
	if (pch != NULL)
		pDumpGroup = pch;
	else {
		Ret = 0;
		goto error;
	}


	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RA_GET_MU_RA_INFO_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters */

	prRaMuInfo = (struct UNI_CMD_RA_GET_MU_RA_INFO_T *)pNextHeadBuf;
	/* Fill TLV format */
	prRaMuInfo->u2Tag = cpu2le16(UNI_CMD_RA_GET_MU_RA_INFO);
	prRaMuInfo->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_GET_MU_RA_INFO_T));

	prRaMuInfo->u2MuGroupIdx = (UINT16)os_str_tol(pMuGroupIdx, 0, 10);
	prRaMuInfo->u2UserIdx = (UINT16)os_str_tol(pUserIdx, 0, 10);
	prRaMuInfo->u2Direction = (UINT16)os_str_tol(pDirection, 0, 10);
	prRaMuInfo->u2DumpGroup = (UINT16)os_str_tol(pDumpGroup, 0, 10);

#ifdef CFG_BIG_ENDIAN
	prRaMuInfo->u2MuGroupIdx = cpu2le16(prRaMuInfo->u2MuGroupIdx);
	prRaMuInfo->u2UserIdx = cpu2le16(prRaMuInfo->u2UserIdx);
	prRaMuInfo->u2Direction = cpu2le16(prRaMuInfo->u2Direction);
	prRaMuInfo->u2DumpGroup = cpu2le16(prRaMuInfo->u2DumpGroup);
#endif

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		"MuGroupIdx: %d UserIdx: %d Direction: %d DumpGroup: %d\n",
		prRaMuInfo->u2MuGroupIdx, prRaMuInfo->u2UserIdx, prRaMuInfo->u2Direction, prRaMuInfo->u2DumpGroup);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdSetFixedRate(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	UINT8 fgStatus = TRUE;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_RA_SET_FIXED_RATE_T *prRaSetFixedRate = (struct _UNI_CMD_RA_SET_FIXED_RATE_T *)pHandle;
	struct _UNI_CMD_RA_SET_FIXED_RATE_V1 RaFixedRateV1 = {0};
	UINT32 ret;
	INT32 i4Recv = 0;
	UINT32 u4WCID = 0;
	UINT32 u4Mode = 0, u4Bw = 0, u4Mcs = 0, u4VhtNss = 0, u4HeLtf = 0;
	UINT32 u4SGI = 0, u4Preamble = 0, u4STBC = 0, u4LDPC = 0, u4SpeEn = 0;
	struct _MAC_TABLE_ENTRY *pEntry = NULL;
	struct _RTMP_CHIP_CAP *cap;
	UINT8 vhtmaxmcs = (pAd->CommonCfg.vht_1024_qam == TRUE)?11:9;
#ifdef CONFIG_6G_SUPPORT
#ifdef CONFIG_6G_AFC_SUPPORT
	struct wifi_dev *wdev = NULL;
#endif
#endif

	cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Fill TLV format */
	prRaSetFixedRate->u2Tag = cpu2le16(UNI_CMD_RA_SET_FIXED_RATE);
	prRaSetFixedRate->u2Length = cpu2le16(sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_T));
	prRaSetFixedRate->u2Version = cpu2le16(UNI_CMD_RA_FIXED_RATE_VER1);

	if (arg) {
		do {
			i4Recv = sscanf(arg, "%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d", &(u4WCID),
							&(u4Mode), &(u4Bw), &(u4Mcs), &(u4VhtNss), &(u4SGI),
							&(u4Preamble), &(u4STBC), &(u4LDPC), &(u4SpeEn), &(u4HeLtf));
			MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"WCID = %d, Mode = %d, BW = %d, MCS = %d, Nss = %d\n"
				"\t\tSGI = %d, Preamble = %d, STBC = %d, LDPC = %d, SpeEn = %d, HeLtf = %d\n",
				u4WCID, u4Mode, u4Bw, u4Mcs, u4VhtNss,
				u4SGI, u4Preamble, u4STBC, u4LDPC, u4SpeEn, u4HeLtf);

			if (i4Recv != 11) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Format Error!\n");
				fgStatus = FALSE;
				break;
			}
#ifdef CONFIG_6G_SUPPORT
#ifdef CONFIG_6G_AFC_SUPPORT
			wdev = &pAd->ApCfg.MBSSID[0].wdev;
			if (WMODE_CAP_6G(wdev->PhyMode) && is_afc_in_run_state(pAd))
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"DO NOT return when AFC run for BMC WCID\n");
			else {
#endif
#endif
				if (!VALID_UCAST_ENTRY_WCID(pAd, u4WCID)) {
					MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
						"WCID exceed pAd->MaxUcastEntryNum!\n");
					fgStatus = FALSE;
					break;
				}
#ifdef CONFIG_6G_SUPPORT
#ifdef CONFIG_6G_AFC_SUPPORT
			}
#endif
#endif

			if ((u4Mode > MODE_VHT)
#ifdef MLR_SUPPORT
					&& ((u4Mode != HW_PLR_MODE) && (u4Mode != HW_PLRP_MODE))
#endif
					&& ((u4Mode != HW_HE_SU_MODE) && (u4Mode != HW_HE_EXT_SU_MODE))
					&& ((u4Mode != HW_EHT_EXTSU) && (u4Mode != HW_EHT_TRIG)
					&& (u4Mode != HW_EHT_MU))) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Unknown Mode!\n");
				fgStatus = FALSE;
				break;
			}

			if (u4Bw > 4) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Unknown BW!\n");
				fgStatus = FALSE;
				break;
			}

			if (((u4Mode == MODE_CCK) && (u4Mcs > 3)) ||
				((u4Mode == MODE_OFDM) && (u4Mcs > 7)) ||
				((u4Mode == MODE_HTMIX) && (u4Mcs > 32)) ||
				((u4Mode == MODE_VHT) && (u4Mcs > vhtmaxmcs)) ||
				((u4Mode == HW_HE_SU_MODE) && (u4Mcs > 27)) ||
				((u4Mode == HW_EHT_EXTSU) && (u4Mcs > 15)) ||
				((u4Mode == HW_EHT_TRIG) && (u4Mcs > 15)) ||
				((u4Mode == HW_EHT_MU) && (u4Mcs > 15))) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Unknown MCS!\n");
				fgStatus = FALSE;
				break;
			}

			if ((u4Mode == MODE_VHT) && (u4VhtNss > 4)) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Unknown VhtNss!\n");
				fgStatus = FALSE;
				break;
			}

			if ((u4Mode == HW_HE_SU_MODE) && (u4VhtNss > 4)) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Unknown HeNss!\n");
				fgStatus = FALSE;
				break;
			}

			RTMP_SEM_EVENT_WAIT(&pAd->AutoRateLock, ret);
			pEntry = entry_get(pAd, u4WCID);

			os_zero_mem(&RaFixedRateV1, sizeof(RaFixedRateV1));
			RaFixedRateV1.u2WlanIdx = (UINT16)u4WCID;

			if (u4LDPC)
				RaFixedRateV1.u1Ecc = HT_LDPC | VHT_LDPC | HE_LDPC;
			else
				RaFixedRateV1.u1Ecc = 0;

			if (u4Preamble == 0)
				u4Preamble = LONG_PREAMBLE;
			else
				u4Preamble = SHORT_PREAMBLE;

			u4STBC = raStbcSettingCheck(u4STBC, u4Mode, u4Mcs, u4VhtNss, 0, 0);
			pEntry->HTPhyMode.field.MODE = u4Mode;
			pEntry->HTPhyMode.field.iTxBF = 0;
			pEntry->HTPhyMode.field.eTxBF = 0;
			pEntry->HTPhyMode.field.STBC = u4STBC ? 1 : 0;
			pEntry->HTPhyMode.field.ShortGI = u4SGI ? 1 : 0;
			pEntry->HTPhyMode.field.BW = u4Bw;
			pEntry->HTPhyMode.field.ldpc = u4LDPC ? 1 : 0;
#ifdef DOT11_N_SUPPORT
#ifdef DOT11_VHT_AC

			if (u4Mode == MODE_VHT || u4Mode == HW_HE_SU_MODE || u4Mode == HW_HE_EXT_SU_MODE)
				pEntry->HTPhyMode.field.MCS = (((u4VhtNss - 1) & 0x3) << 4) + u4Mcs;
			else
#endif /* DOT11_VHT_AC */
#endif /* DOT11_N_SUPPORT */
			{
				pEntry->HTPhyMode.field.MCS = u4Mcs;
			}

			pEntry->LastTxRate = pEntry->HTPhyMode.word;
			pAd->LastTxRate = pEntry->HTPhyMode.word;
			pEntry->bAutoTxRateSwitch = FALSE;
			RaFixedRateV1.u1PhyMode = (UINT8)u4Mode;
			RaFixedRateV1.u1Stbc = (UINT8)u4STBC;
			RaFixedRateV1.u2ShortGi = (UINT16)u4SGI;
			RaFixedRateV1.u2HeLtf = (UINT16)u4HeLtf;
			RaFixedRateV1.u1Bw = (UINT8)u4Bw;
			RaFixedRateV1.u1Mcs = (UINT8)u4Mcs;
			RaFixedRateV1.u1Nss = (UINT8)u4VhtNss;
			RaFixedRateV1.u1ShortPreamble = (UINT8)u4Preamble;
			RaFixedRateV1.u1Spe = (UINT8)u4SpeEn;

#ifdef CFG_BIG_ENDIAN
			RaFixedRateV1.u2WlanIdx = cpu2le16(RaFixedRateV1.u2WlanIdx);
			RaFixedRateV1.u2ShortGi = cpu2le16(RaFixedRateV1.u2ShortGi);
			RaFixedRateV1.u2HeLtf = cpu2le16(RaFixedRateV1.u2HeLtf);
#endif
			RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
		} while (0);
	}

	memcpy(&(prRaSetFixedRate->aucBuffer[0]), &RaFixedRateV1, sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_V1));

	if (fgStatus == FALSE)
		Ret = NDIS_STATUS_FAILURE;
	else
		asic_dump_wtbl_info(pAd, u4WCID);

	return Ret;
}

static INT32 UniCmdSetFixedRateUl(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	UINT8 fgStatus = TRUE;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_T *prRaSetFixedRateUl = (struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_T *)pHandle;
	struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_V1 RaFixedRateUlV1 = {0};
	UINT32 ret;
	INT32 i4Recv = 0;
	UINT32 u4WCID = 0, u4HeLtf = 0, u4Stbc = 0, u4ShortGi = 0;
	UINT32 u4Mcs = 0, u4Nss = 0, u4Ecc = 0;
	MAC_TABLE_ENTRY *pEntry = NULL;
	struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Fill TLV format */
	prRaSetFixedRateUl->u2Tag = cpu2le16(UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG);
	prRaSetFixedRateUl->u2Length = cpu2le16(sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_T));

	if (arg) {
		do {
			i4Recv = sscanf(arg, "%d-%d-%d-%d-%d-%d-%d", &(u4WCID), &(u4Stbc), &(u4ShortGi),
						&(u4Ecc), &(u4Mcs), &(u4Nss), &(u4HeLtf));

			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
				"WCID = %d, MCS = %d, Nss = %d\n"
				"\t\tSGI = %d, STBC = %d, LDPC = %d, HeLtf = %d\n",
				u4WCID, u4Mcs, u4Nss, u4ShortGi, u4Stbc, u4Ecc, u4HeLtf);

			if (i4Recv != 7) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Format Error!\n");
				fgStatus = FALSE;
				break;
			}

			if (!VALID_UCAST_ENTRY_WCID(pAd, u4WCID)) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
						"WCID exceed pAd->MaxUcastEntryNum!\n");
				fgStatus = FALSE;
				break;
			}

			RTMP_SEM_EVENT_WAIT(&pAd->AutoRateLock, ret);
			pEntry = entry_get(pAd, u4WCID);

			if (IS_ENTRY_NONE(pEntry)) {
				RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
				break;
			}

			RaFixedRateUlV1.u2WlanIdx = (UINT16)u4WCID;
			RaFixedRateUlV1.u1Stbc = (UINT8)u4Stbc;
			RaFixedRateUlV1.u1ShortGi = (UINT8)u4ShortGi;
			RaFixedRateUlV1.u1Ecc = (UINT8)u4Ecc;
			RaFixedRateUlV1.u1Mcs = (UINT8)u4Mcs;
			RaFixedRateUlV1.u1Nss = (UINT8)u4Nss;
			RaFixedRateUlV1.u1HeLtf = (UINT8)u4HeLtf;

#ifdef CFG_BIG_ENDIAN
			RaFixedRateUlV1.u2WlanIdx = cpu2le16(RaFixedRateUlV1.u2WlanIdx);
#endif
			memcpy(&(prRaSetFixedRateUl->aucBuffer[0]), &RaFixedRateUlV1, sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_V1));

			RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
		} while (0);
	}

	if (fgStatus == FALSE)
		Ret = NDIS_STATUS_FAILURE;

	return Ret;
}

static INT32 UniCmdSetAutoRate(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
	UINT8 fgStatus = TRUE;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_RA_SET_AUTO_RATE_T *prRaSetAutoRate = (struct _UNI_CMD_RA_SET_AUTO_RATE_T *)pHandle;
	UINT32 ret;
	INT32 i4Recv = 0;
	UINT32 u4WCID = 0, u4AutoRateEn, u4Mode;
	MAC_TABLE_ENTRY *pEntry = NULL;
	struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Fill TLV format */
	prRaSetAutoRate->u2Tag = cpu2le16(UNI_CMD_RA_SET_AUTO_RATE);
	prRaSetAutoRate->u2Length = cpu2le16(sizeof(struct _UNI_CMD_RA_SET_AUTO_RATE_T));

	if (arg) {
		do {
			i4Recv = sscanf(arg, "%d-%d-%d", &(u4WCID), &(u4AutoRateEn), &(u4Mode));
			MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
				"WCID = %d, AutoRateEn = %d, Mode = %d\n",
				u4WCID, u4AutoRateEn, u4Mode);

			if (i4Recv != 3) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
					"Format Error!\n");
				fgStatus = FALSE;
				break;
			}

			if (!VALID_UCAST_ENTRY_WCID(pAd, u4WCID)) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
						"WCID exceed pAd->MaxUcastEntryNum!\n");
				fgStatus = FALSE;
				break;
			}

			RTMP_SEM_EVENT_WAIT(&pAd->AutoRateLock, ret);
			pEntry = entry_get(pAd, u4WCID);

			if (IS_ENTRY_NONE(pEntry)) {
				RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
				break;
			}

			prRaSetAutoRate->u2WlanIdx = (UINT16)u4WCID;
			prRaSetAutoRate->u1AutoRateEn = (UINT8)u4AutoRateEn;
			prRaSetAutoRate->u1Mode = (UINT8)u4Mode;

#ifdef CFG_BIG_ENDIAN
			prRaSetAutoRate.u2WlanIdx = cpu2le16(prRaSetAutoRate.u2WlanIdx);
#endif
			RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
		} while (0);
	}

	if (fgStatus == FALSE)
		Ret = NDIS_STATUS_FAILURE;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdRATab[UNI_CMD_RA_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_RA_GET_HERA_RELATED_INFO,
		.u4StructSize = sizeof(struct UNI_CMD_RA_GET_HERA_RELATED_INFO_T),
		.pfHandler = UniCmdGetHeraRelatedInfo
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_MAX_PHY_RATE,
		.u4StructSize = sizeof(struct UNI_CMD_RA_SET_MAX_PHY_RATE_T),
		.pfHandler = UniCmdHeraSetMaxPhyRate
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_VHT_RATE_FOR_2G,
		.u4StructSize = sizeof(struct UNI_CMD_RA_SET_VHT_RATE_FOR_2G_T),
		.pfHandler = UniCmdHeraSetUseVhtRateFor2G
	},
	{
		.u8CmdFeature = UNI_CMD_RA_CFG_MU_INIT_RATE_INTV,
		.u4StructSize = sizeof(struct UNI_CMD_RA_CFG_MU_INIT_RATE_INTV_T),
		.pfHandler = UniCmdSetHeraMuInitRateIntervalCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU,
		.u4StructSize = sizeof(struct UNI_CMD_RA_CFG_MU_DIS_SWITCH_SU_T),
		.pfHandler = UniCmdSetHeraMuDisableSwitchSu
	},
	{
		.u8CmdFeature = UNI_CMD_RA_CFG_PTEC_PER_PPDU,
		.u4StructSize = sizeof(struct UNI_CMD_RA_CFG_PTEC_PER_PPDU_T),
		.pfHandler = UniCmdHeraProtectionPerPpduDis
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_VHT_1024_QAM,
		.u4StructSize = sizeof(struct UNI_CMD_RA_SET_VHT_1024_QAM_T),
		.pfHandler = UniCmdSetHeraVht1024QamSupportCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_RA_GET_TX_RATE,
		.u4StructSize = sizeof(struct UNI_CMD_RA_GET_TX_RATE_T),
		.pfHandler = UniCmdHeraGetAllStaStats
	},
	{
		.u8CmdFeature = UNI_CMD_RA_HERA_STBC_PRIORITY,
		.u4StructSize = sizeof(struct UNI_CMD_RA_HERA_STBC_PRIORITY_T),
		.pfHandler = UniCmdSetHeraStbcPriorityCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_RA_OPTION_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_RA_RA_OPTION_CTRL_T),
		.pfHandler = UniCmdSetRAOption
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_FIXED_RATE,
		.u4StructSize = sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_T) +
			sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_V1),
		.pfHandler = UniCmdSetFixedRate
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG,
		.u4StructSize = sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_T) +
			sizeof(struct _UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG_V1),
		.pfHandler = UniCmdSetFixedRateUl
	},
	{
		.u8CmdFeature = UNI_CMD_RA_SET_AUTO_RATE,
		.u4StructSize = sizeof(struct _UNI_CMD_RA_SET_AUTO_RATE_T),
		.pfHandler = UniCmdSetAutoRate
	},
};

INT32 UniCmdRAParameterSet(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg, UINT32 u4EnableFeature)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 ucTLVNumber = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 RATabSize = ARRAY_SIZE(UniCmdRATab);
	struct UNI_CMD_RA *pCmdRaUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RA);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < RATabSize; i++) {
		if (UniCmdRATab[i].u8CmdFeature == u4EnableFeature) {
			u4CmdNeedMaxBufSize += UniCmdRATab[i].u4StructSize;
			break;
		}
	}

	if (i >= RATabSize) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
				"Not support for RA feature input! (0x%x)\n", u4EnableFeature);
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdRaUpdate = (struct UNI_CMD_RA *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Fill params of  supported feature */
	if (UniCmdRATab[i].pfHandler != NULL) {
		Ret = ((PFN_RA_HANDLE)(UniCmdRATab[i].pfHandler))(pAd, arg, pNextHeadBuf);
		if (Ret == NDIS_STATUS_SUCCESS) {
			pNextHeadBuf += UniCmdRATab[i].u4StructSize;
			ucTLVNumber++;
		} else
			goto error;
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		UINT8 bNeedFrag = FALSE;
		UINT8 bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RA);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG, "(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdRAFixedRateProc(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg)
{
	INT32 Ret = TRUE;
	UINT32 u4CmdFeature = UNI_CMD_RA_SET_FIXED_RATE;

	if (arg != NULL)
		UniCmdRAParameterSet(pAd, arg, u4CmdFeature);

	return Ret;
}

INT32 UniCmdRAFixedRateUlProc(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg)
{
	INT32 Ret = TRUE;
	UINT32 u4CmdFeature = UNI_CMD_RA_SET_FIXED_RATE_UL_TRIG;

	if (arg != NULL)
		UniCmdRAParameterSet(pAd, arg, u4CmdFeature);

	return Ret;
}

INT32 UniCmdRAAutoRateProc(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg)
{
	INT32 Ret = TRUE;
	UINT32 u4CmdFeature = UNI_CMD_RA_SET_AUTO_RATE;

	if (arg != NULL)
		UniCmdRAParameterSet(pAd, arg, u4CmdFeature);

	return Ret;
}

INT32 UniCmdWifiSpectrumStart(
	struct _RTMP_ADAPTER *pAd,
	UINT8  *pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	RBIST_CAP_START_T *prRBISTInfo = (RBIST_CAP_START_T *)pData;
	struct UNI_CMD_SET_SPECTRUM_PARAMTER_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SET_SPECTRUM_PARAMTER_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SET_SPECTRUM_PARAMTER*/
	prSpectrumCtrl = (struct UNI_CMD_SET_SPECTRUM_PARAMTER_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_SET_SPECTRUM_PARAMTER);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SET_SPECTRUM_PARAMTER_T));

	/* Update data of pAd */
	pAd->SpectrumCapNode = prRBISTInfo->u4CaptureNode;
	/* Update data structure of SpectrumCtrl */
	prSpectrumCtrl->fgTrigger = cpu2le32(prRBISTInfo->fgTrigger);
	prSpectrumCtrl->fgRingCapEn = cpu2le32(prRBISTInfo->fgRingCapEn);
	prSpectrumCtrl->u4TriggerEvent = cpu2le32(prRBISTInfo->u4TriggerEvent);
	prSpectrumCtrl->u4CaptureNode = cpu2le32(prRBISTInfo->u4CaptureNode);
	prSpectrumCtrl->u4CaptureLen = cpu2le32(prRBISTInfo->u4CaptureLen);
	prSpectrumCtrl->u4CapStopCycle = cpu2le32(prRBISTInfo->u4CapStopCycle);
	prSpectrumCtrl->u4BW = cpu2le32(prRBISTInfo->u4BW);
	prSpectrumCtrl->u4MACTriggerEvent = cpu2le32(prRBISTInfo->u4MACTriggerEvent);
	prSpectrumCtrl->u4SourceAddressLSB = cpu2le32(prRBISTInfo->u4SourceAddressLSB);
	prSpectrumCtrl->u4SourceAddressMSB = cpu2le32(prRBISTInfo->u4SourceAddressMSB);
	prSpectrumCtrl->u4BandIdx = cpu2le32(prRBISTInfo->u4BandIdx);
	prSpectrumCtrl->u4EnBitWidth = cpu2le32(CAP_96_BIT);
	prSpectrumCtrl->u4Architech = cpu2le32(CAP_ON_CHIP);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "\n"
			" prSpectrumCtrl->fgTrigger = 0x%08x\n prSpectrumCtrl->fgRingCapEn = 0x%08x\n"
			" prSpectrumCtrl->u4TriggerEvent = 0x%08x\n prSpectrumCtrl->u4CaptureNode = 0x%08x\n"
			" prSpectrumCtrl->u4CaptureLen = 0x%08x\n prSpectrumCtrl->u4CapStopCycle = 0x%08x\n"
			" prSpectrumCtrl->ucBW = 0x%08x\n prSpectrumCtrl->u4MACTriggerEvent = 0x%08x\n"
			" prSpectrumCtrl->u4SourceAddressLSB = 0x%08x\n prSpectrumCtrl->u4SourceAddressMSB = 0x%08x\n"
			" prSpectrumCtrl->u4BandIdx = 0x%08x\n", prSpectrumCtrl->fgTrigger, prSpectrumCtrl->fgRingCapEn,
			prSpectrumCtrl->u4TriggerEvent, prSpectrumCtrl->u4CaptureNode, prSpectrumCtrl->u4CaptureLen,
			prSpectrumCtrl->u4CapStopCycle, prSpectrumCtrl->u4BW, prSpectrumCtrl->u4MACTriggerEvent,
			prSpectrumCtrl->u4SourceAddressLSB, prSpectrumCtrl->u4SourceAddressMSB, prSpectrumCtrl->u4BandIdx);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdWifiSpectrumCapStatus(
	struct _RTMP_ADAPTER *pAd,
	INT8   *rsp_payload,
	UINT16 rsp_wait_time
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct UNI_CMD_GET_SPECTRUM_STATUS_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_GET_SPECTRUM_STATUS_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_GET_SPECTRUM_STATUS*/
	prSpectrumCtrl = (struct UNI_CMD_GET_SPECTRUM_STATUS_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_GET_SPECTRUM_STATUS);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_GET_SPECTRUM_STATUS_T));

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, rsp_wait_time);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, rsp_payload);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_ID_SPECTRUM_STATUS_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventSpectrumHandler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdSpectrumGetRawData(
	struct _RTMP_ADAPTER *pAd
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct UNI_CMD_GET_SPECTRUM_DATA_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_GET_SPECTRUM_DATA_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_GET_SPECTRUM_DATA*/
	prSpectrumCtrl = (struct UNI_CMD_GET_SPECTRUM_DATA_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_GET_SPECTRUM_DATA);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_GET_SPECTRUM_DATA_T));

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruBsrpCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_BSRP_CTRL_T *pCmdBsrpCtrl = (struct UNI_CMD_MURU_BSRP_CTRL_T *)pHandle;
	PCHAR pch = NULL;
	UINT8 u1Band = 3; /* B0 B1 B2 */
	UINT8 u1BandIdx = 0;

	pCmdBsrpCtrl->u2Tag = UNI_CMD_MURU_BSRP_CTRL;
	pCmdBsrpCtrl->u2Length = sizeof(*pCmdBsrpCtrl);

	pch = strsep(&arg, "-");

	if (pch != NULL) {
		if (os_str_tol(pch, 0, 10))
			pCmdBsrpCtrl->fgExtCmdBsrp = 1;
		else
			pCmdBsrpCtrl->fgExtCmdBsrp = 0;
		MTWF_PRINT("(fgExtCmdBsrp = %u\n",
			pCmdBsrpCtrl->fgExtCmdBsrp);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL) {
		pCmdBsrpCtrl->u1TriggerFlow = os_str_tol(pch, 0, 10);
		MTWF_PRINT("%s:(ucTriggerFlow = %u\n",
			__func__, pCmdBsrpCtrl->u1TriggerFlow);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL) {
		pCmdBsrpCtrl->u2BsrpInterval = os_str_tol(pch, 0, 10);
#ifdef CFG_BIG_ENDIAN
		pCmdBsrpCtrl->u2BsrpInterval = cpu2le16(pCmdBsrpCtrl->u2BsrpInterval);
#endif

		MTWF_PRINT("%s:(ucBsrpInterval = %u\n",
			__func__, pCmdBsrpCtrl->u2BsrpInterval);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL) {
		pCmdBsrpCtrl->u2BsrpRuAlloc = os_str_tol(pch, 0, 10);
#ifdef CFG_BIG_ENDIAN
		pCmdBsrpCtrl->u2BsrpRuAlloc = cpu2le16(pCmdBsrpCtrl->u2BsrpRuAlloc);
#endif

		MTWF_PRINT("%s:(ucBsrpRuAlloc = %u\n",
			__func__, pCmdBsrpCtrl->u2BsrpRuAlloc);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL) {
		pCmdBsrpCtrl->u4TriggerType = os_str_tol(pch, 0, 10);
#ifdef CFG_BIG_ENDIAN
		pCmdBsrpCtrl->u4TriggerType = cpu2le32(pCmdBsrpCtrl->u4TriggerType);
#endif

		MTWF_PRINT("%s:(u4TriggerType = %u\n", __func__, pCmdBsrpCtrl->u4TriggerType);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL && (os_str_tol(pch, 0, 10) < 3)) {
		u1Band = os_str_tol(pch, 0, 10);
		pCmdBsrpCtrl->u1BandBitMap |= BIT(u1Band);
#ifdef CFG_BIG_ENDIAN
		pCmdBsrpCtrl->u1BandBitMap = cpu2le32(pCmdBsrpCtrl->u1BandBitMap);
#endif
		MTWF_PRINT("%s:(u1BandBitMap = %u (Band %u)\n", __func__, pCmdBsrpCtrl->u1BandBitMap, u1Band);
	} else {
		for (u1BandIdx = 0; u1BandIdx < u1Band; u1BandIdx++)
			pCmdBsrpCtrl->u1BandBitMap |= BIT(u1BandIdx);

#ifdef CFG_BIG_ENDIAN
		pCmdBsrpCtrl->u1BandBitMap = cpu2le32(pCmdBsrpCtrl->u1BandBitMap);
#endif
		MTWF_PRINT("%s:(u1BandBitMap = %u (All Band)\n", __func__, pCmdBsrpCtrl->u1BandBitMap);
	}

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetArbOpMode(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_ARB_OP_MODE_T *pCmdMuruArbOpModeCtrl = (struct UNI_CMD_MURU_SET_ARB_OP_MODE_T *)pHandle;
	UINT8 *OpMode = (UINT8 *)arg;

	pCmdMuruArbOpModeCtrl->u1OpMode = *OpMode;
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruArbOpModeCtrl->u1OpMode);

	pCmdMuruArbOpModeCtrl->u2Tag = UNI_CMD_MURU_SET_ARB_OP_MODE;
	pCmdMuruArbOpModeCtrl->u2Length = sizeof(*pCmdMuruArbOpModeCtrl);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetAlgoDbgCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_ALGO_DBG_CTRL_T *pUniCmd = (struct UNI_CMD_MURU_ALGO_DBG_CTRL_T *)pHandle;
	PCHAR pch = NULL;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_ALGO_DBG_CTRL;
	pUniCmd->u2Length = sizeof(*pUniCmd);

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		pUniCmd->u1OpMode = os_str_tol(pch, 0, 10);
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"u1OpMode = %u\n", pUniCmd->u1OpMode);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		pUniCmd->u1Enable = os_str_tol(pch, 0, 10);
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"u1Enable = %u\n", pUniCmd->u1Enable);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		pUniCmd->u2Period = os_str_tol(pch, 0, 10);
#ifdef CFG_BIG_ENDIAN
		pUniCmd->u2Period = cpu2le16(pUniCmd->u2Period);
#endif
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"u2Period = %u\n", pUniCmd->u2Period);
	} else {
		Ret = 0;
		goto error;
	}

error:

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSuTxCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_SUTX_T *pCmdMuruSuTxCtrl = (struct UNI_CMD_MURU_SET_SUTX_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruSuTxCtrl->u1ForceSuTx = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		goto error;
	}
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruSuTxCtrl->u1ForceSuTx);

	pCmdMuruSuTxCtrl->u2Tag = UNI_CMD_MURU_SUTX_CTRL;
	pCmdMuruSuTxCtrl->u2Length = sizeof(*pCmdMuruSuTxCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetFixedRate(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_FIXED_RATE_CTRL_T *pCmdFixedRateCtrl = (struct UNI_CMD_MURU_FIXED_RATE_CTRL_T *)pHandle;

	if (arg != NULL) {
		pCmdFixedRateCtrl->u2Value = os_str_tol(arg, 0, 10);
		MTWF_PRINT("%s:(u2Value = %u\n", __func__, pCmdFixedRateCtrl->u2Value);
	} else {
		Ret = 0;
		goto error;
	}

	pCmdFixedRateCtrl->u2Tag = UNI_CMD_MURU_FIXED_RATE_CTRL;
	pCmdFixedRateCtrl->u2Length = sizeof(*pCmdFixedRateCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef WIFI_MD_COEX_SUPPORT
static INT32 UniCmdIdc(struct _RTMP_ADAPTER *pAd, char *buf, UINT16 bufLen,
							enum _UNI_CMD_IDC_TAG_T u2Tag)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	if (u2Tag >= UNI_CMD_IDC_MAX_NUM) {
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	u4ComCmdSize = sizeof(struct _UNI_CMD_IDC_COMMON_TLV_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + bufLen;

	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);

	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;
	os_move_mem(pNextHeadBuf, buf, bufLen);

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_IDC);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);

	switch (u2Tag) {
	case UNI_CMD_IDC_GET_CHN:
	case UNI_CMD_IDC_GET_INFO:
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniEventIDCRsp);
		break;

	case UNI_CMD_IDC_SET_PWR_BACKOFF:
	case UNI_CMD_IDC_UPDATE_STATE:
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
		break;

	default:
		break;
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	MTWF_DBG(pAd, DBG_CAT_COEX, CATCOEX_MD, DBG_LVL_INFO,
			"pAd:%p, cmd Tag: %d, cmd msg:%p, cmd msg len:%d\n",
			pAd, u2Tag, msg, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdQuerySafeChannel(struct _RTMP_ADAPTER *pAd)
{
	UINT16 u2Tag = UNI_CMD_IDC_GET_CHN;
	UINT16 u2Length = sizeof(struct _UNI_CMD_IDC_GET_CHAN_T);
	struct _UNI_CMD_IDC_GET_CHAN_T prbuffer;

	prbuffer.u2Tag = u2Tag;
	prbuffer.u2Length = u2Length;
#ifdef CFG_BIG_ENDIAN
	prbuffer.u2Tag = cpu2le16(prbuffer->u2Tag);
	prbuffer.u2Length = cpu2le16(prbuffer->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return UniCmdIdc(pAd, (char *)&prbuffer, u2Length, u2Tag);
}

INT32 UniCmdQueryIdcInfo(struct _RTMP_ADAPTER *pAd)
{
	UINT16 u2Tag = UNI_CMD_IDC_GET_INFO;
	UINT16 u2Length = sizeof(struct _UNI_CMD_IDC_GET_INFO_T);
	struct _UNI_CMD_IDC_GET_INFO_T prbuffer;

	prbuffer.u2Tag = u2Tag;
	prbuffer.u2Length = u2Length;
#ifdef CFG_BIG_ENDIAN
	prbuffer.u2Tag = cpu2le16(prbuffer->u2Tag);
	prbuffer.u2Length = cpu2le16(prbuffer->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return UniCmdIdc(pAd, (char *)&prbuffer, u2Length, u2Tag);
}

INT32 UniCmdUpdateIdcState(struct _RTMP_ADAPTER *pAd)
{
	UINT16 u2Tag = UNI_CMD_IDC_UPDATE_STATE;
	UINT16 u2Length = sizeof(struct _UNI_CMD_IDC_SET_STATE_T);
	struct _UNI_CMD_IDC_SET_STATE_T prbuffer;

	prbuffer.u2Tag = u2Tag;
	prbuffer.u2Length = u2Length;
	prbuffer.isIDCen = pAd->idcState;
#ifdef CFG_BIG_ENDIAN
	prbuffer.u2Tag = cpu2le16(prbuffer->u2Tag);
	prbuffer.u2Length = cpu2le16(prbuffer->u2Length);
	prbuffer.isIDCen = cpu2le16(pAd->idcState);
#endif /* CFG_BIG_ENDIAN */

	return UniCmdIdc(pAd, (char *)&prbuffer, u2Length, u2Tag);
}

INT32 UniCmdSetIdcPwrBackoff(struct _RTMP_ADAPTER *pAd, UINT16 maxTxPwrLimit)
{
	UINT16 u2Tag = UNI_CMD_IDC_SET_PWR_BACKOFF;
	UINT16 u2Length = sizeof(struct _UNI_CMD_IDC_SET_PWR_BACKOFF_T);
	struct _UNI_CMD_IDC_SET_PWR_BACKOFF_T prbuffer;

	prbuffer.u2Tag = u2Tag;
	prbuffer.u2Length = u2Length;
	prbuffer.u2MaxTxPwrLimit = maxTxPwrLimit;
	prbuffer.ucBandIdx = hc_get_hw_band_idx(pAd);
	prbuffer.ucReserved = 0;
#ifdef CFG_BIG_ENDIAN
	prbuffer.u2Tag = cpu2le16(prbuffer->u2Tag);
	prbuffer.u2Length = cpu2le16(prbuffer->u2Length);
	prbuffer.u2MaxTxPwrLimit = cpu2le16(prbuffer.u2MaxTxPwrLimit);
	prbuffer.ucBandIdx = cpu2le16(prbuffer.ucBandIdx);
	prbuffer.ucReserved = cpu2le16(prbuffer.ucReserved);
#endif /* CFG_BIG_ENDIAN */

	return UniCmdIdc(pAd, (char *)&prbuffer, u2Length, u2Tag);
}

#endif

#define RUALLOC_BW20 122
#define RUALLOC_BW40 130
#define RUALLOC_BW80 134
#define RUALLOC_BW160 137
#define RUALLOC_BW320 395
#define RUALLOC_TYPE_CHECK_HE(BW) ((BW == RUALLOC_BW20) || (BW == RUALLOC_BW40) || (BW == RUALLOC_BW80) || (BW == RUALLOC_BW160))
#define RUALLOC_TYPE_CHECK_EHT(BW) (RUALLOC_TYPE_CHECK_HE(BW) || (BW == RUALLOC_BW320))
#define MAX_MODBF_EHT 4
#define MAX_MODBF_HE 2
#define MAX_MODBF_VHT 0

static INT32 UniCmdMuruSetFixedGroupRate(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT8 ucNumUser = 0, MaxMcs = 0, McsUsr[4] = {0};
	struct UNI_CMD_MURU_FIXED_GRP_RATE_CTRL_T *pCmdFixedGrpRateCtrl = (struct UNI_CMD_MURU_FIXED_GRP_RATE_CTRL_T *)pHandle;
	UINT16 ucBW = 0;
	UINT32 recvArgNum = 0;

	pCmdFixedGrpRateCtrl->u2Tag = UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL;
	pCmdFixedGrpRateCtrl->u2Length = sizeof(*pCmdFixedGrpRateCtrl);
	pCmdFixedGrpRateCtrl->u1CmdVersion = (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) ? UNI_CMD_MURU_VER_EHT : UNI_CMD_MURU_VER_HE;

	if (pCmdFixedGrpRateCtrl->u1CmdVersion == UNI_CMD_MURU_VER_EHT)
		MaxMcs = UNI_MAX_MCS_SUPPORT_EHT;
	else
		MaxMcs = UNI_MAX_MCS_SUPPORT_HE;

	if (arg != NULL) {
		do {
			recvArgNum = sscanf(arg, "%hhu-%hu-%hhu-%hhu-%hhu-%hu-%hhu-%hu-%hhu-%hu-%hhu-%hu-%hhu", &ucNumUser, &ucBW,
				&(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1GI), &(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Capability),
				&(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul), &(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u2WlidUser0),
				&McsUsr[0], &(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u2WlidUser1),
				&McsUsr[1], &(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u2WlidUser2),
				&McsUsr[2], &(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u2WlidUser3),
				&McsUsr[3]);

			if (recvArgNum != (5 + 2*ucNumUser)) {
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
					"u1NumUser = %u, recvArgNum = %u\n", ucNumUser, recvArgNum);
				goto error;
			}

			if ((ucNumUser > 0) && (ucNumUser < 5))
				pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1NumUser = ucNumUser - 1;
			else
				goto error;

			/* Prarameter check*/
			if (pCmdFixedGrpRateCtrl->u1CmdVersion != UNI_CMD_MURU_VER_EHT) {
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Capability > MAX_MODBF_HE) ||
					(ucBW == RUALLOC_BW320))
					goto error;
			} else {
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Capability <= MAX_MODBF_HE) &&
					(ucBW == RUALLOC_BW320))
					goto error;
			}

			/* check ModBf */
			if (pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Capability <= MAX_MODBF_HE)
				MaxMcs = UNI_MAX_MCS_SUPPORT_HE;

			/* check RUAlloc */
			if (RUALLOC_TYPE_CHECK_EHT(ucBW)) {
				pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1RuAlloc = (UINT8)(ucBW&0xFF);
				if (ucBW == RUALLOC_BW320)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1RuAllocExt = (UINT8)(ucBW>>8);
			} else
				goto error;

			/* check GI */
			if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1GI > 2) ||
				((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1GI > 1) &&
				(pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Capability == MAX_MODBF_VHT)))
				goto error;

			/* check DL/UL */
			if (pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul > 2)
				goto error;

			/* check MCS */
			if (McsUsr[0] > MaxMcs) {
				McsUsr[0] -= (MaxMcs + 1);
				pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Nss0 = 1;
				if (McsUsr[0] > MaxMcs)
					McsUsr[0] = MaxMcs;
			}
			if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x1) == 0)
				pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1DlMcsUser0 = McsUsr[0];
			if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x3) > 0)
				pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1UlMcsUser0 = McsUsr[0];

			if (pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1NumUser > 0) {
				if (McsUsr[1] > MaxMcs) {
					McsUsr[1] -= (MaxMcs + 1);
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Nss1 = 1;
					if (McsUsr[1] > MaxMcs)
						McsUsr[1] = MaxMcs;
				}
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x1) == 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1DlMcsUser1 = McsUsr[1];
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x3) > 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1UlMcsUser1 = McsUsr[1];
			}

			if (pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1NumUser > 1) {
				if (McsUsr[2] > MaxMcs) {
					McsUsr[2] -= (MaxMcs + 1);
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Nss2 = 1;
					if (McsUsr[2] > MaxMcs)
						McsUsr[2] = MaxMcs;
				}
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x1) == 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1DlMcsUser2 = McsUsr[2];
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x3) > 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1UlMcsUser2 = McsUsr[2];
			}

			if (pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1NumUser > 2) {
				if (McsUsr[3] > MaxMcs) {
					McsUsr[3] -= (MaxMcs + 1);
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Nss3 = 1;
					if (McsUsr[3] > MaxMcs)
						McsUsr[3] = MaxMcs;
				}
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x1) == 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1DlMcsUser3 = McsUsr[3];
				if ((pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1Dl_Ul&0x3) > 0)
					pCmdFixedGrpRateCtrl->rMuruSetGrpTblEntry.u1UlMcsUser3 = McsUsr[3];
			}
		} while (0);
	}
	return Ret;
error:
	MTWF_PRINT("cmd=[NumUser]-[RUAlloc]-[GuardInterval]-[Phy/FullBW]");
	MTWF_PRINT("-[DL/UL]-[WcidUsr1]-[McsUsr1]-.....-[WcidUsr4]-[McsUsr4]\n");
	MTWF_PRINT("[NumUser]: 1~4\n");
	MTWF_PRINT("[RUAlloc]: BW20=122, BW40=130, BW80=134, BW160=137, BW320=395\n");
	MTWF_PRINT("[LTF/GI]: VHT:short GI=0, long GI=1; ");
	MTWF_PRINT("HE/EHT: 4xLTF+3.2us=0, 4xLTF+0.8us=1, 2xLTF+0.8u=2\n");
	MTWF_PRINT("[Phy/FullBW]: VHT=0, HEFullBW=1, HEPartialBW=2, EHTFullBW=3, EHTPartailBW=4\n");
	MTWF_PRINT("[DL/UL]: DL=0, UL=1, DLUL=2\n");
	MTWF_PRINT("[WcidUsrx]: WCID for nth user, according to NumUser\n");
	MTWF_PRINT("[McsUsrx]: MCS for nth user, according to NumUser, ");
	MTWF_PRINT("1SS MCS0~MCS11=0~11 and 2SS MCS0~MCS13=12~23 for HE/VHT\n");
	MTWF_PRINT(",1SS MCS0~MCS13=0~13 and 2SS MCS0~MCS13=14~27 for EHT\n");
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	Ret = NDIS_STATUS_INVALID_DATA;
	return Ret;
}

static INT32 UniCmdMuruSetDbgInfo(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_DBG_INFO *pCmdMuruSetDbgInfo = (struct UNI_CMD_MURU_SET_DBG_INFO *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruSetDbgInfo->u2Item = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		MTWF_PRINT("invalid format, muruDbgInfo=[item]-[value]\n");
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruSetDbgInfo->u4Value = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		MTWF_PRINT("invalid format, muruDbgInfo=[item]-[value]\n");
		goto error;
	}
	MTWF_PRINT("%s: item=%u value=%u\n", __func__,
		pCmdMuruSetDbgInfo->u2Item, pCmdMuruSetDbgInfo->u4Value);

	pCmdMuruSetDbgInfo->u2Tag = UNI_CMD_MURU_DBG_INFO;
	pCmdMuruSetDbgInfo->u2Length = sizeof(*pCmdMuruSetDbgInfo);

error:
	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetMdvtInfo(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_MDVT_INFO_T *pCmdMuruSetMdvtInfo = (struct UNI_CMD_MURU_SET_MDVT_INFO_T *)pHandle;
	PCHAR pch = NULL;
	UINT_32 u4Val[UNI_CMD_MURU_SET_MDVT_VAL_SIZE];
	UINT_16 u2Item = 0xff;
	UINT_8 i;

	for (i = 0; i < UNI_CMD_MURU_SET_MDVT_VAL_SIZE; i++)
		u4Val[i] = 0xffffffff;

	pch = strsep(&arg, "-");

	if (pch == NULL) {

		Ret = 0;
		MTWF_PRINT("%s invalid format, muruMdvtInfo=[item]-[val1]-[val2]-[val3]-[val4]\n",
			__func__);
		goto error;
	}

	set_muru_mdvt_param_info(pch, arg, &u2Item, u4Val, UNI_CMD_MURU_SET_MDVT_VAL_SIZE);

	if (u2Item != 0xff)
		pCmdMuruSetMdvtInfo->u2Item = u2Item;

	for (i = 0; i < UNI_CMD_MURU_SET_MDVT_VAL_SIZE; i++)
		pCmdMuruSetMdvtInfo->u4Value[i] = u4Val[i];

	pCmdMuruSetMdvtInfo->u2Tag = UNI_CMD_MURU_MDVT_INFO;
	pCmdMuruSetMdvtInfo->u2Length = sizeof(*pCmdMuruSetMdvtInfo);

	MTWF_PRINT("%s Item: %u\n", __func__, pCmdMuruSetMdvtInfo->u2Item);

	for (i = 0; i < UNI_CMD_MURU_SET_MDVT_VAL_SIZE; i++) {

		pCmdMuruSetMdvtInfo->u4Value[i] = u4Val[i];

		MTWF_PRINT("Value[%u]: %u.", i, pCmdMuruSetMdvtInfo->u4Value[i]);

	}

	MTWF_PRINT("\n");

error:
	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdPhyIcsStart(
	struct _RTMP_ADAPTER *pAd,
	UINT8  *pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	PHY_ICS_START_T *prRBISTInfo = (PHY_ICS_START_T *)pData;
	struct UNI_CMD_SET_PHY_ICS_START_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SET_PHY_ICS_START_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SET_SPECTRUM_PARAMTER*/
	prSpectrumCtrl = (struct UNI_CMD_SET_PHY_ICS_START_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_SET_PHY_ICS_START);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SET_PHY_ICS_START_T));

	/* Update data structure of SpectrumCtrl */
	prSpectrumCtrl->fgTrigger = cpu2le32(prRBISTInfo->fgTrigger);
	prSpectrumCtrl->u4PhyIcsTimer = cpu2le32(prRBISTInfo->u4PhyIcsTimer);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR, "\n"
			" prSpectrumCtrl->fgTrigger = 0x%08x\n"
			" prSpectrumCtrl->u4PhyIcsTimer = %d\n",
			prSpectrumCtrl->fgTrigger,
			prSpectrumCtrl->u4PhyIcsTimer);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPhyIcsEventEnable(
	struct _RTMP_ADAPTER *pAd,
	UINT8  * pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	PHY_ICS_START_T *prRBISTInfo = (PHY_ICS_START_T *)pData;
	struct UNI_CMD_SET_PHY_ICS_START_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SET_PHY_ICS_START_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SET_SPECTRUM_PARAMTER*/
	prSpectrumCtrl = (struct UNI_CMD_SET_PHY_ICS_START_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_SET_PHY_ICS_EVENT_ENABLE);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SET_PHY_ICS_START_T));

	/* Update data structure of SpectrumCtrl */
	prSpectrumCtrl->u4BandIdx = cpu2le32(prRBISTInfo->u4BandIdx);
	prSpectrumCtrl->u4PhyIdx = cpu2le32(prRBISTInfo->u4PhyIdx);
	prSpectrumCtrl->u4PhyIcsType = cpu2le32(prRBISTInfo->u4PhyIcsType);
	prSpectrumCtrl->u4PhyIcsEventGroup = cpu2le32(prRBISTInfo->u4PhyIcsEventGroup);
	prSpectrumCtrl->u4PhyIcsEventID[0] = cpu2le32(prRBISTInfo->u4PhyIcsEventID[0]);
	prSpectrumCtrl->u4PhyIcsEventID[1] = cpu2le32(prRBISTInfo->u4PhyIcsEventID[1]);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR, "\n"
			" prSpectrumCtrl->u4BandIdx = 0x%08x\n prSpectrumCtrl->u4PhyIdx = 0x%08x\n"
			" prSpectrumCtrl->u4PhyIcsType = 0x%08x\n prSpectrumCtrl->u4PhyIcsEventGroup = 0x%08x\n"
			" prSpectrumCtrl->u4PhyIcsEventID[0] = 0x%08x\n prSpectrumCtrl->u4PhyIcsEventID[1] = 0x%08x\n",
			prSpectrumCtrl->u4BandIdx, prSpectrumCtrl->u4PhyIdx,
			prSpectrumCtrl->u4PhyIcsType, prSpectrumCtrl->u4PhyIcsEventGroup,
			prSpectrumCtrl->u4PhyIcsEventID[0], prSpectrumCtrl->u4PhyIcsEventID[1]);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPhyIcsGetRawData(
	struct _RTMP_ADAPTER *pAd
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct UNI_CMD_GET_SPECTRUM_DATA_T *prSpectrumCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SPECTRUM_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_GET_SPECTRUM_DATA_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_GET_SPECTRUM_DATA*/
	prSpectrumCtrl = (struct UNI_CMD_GET_SPECTRUM_DATA_T *) pNextHeadBuf;
	prSpectrumCtrl->u2Tag = cpu2le16(UNI_CMD_GET_SPECTRUM_DATA);
	prSpectrumCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_GET_SPECTRUM_DATA_T));

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SPECTRUM);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetForceMu(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_FORCE_MU_T *pUniCmd = (struct UNI_CMD_MURU_SET_FORCE_MU_T *)pHandle;
	UINT8 *force_mu = (UINT8 *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_FORCE_MU;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->u1ForceMu = *force_mu;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);

	return Ret;
}

static INT32 UniCmdMuruShowUlRuStatus(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_GET_ULRU_STATUS_T *pCmdMuruUlRuStatusCtrl = (struct UNI_CMD_MURU_GET_ULRU_STATUS_T *)pHandle;

	pCmdMuruUlRuStatusCtrl->u2Tag = UNI_CMD_MURU_GET_UL_RU_STATUS;
	pCmdMuruUlRuStatusCtrl->u2Length = sizeof(*pCmdMuruUlRuStatusCtrl);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetDlUlLimits(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_DLUL_LIMITS_T *pUniCmd = (struct UNI_CMD_MURU_SET_DLUL_LIMITS_T *)pHandle;
	UINT8 *band = (UINT8 *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_CFG_DLUL_LIMIT;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->u1Dis160RuMu  = pAd->CommonCfg.Dis160RuMu;
	pUniCmd->u1MaxRuOfdma  = pAd->CommonCfg.MaxRuOfdma;
	pUniCmd->u1MaxDLMuMimo = pAd->CommonCfg.MaxDLMuMimo;
	pUniCmd->u1MaxULMuMimo = pAd->CommonCfg.MaxULMuMimo;
	pUniCmd->u1BandIdx = *band;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"Band:%d Dis160RuMu:%u MaxRuOfdma:%u MaxDLMuMimo:%u MaxULMuMimo:%u\n",
		pUniCmd->u1BandIdx, pUniCmd->u1Dis160RuMu, pUniCmd->u1MaxRuOfdma,
		pUniCmd->u1MaxDLMuMimo, pUniCmd->u1MaxULMuMimo);

	return Ret;
}

static INT32 UniCmdMuruSetDlUlConfig(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_DLUL_VAL_T *pUniCmd = (struct UNI_CMD_MURU_SET_DLUL_VAL_T *)pHandle;
	struct UNI_CMD_MURU_SET_DLUL_VAL_T *prSetParam = (struct UNI_CMD_MURU_SET_DLUL_VAL_T *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_DLUL_EN;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->u1BandBssSelect = prSetParam->u1BandBssSelect;
	pUniCmd->u1Index = prSetParam->u1Index;
	pUniCmd->u1DlUlUpdList = prSetParam->u1DlUlUpdList;
	pUniCmd->u1DlUlVal = prSetParam->u1DlUlVal;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		"u1BandBssSelect:%d u1Index:%u u1DlUlUpdList:%u u1DlUlVal:%u\n",
		pUniCmd->u1BandBssSelect, pUniCmd->u1Index, pUniCmd->u1DlUlUpdList, pUniCmd->u1DlUlVal);

	return Ret;
}

static UINT32 gu4UniMuruManCfgUsrListDl;
static UINT32 gu4UniMuruManCfgUsrListUl;

static struct UNI_MURU_MANUAL_CONFIG_T  grUniMuruManCfgInf;
static struct UNI_PQS_MANUAL_SCS_CONFIG_T grUniPqsScsManCfgInf;


INT32 uni_hqa_muru_parse_cmd_param_dltx(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *type,
	RTMP_STRING *val,
	struct UNI_MURU_MANUAL_CONFIG_T *pMuruManCfg
)
{
	INT32    status = FALSE;
#if defined(CONFIG_WLAN_SERVICE)
	UINT8  user_idx = 0;
	UINT8  tmpValue = 0;
	UINT32  loop_cnt, loop_idx, ru_idx, c26_idx;
	PCHAR  pch = NULL;

	UINT32 *pu4UsrList;
	UINT32 *pu4ManCfgBmpDl;
	UINT32 *pu4ManCfgBmpCmm;
	struct wifi_dev *wdev = NULL;

	struct UNI_MURU_DL_MANUAL_CONFIG *pCfgDl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;

	pu4UsrList = &gu4UniMuruManCfgUsrListDl;
	pu4ManCfgBmpDl = &pMuruManCfg->u4ManCfgBmpDl;
	pu4ManCfgBmpCmm = &pMuruManCfg->u4ManCfgBmpCmm;
	pCfgDl = &pMuruManCfg->rCfgDl;
	pCfgCmm = &pMuruManCfg->rCfgCmm;

	/* comm_cfg:[Band]:[BW]:[GI]:[LTF]:[total User#]:[VHT/HE]:[SPE] */
	if (strcmp("comm_cfg", type) == 0) {

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgCmm->u1Band = (uint8_t)os_str_tol(pch, 0, 10);

			if (pCfgCmm->u1Band < TESTMODE_BAND_NUM) {
				/* set TXCMD mode */
				wdev = &pAd->ate_wdev;
				pCfgCmm->u1Ac = HcGetWmmIdx(pAd, wdev);
			} else {
				status = FALSE;
				goto error;
			}

			*pu4ManCfgBmpCmm |= (MURU_FIXED_CMM_BAND | MURU_FIXED_CMM_AC);
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1Bw = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1GI = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1Ltf = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDl->u1UserCnt = (pAd->CommonCfg.HE_OfdmaUserNum) ?
									(uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum) :
									(uint8_t)os_str_tol(pch, 0, 10);

			pCfgCmm->u1PpduFmt |= MURU_PPDU_HE_MU;
			pCfgCmm->u1SchType |= MURU_OFDMA_SCH_TYPE_DL;
			*pu4ManCfgBmpCmm |= (MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			if (strcmp("VHT", pch) == 0)
				pCfgDl->u1TxMode = TX_MODE_VHT;
			else if (strcmp("HE", pch) == 0)
				pCfgDl->u1TxMode = TX_MODE_HE;
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgCmm->u1SpeIdx = (uint8_t)os_str_tol(pch, 0, 10);

			*pu4ManCfgBmpCmm |= (MURU_FIXED_CMM_SPE_IDX);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("%s:cmd=comm_cfg: band=%u, AC=%u, bw=%u, "
			"GI=%u, UserCnt=%u, TxMode=%u, SpeIdx=%u\n",
			__func__,
			pCfgCmm->u1Band, pCfgCmm->u1Ac, pCfgDl->u1Bw,
			pCfgDl->u1GI, pCfgDl->u1UserCnt, pCfgDl->u1TxMode,
			pCfgCmm->u1SpeIdx);

		*pu4UsrList = (1 << pCfgDl->u1UserCnt) - 1;
		*pu4ManCfgBmpDl |= (MURU_FIXED_BW | MURU_FIXED_GI | MURU_FIXED_LTF | MURU_FIXED_TOTAL_USER_CNT | MURU_FIXED_TX_MODE);

		status = TRUE;
	}

	/* comm_sigb_cfg:[sigb MCS]:[sigb DCM]:[sigb Compression] */
	if (strcmp("comm_sigb_cfg", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			tmpValue = (uint8_t)os_str_tol(pch, 0, 10);
			if (tmpValue != 0xFF) {
				pCfgDl->u1SigMcs = tmpValue;
				*pu4ManCfgBmpDl |= MURU_FIXED_SIGB_MCS;
			}
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			tmpValue = (uint8_t)os_str_tol(pch, 0, 10);
			if (tmpValue != 0xFF) {
				pCfgDl->u1SigDcm = tmpValue;
				*pu4ManCfgBmpDl |= MURU_FIXED_SIGB_DCM;
			}
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			tmpValue = (uint8_t)os_str_tol(pch, 0, 10);
			if (tmpValue != 0xFF) {
				pCfgDl->u1SigCmprs = tmpValue;
				*pu4ManCfgBmpDl |= MURU_FIXED_SIGB_CMPRS;
			}
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("%s:cmd=comm_sig_cfg: sigb mcs=%u, "
			"sig dcm=%u, sig compress=%u\n",
			__func__,
			pCfgDl->u1SigMcs,
			pCfgDl->u1SigDcm, pCfgDl->u1SigCmprs);

		status = TRUE;
	}

	/* comm_toneplan:[RU1]:[RU2]:[RU3]:[RU4]:[D26]:[RU5]:[RU6]:[RU7]:[RU8]:[U26] */
	if (strcmp("comm_toneplan", type) == 0) {

		ru_idx = c26_idx = 0;

		switch (pCfgDl->u1Bw) {
		case 0:
			loop_cnt = 1;
			break; /* 20MHz */

		case 1:
			loop_cnt = 2;
			break; /* 40MHz */

		case 2:
			loop_cnt = 5;
			break; /* 80MHz */

		case 3:
			loop_cnt = 10;
			break;/* 160MHz */

		default:
			loop_cnt = 1;
			break;
		}

		for (loop_idx = 0 ; loop_idx < loop_cnt ; loop_idx++) {

			pch = strsep(&val, ":");
			if (pch != NULL) {
				if ((loop_idx % 5) == 4) {
					pCfgDl->au1C26[c26_idx] = (uint8_t)os_str_tol(pch, 0, 10);
					c26_idx++;
				} else {
					pCfgDl->au2RU[ru_idx] = (uint8_t)os_str_tol(pch, 0, 10);
					ru_idx++;
				}
			} else {
				status = FALSE;
				goto error;
			}
		}

		MTWF_PRINT("%s:cmd=comm_toneplan: RU1=%u,RU2=%u,RU3=%u,"
			"RU4=%u,D26=%u,RU5=%u,RU6=%u,RU7=%u,RU8=%u,U26=%u\n",
			__func__,
			pCfgDl->au2RU[0], pCfgDl->au2RU[1], pCfgDl->au2RU[2],
			pCfgDl->au2RU[3], pCfgDl->au1C26[0],
			pCfgDl->au2RU[4], pCfgDl->au2RU[5], pCfgDl->au2RU[6],
			pCfgDl->au2RU[7], pCfgDl->au1C26[1]);

		*pu4ManCfgBmpDl |= MURU_FIXED_TONE_PLAN;
		status = TRUE;
	}

	/* user:[user #1]:[WLAN_ID]:[RBN]:[RU allocation]:[LDPC]:[Nsts]:[MCS]:[MU group]:[GID]:[UP]:[StartStream]:[MuMimoSpatial]:[AckPol] */
	if (strcmp("user", type) == 0) {

		pch = strsep(&val, ":");
		if (pch != NULL) {
			user_idx = (uint8_t)(os_str_tol(pch, 0, 10) - 1);
			if (user_idx >= MAX_NUM_TXCMD_USER_INFO)
				goto error;
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u2WlanIdx = (uint16_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1RuAllocBn = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1RuAllocIdx = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1Ldpc = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1Nss = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1Mcs = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDl->arUserInfoDl[user_idx].u1MuGroupIdx = (uint8_t)os_str_tol(pch, 0, 10);

			if (pCfgDl->arUserInfoDl[user_idx].u1MuGroupIdx > 0)
				*pu4ManCfgBmpDl |= MURU_FIXED_USER_MUMIMO_GRP;
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1VhtGid = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1VhtUp = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1HeStartStream = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->arUserInfoDl[user_idx].u1HeMuMimoSpatial = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDl->arUserInfoDl[user_idx].u1AckPolicy = (uint8_t)os_str_tol(pch, 0, 10);

			*pu4ManCfgBmpDl |= MURU_FIXED_USER_ACK_POLICY;
		}

		MTWF_PRINT("%s:cmd=user, user#%u, WlanIdx=%u, RBN=%u, RuAlloc=%u, "
			"Ldpc=%u, Nss=%u, Mcs=%u, MuGroup=%u, VhtGid=%u, "
			"VhtUp=%u, HeStartStream=%u, "
			"HeMuMimoSpatial=%u, AckPolicy=%u\n",
			__func__, user_idx+1,
			pCfgDl->arUserInfoDl[user_idx].u2WlanIdx,
			pCfgDl->arUserInfoDl[user_idx].u1RuAllocBn,
			pCfgDl->arUserInfoDl[user_idx].u1RuAllocIdx,
			pCfgDl->arUserInfoDl[user_idx].u1Ldpc,
			pCfgDl->arUserInfoDl[user_idx].u1Nss,
			pCfgDl->arUserInfoDl[user_idx].u1Mcs,
			pCfgDl->arUserInfoDl[user_idx].u1MuGroupIdx,
			pCfgDl->arUserInfoDl[user_idx].u1VhtGid,
			pCfgDl->arUserInfoDl[user_idx].u1VhtUp,
			pCfgDl->arUserInfoDl[user_idx].u1HeStartStream,
			pCfgDl->arUserInfoDl[user_idx].u1HeMuMimoSpatial,
			pCfgDl->arUserInfoDl[user_idx].u1AckPolicy);

		*pu4ManCfgBmpDl |= (MURU_FIXED_USER_WLAN_ID | MURU_FIXED_USER_RU_ALLOC | MURU_FIXED_USER_COD | MURU_FIXED_USER_MCS | MURU_FIXED_USER_NSS);
		*pu4UsrList &= ~(1 << user_idx);

		status = TRUE;
	}

error:
#endif
	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		 "(status = %d\n", status);

	return status;
}

INT32 uni_hqa_muru_parse_cmd_param_ultx(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *type,
	RTMP_STRING *val,
	struct UNI_MURU_MANUAL_CONFIG_T *pMuruManCfg
)
{
	INT32	status = FALSE;
#if defined(CONFIG_WLAN_SERVICE)
	UINT8	user_idx = 0;
	PCHAR	pch = NULL;
	INT32	loop_idx;

	UINT32	*pu4UsrList;
	UINT32	*pu4ManCfgBmpUl;
	UINT32	*pu4ManCfgBmpCmm;
	struct wifi_dev *wdev = NULL;

	struct UNI_MURU_UL_MANUAL_CONFIG *pCfgUl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;

	pu4UsrList = &gu4UniMuruManCfgUsrListUl;
	pu4ManCfgBmpUl = &pMuruManCfg->u4ManCfgBmpUl;
	pu4ManCfgBmpCmm = &pMuruManCfg->u4ManCfgBmpCmm;
	pCfgUl = &pMuruManCfg->rCfgUl;
	pCfgCmm = &pMuruManCfg->rCfgCmm;

	/* comm_cfg:[Band]:[BW]:[GI&LTF]:[total User#]*/
	if (strcmp("comm_cfg", type) == 0) {

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgCmm->u1Band = (uint8_t)os_str_tol(pch, 0, 10);

			if (pCfgCmm->u1Band < TESTMODE_BAND_NUM) {
				/* set TXCMD mode */
				wdev = &pAd->ate_wdev;
				pCfgCmm->u1Ac = HcGetWmmIdx(pAd, wdev);
			} else {
				status = FALSE;
				goto error;
			}

			*pu4ManCfgBmpCmm |= (MURU_FIXED_CMM_BAND | MURU_FIXED_CMM_AC);
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->u1UlBw = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->u1UlGiLtf = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u1UserCnt = (pAd->CommonCfg.HE_OfdmaUserNum) ?
									(uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum) :
									(uint8_t)os_str_tol(pch, 0, 10);

			pCfgCmm->u1PpduFmt |= MURU_PPDU_HE_TRIG;
			pCfgCmm->u1SchType |= MURU_OFDMA_SCH_TYPE_UL;
			*pu4ManCfgBmpCmm |= (MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("%s:cmd=comm_cfg: Band=%u, AC=%u, "
			"UlBw=%u, UlGiLtf=%u, UserCnt=%u\n",
			__func__,
			pCfgCmm->u1Band, pCfgCmm->u1Ac, pCfgUl->u1UlBw,
			pCfgUl->u1UlGiLtf, pCfgUl->u1UserCnt);

		*pu4UsrList = (1 << pCfgUl->u1UserCnt) - 1;
		*pu4ManCfgBmpUl |= (MURU_FIXED_UL_BW | MURU_FIXED_UL_GILTF | MURU_FIXED_UL_TOTAL_USER_CNT);

		status = TRUE;
	}

	/* comm_ta:[00]:[00]:[00]:[00]:[00]:[00] */
	if (strcmp("comm_ta", type) == 0) {

		for (loop_idx = 0 ; loop_idx < MAC_ADDR_LEN ; loop_idx++) {
			pch = strsep(&val, ":");

			if (pch != NULL) {
				pCfgUl->u1TrigTa[loop_idx] = (uint8_t)os_str_tol(pch, 0, 16);
			} else {
				status = FALSE;
				goto error;
			}
		}

		MTWF_PRINT("%s:cmd=comm_ta:%02X:%02X:%02X:%02X:%02X:%02X\n",
			__func__,
			pCfgUl->u1TrigTa[0],
			pCfgUl->u1TrigTa[1],
			pCfgUl->u1TrigTa[2],
			pCfgUl->u1TrigTa[3],
			pCfgUl->u1TrigTa[4],
			pCfgUl->u1TrigTa[5]);

		*pu4ManCfgBmpUl |= MURU_FIXED_TRIG_TA;

		status = TRUE;
	}

	/* ul_trig_cfg:[HE_TRIG cnt]:[HE_TRIG interval] */
	if (strcmp("ul_trig_cfg", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u2TrigCnt = (uint16_t)os_str_tol(pch, 0, 10);
			if (pCfgUl->u2TrigCnt)
				*pu4ManCfgBmpUl |= MURU_FIXED_TRIG_CNT;
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u2TrigIntv = (uint16_t)os_str_tol(pch, 0, 10);
			if (pCfgUl->u2TrigIntv)
				*pu4ManCfgBmpUl |= MURU_FIXED_TRIG_INTV;
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("%s:cmd=ul_trig_cfg: TrigCnt=%u, TrigIntv=%u\n",
			__func__, pCfgUl->u2TrigCnt, pCfgUl->u2TrigIntv);

		status = TRUE;
	}

	/* user:[user #1]:[WLAN_ID]:[RBN]:[RU allocation]:[LDPC]:[Nsts]:[MCS]:[packet size] */
	if (strcmp("user", type) == 0) {

		pch = strsep(&val, ":");
		if (pch != NULL) {
			user_idx = (uint8_t)(os_str_tol(pch, 0, 10) - 1);
			if (user_idx >= MAX_NUM_TXCMD_USER_INFO)
				goto error;
		} else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u2WlanIdx = (uint16_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u1RuAllocBn = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u1RuAllocIdx = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u1Ldpc = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u1Nss = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->arUserInfoUl[user_idx].u1Mcs = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		if (MURU_MANUAL_CFG_CHK(*pu4ManCfgBmpUl, MURU_FIXED_TRIG_CNT)) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->arUserInfoUl[user_idx].u4TrigPktSize = (UINT32)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("%s:cmd=user, user#%u, PktSize=%u\n",
				__func__, user_idx+1,
				pCfgUl->arUserInfoUl[user_idx].u4TrigPktSize);

			*pu4ManCfgBmpUl |= MURU_FIXED_TRIG_PKT_SIZE;
		}

		MTWF_PRINT("%s:cmd=user, user#%u, WlanIdx=%u, RBN=%u, "
			"RuAlloc=%u, Ldpc=%u, Nss=%u, Mcs=%u\n",
			__func__, user_idx+1,
			pCfgUl->arUserInfoUl[user_idx].u2WlanIdx,
			pCfgUl->arUserInfoUl[user_idx].u1RuAllocBn,
			pCfgUl->arUserInfoUl[user_idx].u1RuAllocIdx,
			pCfgUl->arUserInfoUl[user_idx].u1Ldpc,
			pCfgUl->arUserInfoUl[user_idx].u1Nss,
			pCfgUl->arUserInfoUl[user_idx].u1Mcs);

		*pu4ManCfgBmpUl |= (MURU_FIXED_USER_UL_WLAN_ID | MURU_FIXED_USER_UL_RU_ALLOC | MURU_FIXED_USER_UL_COD | MURU_FIXED_USER_UL_NSS | MURU_FIXED_USER_UL_MCS);
		*pu4UsrList &= ~(1 << user_idx);

		status = TRUE;
	}

error:
#endif
	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		 "(status = %d\n", status);

	return status;
}

INT32 uni_muru_parse_cmd_param_muru_manual_config(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *type,
	RTMP_STRING *val,
	struct UNI_MURU_MANUAL_CONFIG_T *pMuruManCfg
)
{
	INT32	status = FALSE;
	INT32	loop_cnt, loop_idx, ru_idx, c26_idx;
	PCHAR	pch = NULL;

	struct UNI_MURU_DL_MANUAL_CONFIG *pCfgDl = NULL;
	struct UNI_MURU_UL_MANUAL_CONFIG *pCfgUl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;
	struct UNI_MURU_DBG_MANUAL_CONFIG *pCfgDbg = NULL;
	UINT32 *pCfgBmpDl, *pCfgBmpUl, *pCfgBmpCmm, *pCfgBmpDbg;
	UINT32 *pUsrLstDl, *pUsrLstUl;

	pCfgDl = &pMuruManCfg->rCfgDl;
	pCfgUl = &pMuruManCfg->rCfgUl;
	pCfgCmm = &pMuruManCfg->rCfgCmm;
	pCfgDbg = &pMuruManCfg->rCfgDbg;
	pCfgBmpDl = &pMuruManCfg->u4ManCfgBmpDl;
	pCfgBmpUl = &pMuruManCfg->u4ManCfgBmpUl;
	pCfgBmpCmm = &pMuruManCfg->u4ManCfgBmpCmm;
	pCfgBmpDbg = &pMuruManCfg->u4ManCfgBmpDbg;
	pUsrLstDl = &gu4UniMuruManCfgUsrListDl;
	pUsrLstUl = &gu4UniMuruManCfgUsrListUl;

	MTWF_PRINT("%s:\n", __func__);

	/********** Common **********/
	/* global_comm_band */
	if (strcmp("global_comm_band", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgCmm->u1Band = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=global_comm_band: %u\n", pCfgCmm->u1Band);

		*pCfgBmpCmm |= MURU_FIXED_CMM_BAND;

		status = TRUE;
	}

	/* global_comm_ac */
	if (strcmp("global_comm_ac", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgCmm->u1Ac = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=global_comm_ac: %u\n",
			pCfgCmm->u1Ac);

		*pCfgBmpCmm |= MURU_FIXED_CMM_AC;

		status = TRUE;
	}

	/* global_comm_proc_type */
	if (strcmp("global_comm_proc_type", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgCmm->u1ProcType = (UINT8)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=global_comm_proc_type: %u\n", pCfgCmm->u1ProcType);

		*pCfgBmpCmm |= MURU_FIXED_CMM_PROC_TYPE;

		status = TRUE;
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {

		/* global_comm_spe */
		if (strcmp("global_comm_spe", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgCmm->u1SpeIdx = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=global_comm_spe: %u\n",
				pCfgCmm->u1SpeIdx);

			*pCfgBmpCmm |= MURU_FIXED_CMM_SPE_IDX;

			status = TRUE;
		}

		/* global_comm_mlo */
		if (strcmp("global_comm_mlo", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgCmm->u2MloCtrl = (uint16_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=global_comm_mlo: %u\n",
				pCfgCmm->u2MloCtrl);

			*pCfgBmpCmm |= MURU_FIXED_CMM_MLO_CTRL;

			status = TRUE;
		}

		/* global_comm_pda_pol */
		if (strcmp("global_comm_pda_pol", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgCmm->u1PdaPol = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=global_comm_pda_pol: %u\n",
				pCfgCmm->u1PdaPol);

			*pCfgBmpCmm |= MURU_FIXED_CMM_PDA_POL;

			status = TRUE;
		}
	}

	/* dl_comm_bw */
	if (strcmp("dl_comm_bw", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1Bw = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_bw: %u\n", pCfgDl->u1Bw);

		*pCfgBmpDl |= MURU_FIXED_BW;

		status = TRUE;
	}

	/* dl_comm_gi */
	if (strcmp("dl_comm_gi", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1GI = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_gi: %u\n", pCfgDl->u1GI);

		*pCfgBmpDl |= MURU_FIXED_GI;

		status = TRUE;
	}

	/* dl_comm_txmode */
	if (strcmp("dl_comm_txmode", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1TxMode = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_txmode: %u\n", pCfgDl->u1TxMode);

		*pCfgBmpDl |= MURU_FIXED_TX_MODE;

		status = TRUE;
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {

		/* dl_comm_toneplan:[RU1]:[RU2]:[RU3]:
		[RU4]:[RU5]:[RU6]:[RU7]:[RU8]:[RU9]:[RU10]:[RU11]:
		[RU12]:[RU13]:[RU14]:[RU15]:[RU16]: */
		if (strcmp("dl_comm_toneplan", type) == 0) {

			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_BW)) {
				ru_idx = c26_idx = 0;

				switch (pCfgDl->u1Bw) {
				case 0:
					loop_cnt = 1;
					break; /* 20MHz */

				case 1:
					loop_cnt = 2;
					break; /* 40MHz */

				case 2:
					loop_cnt = 4;
					break; /* 80MHz */

				case 3:
					loop_cnt = 8;
					break; /* 160MHz */

				case 4:
					loop_cnt = 16;
					break; /* 320MHz */

				default:
					loop_cnt = 1;
					break;
				}

				for (loop_idx = 0 ; loop_idx < loop_cnt ; loop_idx++) {

					pch = strsep(&val, ":");

					if (pch != NULL) {
						pCfgDl->au2RU[ru_idx] = (uint16_t)os_str_tol(pch, 0, 10);
						ru_idx++;
					} else {
						status = FALSE;
						goto error;
					}
				}

				MTWF_PRINT("cmd=dl_comm_toneplan: RU1=%u,RU2=%u,RU3=%u,RU4=%u,RU5=%u,RU6=%u,RU7=%u,RU8=%u\n",
				pCfgDl->au2RU[0], pCfgDl->au2RU[1], pCfgDl->au2RU[2],
				pCfgDl->au2RU[3], pCfgDl->au2RU[4], pCfgDl->au2RU[5],
				pCfgDl->au2RU[6], pCfgDl->au2RU[7]);

				MTWF_PRINT("cmd=dl_comm_toneplan: RU9=%u,RU10=%u,RU11=%u,RU12=%u,RU13=%u,RU14=%u,RU15=%u,RU16=%u\n",
				pCfgDl->au2RU[8], pCfgDl->au2RU[9], pCfgDl->au2RU[10],
				pCfgDl->au2RU[11], pCfgDl->au2RU[12], pCfgDl->au2RU[13],
				pCfgDl->au2RU[14], pCfgDl->au2RU[15]);

				*pCfgBmpDl |= MURU_FIXED_TONE_PLAN;
				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_comm_toneplan: set dl_comm_bw before config dl_comm_toneplan\n");

				status = FALSE;
				goto error;
			}
		}
	} else {
		/* dl_comm_toneplan:[RU1]:[RU2]:[RU3]:
		[RU4]:[D26]:[RU5]:[RU6]:[RU7]:[RU8]:[U26] */
		if (strcmp("dl_comm_toneplan", type) == 0) {

			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_BW)) {
				ru_idx = c26_idx = 0;

				switch (pCfgDl->u1Bw) {
				case 0:
					loop_cnt = 1;
					break; /* 20MHz */

				case 1:
					loop_cnt = 2;
					break; /* 40MHz */

				case 2:
					loop_cnt = 5;
					break; /* 80MHz */

				case 3:
					loop_cnt = 10;
					break; /* 160MHz */

				default:
					loop_cnt = 1;
					break;
				}

				for (loop_idx = 0 ; loop_idx < loop_cnt ; loop_idx++) {

					pch = strsep(&val, ":");
					if (pch != NULL && (loop_idx % 5) == 4) {
						pCfgDl->au1C26[c26_idx] = (uint8_t)os_str_tol(pch, 0, 10);
						c26_idx++;
					} else if (pch != NULL) {
						pCfgDl->au2RU[ru_idx] = (uint16_t)os_str_tol(pch, 0, 10);
						ru_idx++;
					} else {
						status = FALSE;
						goto error;
					}
				}

				MTWF_PRINT("cmd=dl_comm_toneplan: RU1=%u,RU2=%u,RU3=%u,RU4=%u,D26=%u,RU5=%u,RU6=%u,RU7=%u,RU8=%u,U26=%u\n",
				pCfgDl->au2RU[0], pCfgDl->au2RU[1], pCfgDl->au2RU[2],
				pCfgDl->au2RU[3], pCfgDl->au1C26[0],
				pCfgDl->au2RU[4], pCfgDl->au2RU[5], pCfgDl->au2RU[6],
				pCfgDl->au2RU[7], pCfgDl->au1C26[1]);

				*pCfgBmpDl |= MURU_FIXED_TONE_PLAN;
				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_comm_toneplan: set dl_comm_bw before config dl_comm_toneplan\n");

				status = FALSE;
				goto error;
			}
		}
	}

	/* dl_comm_user_cnt */
	if (strcmp("dl_comm_user_cnt", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDl->u1UserCnt = (pAd->CommonCfg.HE_OfdmaUserNum) ?
				(uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum) :
				(uint8_t)os_str_tol(pch, 0, 10);

			pCfgCmm->u1PpduFmt |= MURU_PPDU_HE_MU;
			pCfgCmm->u1SchType |= MURU_OFDMA_SCH_TYPE_DL;
			*pCfgBmpCmm |= (MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_user_cnt: %u\n",
			pCfgDl->u1UserCnt);

		*pCfgBmpDl |= MURU_FIXED_TOTAL_USER_CNT;

		status = TRUE;
	}

	/* dl_comm_ltf */
	if (strcmp("dl_comm_ltf", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1Ltf = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_ltf: %u\n", pCfgDl->u1Ltf);

		*pCfgBmpDl |= MURU_FIXED_LTF;

		status = TRUE;
	}

	/* dl_comm_ack_policy */
	if (strcmp("dl_comm_ack_policy", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1AckPly = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_ack_policy: %u\n", pCfgDl->u1AckPly);

		*pCfgBmpDl |= MURU_FIXED_ACK_PLY;

		status = TRUE;
	}

	/* dl_comm_txpwr */
	if (strcmp("dl_comm_txpwr", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1TxPwr = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=dl_comm_txpwr: %u\n", pCfgDl->u1TxPwr);

		*pCfgBmpDl |= MURU_FIXED_TXPOWER;

		status = TRUE;
	}

	/* dl_comm_sig_mcs */
	if (strcmp("dl_comm_sig_mcs", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1SigMcs = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"cmd=dl_comm_sig_mcs: %u\n", pCfgDl->u1SigMcs);

		*pCfgBmpDl |= MURU_FIXED_SIGB_MCS;

		status = TRUE;
	}

	/* dl_comm_sig_dcm */
	if (strcmp("dl_comm_sig_dcm", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1SigDcm = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"cmd=dl_comm_sig_dcm: %u\n", pCfgDl->u1SigDcm);

		*pCfgBmpDl |= MURU_FIXED_SIGB_DCM;

		status = TRUE;
	}

	/* dl_comm_sig_compress */
	if (strcmp("dl_comm_sig_compress", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgDl->u1SigCmprs = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"cmd=dl_comm_sig_compress: %u\n", pCfgDl->u1SigCmprs);

		*pCfgBmpDl |= MURU_FIXED_SIGB_CMPRS;

		status = TRUE;
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {
		/* dl_comm_disp_order */
		if (strcmp("dl_comm_disp_order", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgDl->u1AgcDispOrder = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=dl_comm_disp_order: %u\n",
				pCfgDl->u1AgcDispOrder);

			*pCfgBmpDl |= MURU_FIXED_AGC_POL;

			status = TRUE;
		}

		/* dl_comm_disp_pol */
		if (strcmp("dl_comm_disp_pol", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgDl->u1AgcDispPol = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=dl_comm_disp_pol: %u\n", pCfgDl->u1AgcDispPol);

			*pCfgBmpDl |= MURU_FIXED_AGC_POL;

			status = TRUE;
		}

		/* dl_comm_disp_ratio */
		if (strcmp("dl_comm_disp_ratio", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgDl->u1AgcDispRatio = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=dl_comm_disp_ratio: %u\n", pCfgDl->u1AgcDispRatio);

			*pCfgBmpDl |= MURU_FIXED_AGC_POL;

			status = TRUE;
		}

		/* dl_comm_disp_mgf */
		if (strcmp("dl_comm_disp_mgf", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgDl->u2AgcDispLinkMGF = (uint16_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=dl_comm_disp_mgf: %u\n",
				pCfgDl->u2AgcDispLinkMGF);

			*pCfgBmpDl |= MURU_FIXED_AGC_POL;

			status = TRUE;
		}

		/* dl_comm_preamble_puncture_bitmap */
		if (strcmp("dl_comm_preamble_puncture_bitmap", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgDl->u2PrmblPuncBmp = (uint16_t)os_str_tol(pch, 0, 16);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=dl_comm_preamble_puncture_bitmap: %u\n",
				pCfgDl->u2PrmblPuncBmp);

			*pCfgBmpDl |= MURU_FIXED_PRMBL_PUNC;

			status = TRUE;
		}
	}

	/* dl_user_wlan_idx */
	if (strcmp("dl_user_wlan_idx", type) == 0) {

		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgDl->arUserInfoDl[loop_idx].u2WlanIdx = (uint16_t)os_str_tol(pch, 0, 10);
				} else {
					status = FALSE;
					goto error;
				}
				MTWF_PRINT("cmd=dl_user_wlan_idx: user %u, value=%u\n",
					loop_idx + 1,
					pCfgDl->arUserInfoDl[loop_idx].u2WlanIdx);
			}

			*pCfgBmpDl |= MURU_FIXED_USER_WLAN_ID;
			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_wlan_idx: set dl_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* dl_user_coding*/
	if (strcmp("dl_user_cod", type) == 0) {

		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl,
			MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgDl->arUserInfoDl[loop_idx].u1Ldpc =
						(uint8_t)os_str_tol(pch, 0, 10);
				} else {
					status = FALSE;
					goto error;
				}

				MTWF_PRINT("cmd=dl_user_cod: user %u, value=%u\n",
					loop_idx + 1,
					pCfgDl->arUserInfoDl[loop_idx].u1Ldpc);
			}

			*pCfgBmpDl |= MURU_FIXED_USER_COD;
			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_cod: set dl_comm_user_cnt before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* dl_user_mcs */
	if (strcmp("dl_user_mcs", type) == 0) {

		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl,
			MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgDl->arUserInfoDl[loop_idx].u1Mcs =
						(uint8_t)os_str_tol(pch, 0, 10);
				} else {
					status = FALSE;
					goto error;
				}

				MTWF_PRINT("cmd=dl_user_mcs: user %u, value=%u\n",
					loop_idx + 1,
					pCfgDl->arUserInfoDl[loop_idx].u1Mcs);
			}

			*pCfgBmpDl |= MURU_FIXED_USER_MCS;
			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_mcs: set dl_comm_user_cnt before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* dl_user_nss */
	if (strcmp("dl_user_nss", type) == 0) {

		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl,
			MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgDl->arUserInfoDl[loop_idx].u1Nss =
						(uint8_t)os_str_tol(pch, 0, 10);
				} else {
					status = FALSE;
					goto error;
				}

				MTWF_PRINT("cmd=dl_user_nss: user %u, value=%u\n",
					loop_idx + 1,
					pCfgDl->arUserInfoDl[loop_idx].u1Nss);
			}

			*pCfgBmpDl |= MURU_FIXED_USER_NSS;
			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_nss: set dl_comm_user_cnt before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* dl_user_ru_alloc :[PS160, RBN]:[RU alloc]*/
	if (strcmp("dl_user_ru_alloc", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL)
					pCfgDl->arUserInfoDl[loop_idx].u1RuAllocBn = (uint8_t)os_str_tol(pch, 0, 10);
				else {
					status = FALSE;
					goto error;
				}

				pCfgDl->arUserInfoDl[loop_idx].u1RuAllocPs160 = (pCfgDl->arUserInfoDl[loop_idx].u1RuAllocBn & 0x2) >> 1;
				pCfgDl->arUserInfoDl[loop_idx].u1RuAllocBn = pCfgDl->arUserInfoDl[loop_idx].u1RuAllocBn & 0x1;

				pch = strsep(&val, ":");
				if (pch != NULL)
					pCfgDl->arUserInfoDl[loop_idx].u1RuAllocIdx = (uint8_t)os_str_tol(pch, 0, 10);
				else {
					status = FALSE;
					goto error;
				}

				MTWF_PRINT("cmd=dl_user_ru_alloc:[RBN]:[RU alloc]= user %u, PS160=%u, RBN=%u, RU alloc idx=%u\n",
				loop_idx + 1,
				pCfgDl->arUserInfoDl[loop_idx].u1RuAllocPs160,
				pCfgDl->arUserInfoDl[loop_idx].u1RuAllocBn,
				pCfgDl->arUserInfoDl[loop_idx].u1RuAllocIdx);
			}

			*pCfgBmpDl |= MURU_FIXED_USER_RU_ALLOC;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_ru_alloc: set dl_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {

		/* dl_user_mu_group */
		if (strcmp("dl_user_mu_group", type) == 0) {
			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
				loop_cnt = pCfgDl->u1UserCnt;
				for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
					pch = strsep(&val, ":");
					if (pch != NULL) {
						pCfgDl->arUserInfoDl[loop_idx].u1MuGroupIdx = (uint8_t)os_str_tol(pch, 0, 10);

						MTWF_PRINT("cmd=dl_user_mu_group: user %u, value=%u\n",
							loop_idx + 1,
							pCfgDl->arUserInfoDl[loop_idx].u1MuGroupIdx);
					} else {
						status = FALSE;
						goto error;
					}
				}

				*pCfgBmpDl |= MURU_FIXED_USER_MUMIMO_GRP;

				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_user_mu_group: set dl_comm_user_cnt before user specific config\n");

				status = FALSE;
				goto error;
			}
		}

		/* dl_user_start_stream */
		if (strcmp("dl_user_start_stream", type) == 0) {
			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
				loop_cnt = pCfgDl->u1UserCnt;
				for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
					pch = strsep(&val, ":");
					if (pch != NULL) {
						pCfgDl->arUserInfoDl[loop_idx].u1HeStartStream = (uint8_t)os_str_tol(pch, 0, 10);

						MTWF_PRINT("cmd=dl_user_start_stream: user %u, value=%u\n",
							loop_idx + 1,
							pCfgDl->arUserInfoDl[loop_idx].u1HeStartStream);
					} else {
						status = FALSE;
						goto error;
					}
				}

				*pCfgBmpDl |= MURU_FIXED_USER_MUMIMO_GRP;

				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_user_start_stream: set dl_comm_user_cnt before user specific config\n");

				status = FALSE;
				goto error;
			}
		}

		/* dl_user_gid */
		if (strcmp("dl_user_gid", type) == 0) {
			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
				loop_cnt = pCfgDl->u1UserCnt;
				for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
					pch = strsep(&val, ":");
					if (pch != NULL) {
						pCfgDl->arUserInfoDl[loop_idx].u1VhtGid = (uint8_t)os_str_tol(pch, 0, 10);

						MTWF_PRINT("cmd=dl_user_gid: user %u, value=%u\n",
							loop_idx + 1,
							pCfgDl->arUserInfoDl[loop_idx].u1VhtGid);
					} else {
						status = FALSE;
						goto error;
					}
				}

				*pCfgBmpDl |= MURU_FIXED_USER_MUMIMO_VHT;

				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_user_gid: set dl_comm_user_cnt before user specific config\n");

				status = FALSE;
				goto error;
			}
		}

		/* dl_user_up */
		if (strcmp("dl_user_up", type) == 0) {
			if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
				loop_cnt = pCfgDl->u1UserCnt;
				for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
					pch = strsep(&val, ":");
					if (pch != NULL) {
						pCfgDl->arUserInfoDl[loop_idx].u1VhtUp = (uint8_t)os_str_tol(pch, 0, 10);

						MTWF_PRINT("cmd=dl_user_up: user %u, value=%u\n",
							loop_idx + 1,
							pCfgDl->arUserInfoDl[loop_idx].u1VhtUp);
					} else {
						status = FALSE;
						goto error;
					}
				}

				*pCfgBmpDl |= MURU_FIXED_USER_MUMIMO_VHT;

				status = TRUE;
			} else {
				MTWF_PRINT("cmd=dl_user_up: set dl_comm_user_cnt before user specific config\n");

				status = FALSE;
				goto error;
			}
		}
	}

	/* dl_user_ack_polocy */
	if (strcmp("dl_user_ack_policy", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpDl, MURU_FIXED_TOTAL_USER_CNT)) {
			loop_cnt = pCfgDl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgDl->arUserInfoDl[loop_idx].u1AckPolicy = (uint8_t)os_str_tol(pch, 0, 10);

					MTWF_PRINT("cmd=dl_user_ack_policy: "
						"user %u, value=%u\n",
						loop_idx + 1,
						pCfgDl->arUserInfoDl[loop_idx].u1AckPolicy);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpDl |= MURU_FIXED_USER_ACK_POLICY;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=dl_user_ack_policy: set dl_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/********** Uplink **********/

	/* ul_comm_user_cnt */
	if (strcmp("ul_comm_user_cnt", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u1UserCnt = (pAd->CommonCfg.HE_OfdmaUserNum) ?
									(uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum) :
									(uint8_t)os_str_tol(pch, 0, 10);

			pCfgCmm->u1PpduFmt |= MURU_PPDU_HE_TRIG;
			pCfgCmm->u1SchType |= MURU_OFDMA_SCH_TYPE_UL;
			*pCfgBmpCmm |= (MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_user_cnt: %u\n", pCfgUl->u1UserCnt);

		*pCfgBmpUl |= MURU_FIXED_UL_TOTAL_USER_CNT;

		status = TRUE;
	}

	/* ul_comm_ack_type */
	if (strcmp("ul_comm_ack_type", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->u1BaType = (uint8_t)os_str_tol(pch, 0, 10);
		else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_ack_type: %u\n", pCfgUl->u1BaType);

		*pCfgBmpUl |= MURU_FIXED_UL_ACK_TYPE;

		status = TRUE;
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {
		/* ul_comm_disp_mgf */
		if (strcmp("ul_comm_disp_mgf", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->u2AgcDispLinkMGF = (uint16_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=ul_comm_disp_mgf: %u\n", pCfgUl->u2AgcDispLinkMGF);

			*pCfgBmpUl |= MURU_FIXED_UL_AGC_POL;

			status = TRUE;
		}

		/* ul_comm_disp_mulen */
		if (strcmp("ul_comm_disp_mulen", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->u1AgcDispMuLen = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=ul_comm_disp_mulen: %u\n", pCfgUl->u1AgcDispMuLen);

			*pCfgBmpUl |= MURU_FIXED_UL_AGC_POL;

			status = TRUE;
		}

		/* ul_comm_disp_pol */
		if (strcmp("ul_comm_disp_pol", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->u1AgcDispPol = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=ul_comm_disp_pol: %u\n", pCfgUl->u1AgcDispPol);

			*pCfgBmpUl |= MURU_FIXED_UL_AGC_POL;

			status = TRUE;
		}

		/* ul_comm_disp_ratio */
		if (strcmp("ul_comm_disp_ratio", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->u1AgcDispRatio = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=ul_comm_disp_ratio: %u\n", pCfgUl->u1AgcDispRatio);

			*pCfgBmpUl |= MURU_FIXED_UL_AGC_POL;

			status = TRUE;
		}

		/* ul_comm_disp_puidx */
		if (strcmp("ul_comm_disp_puidx", type) == 0) {
			pch = strsep(&val, ":");
			if (pch != NULL)
				pCfgUl->u1AgcDispPuIdx = (uint8_t)os_str_tol(pch, 0, 10);
			else {
				status = FALSE;
				goto error;
			}

			MTWF_PRINT("cmd=ul_comm_disp_puidx: %u\n", pCfgUl->u1AgcDispPuIdx);

			*pCfgBmpUl |= MURU_FIXED_UL_AGC_POL;

			status = TRUE;
		}
	}

	/* ul_comm_trig_intv */
	if (strcmp("ul_comm_trig_intv", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->u2TrigIntv = (uint16_t)os_str_tol(pch, 0, 10);

		if (pCfgUl->u2TrigIntv) {
			*pCfgBmpUl |= MURU_FIXED_TRIG_INTV;
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_trig_intv: %u\n", pCfgUl->u2TrigIntv);

		status = TRUE;
	}

	/* ul_comm_trig_cnt */
	if (strcmp("ul_comm_trig_cnt", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL)
			pCfgUl->u2TrigCnt = (uint16_t)os_str_tol(pch, 0, 10);

		if (pCfgUl->u2TrigCnt) {
			*pCfgBmpUl |= MURU_FIXED_TRIG_CNT;
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_trig_cnt: %u\n", pCfgUl->u2TrigCnt);

		status = TRUE;
	}

	/* ul_comm_trig_type */
	if (strcmp("ul_comm_trig_type", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u1TrigType = (uint8_t)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_trig_type: %u\n", pCfgUl->u1TrigType);

		*pCfgBmpUl |= MURU_FIXED_TRIG_TYPE;

		status = TRUE;
	}

	/* ul_comm_ta:[00]:[00]:[00]:[00]:[00]:[00] */
	if (strcmp("ul_comm_ta", type) == 0) {

		for (loop_idx = 0 ; loop_idx < MAC_ADDR_LEN ; loop_idx++) {
			pch = strsep(&val, ":");

			if (pch != NULL) {
				pCfgUl->u1TrigTa[loop_idx] = (uint8_t)os_str_tol(pch, 0, 16);
			} else {
				status = FALSE;
				goto error;
			}
		}

		MTWF_PRINT("%s:cmd=comm_ta:%02X:%02X:%02X:%02X:%02X:%02X\n",
			__func__,
			pCfgUl->u1TrigTa[0],
			pCfgUl->u1TrigTa[1],
			pCfgUl->u1TrigTa[2],
			pCfgUl->u1TrigTa[3],
			pCfgUl->u1TrigTa[4],
			pCfgUl->u1TrigTa[5]);

		*pCfgBmpUl |= MURU_FIXED_TRIG_TA;

		status = TRUE;
	}

	/* ul_comm_bw */
	if (strcmp("ul_comm_bw", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u1UlBw = (uint8_t)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_bw: %u\n", pCfgUl->u1UlBw);

		*pCfgBmpUl |= MURU_FIXED_UL_BW;

		status = TRUE;
	}

	/* ul_comm_gi_ltf */
	if (strcmp("ul_comm_gi_ltf", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u1UlGiLtf = (uint8_t)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_gi_ltf: %u\n", pCfgUl->u1UlGiLtf);

		*pCfgBmpUl |= MURU_FIXED_UL_GILTF;

		status = TRUE;
	}

	/* ul_comm_length */
	if (strcmp("ul_comm_length", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgUl->u2UlLength = (uint16_t)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_length: %u\n", pCfgUl->u2UlLength);

		*pCfgBmpUl |= MURU_FIXED_UL_LENGTH;

		status = TRUE;
	}

	/* ul_comm_tf_pad */
	if (strcmp("ul_comm_tf_pad", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			if (pAd->CommonCfg.HE_TrigPadding) {
				if (pAd->CommonCfg.HE_TrigPadding == 8)
					pCfgUl->u1TfPad = 1;
				else if (pAd->CommonCfg.HE_TrigPadding == 16)
					pCfgUl->u1TfPad = 2;
				else
					pCfgUl->u1TfPad = 2;
			} else {
				pCfgUl->u1TfPad = (uint8_t)os_str_tol(pch, 0, 10);
			}
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_tf_pad: %u\n", pCfgUl->u1TfPad);

		*pCfgBmpUl |= MURU_FIXED_UL_TF_PAD;

		status = TRUE;
	}

    /* HETB RX Debug: ul_comm_rx_hetb_cfg1 */
	if (strcmp("ul_comm_rx_hetb_cfg1", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDbg->au4RxHetbCfg[0] = (UINT32)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_rx_hetb_cfg1: %u\n", pCfgDbg->au4RxHetbCfg[0]);

		*pCfgBmpDbg |= MURU_FIXED_RX_HETB_CFG1;

		status = TRUE;
	}

	 /* HETB RX Debug:ul_comm_rx_hetb_cfg2 */
	if (strcmp("ul_comm_rx_hetb_cfg2", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDbg->au4RxHetbCfg[1] = (UINT32)os_str_tol(pch, 0, 10);
		} else {
			status = FALSE;
			goto error;
		}

		MTWF_PRINT("cmd=ul_comm_rx_hetb_cfg2: %u\n", pCfgDbg->au4RxHetbCfg[1]);

		*pCfgBmpDbg |= MURU_FIXED_RX_HETB_CFG2;

		status = TRUE;
	}

	/* ul_user_wlan_idx */
	if (strcmp("ul_user_wlan_idx", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgUl->arUserInfoUl[loop_idx].u2WlanIdx = (uint16_t)os_str_tol(pch, 0, 10);

					MTWF_PRINT("cmd=ul_user_wlan_idx: user %u, "
					"value=%u\n",
					loop_idx + 1,
					pCfgUl->arUserInfoUl[loop_idx].u2WlanIdx);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_WLAN_ID;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_wlan_idx: set ul_comm_user_cnt before "
			"user specific config\n");

			status = FALSE;
			goto error;
		}
	}
	/* ul_user_cod */
	if (strcmp("ul_user_cod", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgUl->arUserInfoUl[loop_idx].u1Ldpc = (uint8_t)os_str_tol(pch, 0, 10);

					MTWF_PRINT("cmd=ul_user_cod: user %u, value=%u\n",
					loop_idx + 1,
					pCfgUl->arUserInfoUl[loop_idx].u1Ldpc);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_COD;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_cod: set ul_comm_user_cnt before "
			"user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* ul_user_mcs */
	if (strcmp("ul_user_mcs", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgUl->arUserInfoUl[loop_idx].u1Mcs = (uint8_t)os_str_tol(pch, 0, 10);
					MTWF_PRINT("cmd=ul_user_mcs: user %u, value=%u\n",
					loop_idx + 1,
					pCfgUl->arUserInfoUl[loop_idx].u1Mcs);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_MCS;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_mcs: set ul_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* ul_user_ssAlloc_raru */
	if (strcmp("ul_user_ssAlloc_raru", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgUl->arUserInfoUl[loop_idx].u1Nss = (uint8_t)os_str_tol(pch, 0, 10);

					MTWF_PRINT("cmd=ul_user_ssAlloc_raru: "
					"user %u, value=%u\n",
					loop_idx + 1,
					pCfgUl->arUserInfoUl[loop_idx].u1Nss);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_NSS;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_ssAlloc_raru: set ul_comm_user_cnt"
				" before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* ul_user_rssi */
	if (strcmp("ul_user_rssi", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL) {
					pCfgUl->arUserInfoUl[loop_idx].u1TargetRssi = (uint8_t)os_str_tol(pch, 0, 10);

					MTWF_PRINT("cmd=ul_user_rssi: user %u, value=%u\n",
					loop_idx + 1,
					pCfgUl->arUserInfoUl[loop_idx].u1TargetRssi);
				} else {
					status = FALSE;
					goto error;
				}
			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_TARGET_RSSI;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_rssi: set ul_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	if (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) {

		/* ul_comm_toneplan:[RU1]:[RU2]:[RU3]:
		[RU4]:[RU5]:[RU6]:[RU7]:[RU8]:[RU9]:[RU10]:[RU11]:
		[RU12]:[RU13]:[RU14]:[RU15]:[RU16]: */
		if (strcmp("ul_comm_toneplan", type) == 0) {

			if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_BW)) {
				ru_idx = c26_idx = 0;

				switch (pCfgUl->u1UlBw) {
				case 0:
					loop_cnt = 1;
					break; /* 20MHz */

				case 1:
					loop_cnt = 2;
					break; /* 40MHz */

				case 2:
					loop_cnt = 4;
					break; /* 80MHz */

				case 3:
					loop_cnt = 8;
					break; /* 160MHz */

				case 4:
					loop_cnt = 16;
					break; /* 320MHz */

				default:
					loop_cnt = 1;
					break;
				}

				for (loop_idx = 0 ; loop_idx < loop_cnt ; loop_idx++) {

					pch = strsep(&val, ":");

					if (pch != NULL) {
						pCfgUl->au2UlRU[ru_idx] = (uint16_t)os_str_tol(pch, 0, 10);
						ru_idx++;
					} else {
						status = FALSE;
						goto error;
					}
				}

				MTWF_PRINT("cmd=ul_comm_toneplan: RU1=%u,RU2=%u,RU3=%u,RU4=%u,",
					pCfgUl->au2UlRU[0], pCfgUl->au2UlRU[1],
					pCfgUl->au2UlRU[2], pCfgUl->au2UlRU[3]);

				MTWF_PRINT("RU5=%u,RU6=%u,RU7=%u,RU8=%u\n",
					pCfgUl->au2UlRU[4], pCfgUl->au2UlRU[5],
					pCfgUl->au2UlRU[6], pCfgUl->au2UlRU[7]);

				MTWF_PRINT("cmd=dl_comm_toneplan: RU9=%u,RU10=%u,RU11=%u,RU12=%u,",
					pCfgUl->au2UlRU[8], pCfgUl->au2UlRU[9],
					pCfgUl->au2UlRU[10], pCfgUl->au2UlRU[11]);

				MTWF_PRINT("RU13=%u,RU14=%u,RU15=%u,RU16=%u\n",
					pCfgUl->au2UlRU[12], pCfgUl->au2UlRU[13],
					pCfgUl->au2UlRU[14], pCfgUl->au2UlRU[15]);

				*pCfgBmpUl |= MURU_FIXED_TONE_PLAN;
				status = TRUE;
			} else {
				MTWF_PRINT("cmd=ul_comm_toneplan: ");
				MTWF_PRINT("set ul_comm_bw before config ul_comm_toneplan\n");

				status = FALSE;
				goto error;
			}
		}
	} else {
		/* ul_comm_toneplan:[RU1]:[RU2]:[RU3]:
		[RU4]:[D26]:[RU5]:[RU6]:[RU7]:[RU8]:[U26] */
		if (strcmp("ul_comm_toneplan", type) == 0) {

			if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_BW)) {
				ru_idx = c26_idx = 0;

				switch (pCfgUl->u1UlBw) {
				case 0:
					loop_cnt = 1;
					break; /* 20MHz */

				case 1:
					loop_cnt = 2;
					break; /* 40MHz */

				case 2:
					loop_cnt = 5;
					break; /* 80MHz */

				case 3:
					loop_cnt = 10;
					break; /* 160MHz */

				default:
					loop_cnt = 1;
					break;
				}

				for (loop_idx = 0 ; loop_idx < loop_cnt ; loop_idx++) {

					pch = strsep(&val, ":");
					if (pch == NULL) {
						status = FALSE;
						goto error;
					}

					if ((loop_idx % 5) == 4) {
						pCfgUl->au1UlC26[c26_idx] = (uint8_t)os_str_tol(pch, 0, 10);
						c26_idx++;
					} else {
						pCfgUl->au2UlRU[ru_idx] = (uint8_t)os_str_tol(pch, 0, 10);
						ru_idx++;
					}
				}

				MTWF_PRINT("cmd=ul_comm_toneplan: RU1=%u,RU2=%u,RU3=%u,RU4=%u,",
					pCfgUl->au2UlRU[0], pCfgUl->au2UlRU[1],
					pCfgUl->au2UlRU[2], pCfgUl->au2UlRU[3]);
				MTWF_PRINT("D26=%u,RU5=%u,RU6=%u,RU7=%u,RU8=%u,U26=%u\n",
					pCfgUl->au1UlC26[0],
					pCfgUl->au2UlRU[4], pCfgUl->au2UlRU[5],
					pCfgUl->au2UlRU[6], pCfgUl->au2UlRU[7],
					pCfgUl->au1UlC26[1]);

				*pCfgBmpUl |= MURU_FIXED_TONE_PLAN;
				status = TRUE;
			} else {
				MTWF_PRINT("cmd=ul_comm_toneplan: ");
				MTWF_PRINT("set ul_comm_bw before config ul_comm_toneplan\n");

				status = FALSE;
				goto error;
			}
		}
	}

	/* ul_user_ru_alloc :[RBN]:[RU alloc]*/
	if (strcmp("ul_user_ru_alloc", type) == 0) {
		if (MURU_MANUAL_CFG_CHK(*pCfgBmpUl, MURU_FIXED_UL_TOTAL_USER_CNT)) {
			loop_cnt = pCfgUl->u1UserCnt;
			for (loop_idx = 0; loop_idx < loop_cnt; loop_idx++) {
				pch = strsep(&val, ":");
				if (pch != NULL)
					pCfgUl->arUserInfoUl[loop_idx].u1RuAllocBn = (uint8_t)os_str_tol(pch, 0, 10);
				else {
					status = FALSE;
					goto error;
				}

				pCfgUl->arUserInfoUl[loop_idx].u1RuAllocPs160 = (pCfgUl->arUserInfoUl[loop_idx].u1RuAllocBn & 0x2) >> 1;
				pCfgUl->arUserInfoUl[loop_idx].u1RuAllocBn = pCfgUl->arUserInfoUl[loop_idx].u1RuAllocBn & 0x1;

				pch = strsep(&val, ":");
				if (pch != NULL)
					pCfgUl->arUserInfoUl[loop_idx].u1RuAllocIdx = (uint8_t)os_str_tol(pch, 0, 10);
				else {
					status = FALSE;
					goto error;
				}

				MTWF_PRINT("cmd=ul_user_ru_alloc:");
				MTWF_PRINT("[RBN]:[RU alloc]= user %u,PS160=%u, RBN=%u, RU alloc idx=%u\n",
				loop_idx + 1,
				pCfgUl->arUserInfoUl[loop_idx].u1RuAllocPs160,
				pCfgUl->arUserInfoUl[loop_idx].u1RuAllocBn,
				pCfgUl->arUserInfoUl[loop_idx].u1RuAllocIdx);

			}

			*pCfgBmpUl |= MURU_FIXED_USER_UL_RU_ALLOC;

			status = TRUE;
		} else {
			MTWF_PRINT("cmd=ul_user_ru_alloc: set ul_comm_user_cnt "
				"before user specific config\n");

			status = FALSE;
			goto error;
		}
	}

	/* ul_user_rx_nonsf_en_bitmap */
	if (strcmp("ul_user_rx_nonsf_en_bitmap", type) == 0) {
		pch = strsep(&val, ":");
		if (pch != NULL) {
			pCfgDbg->u4RxHetbNonsfEnBitmap = (UINT32)os_str_tol(pch, 0, 10);

			MTWF_PRINT("cmd=ul_user_rx_nonsf_en_bitmap: value=0x%x\n",
				pCfgDbg->u4RxHetbNonsfEnBitmap);
		} else {
			status = FALSE;
			goto error;
		}
		*pCfgBmpDbg |= MURU_FIXED_NONSF_EN_BITMAP;
		status = TRUE;
	}

error:
	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		 "(status = %d\n", status);

	return status;
}

INT32 uni_hqa_muru_set_dl_tx_muru_config(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret = TRUE;
	char sep_val = ':';
	RTMP_STRING *param_type, *param_val;

	UINT32	*pu4UsrList;
	UINT32	*pu4ManCfgBmpDl;
	UINT32	*pu4ManCfgBmpCmm;

	struct UNI_MURU_DL_MANUAL_CONFIG *pCfgDl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;

	pu4UsrList = &gu4UniMuruManCfgUsrListDl;
	pu4ManCfgBmpDl = &grUniMuruManCfgInf.u4ManCfgBmpDl;
	pu4ManCfgBmpCmm = &grUniMuruManCfgInf.u4ManCfgBmpCmm;
	pCfgDl = &grUniMuruManCfgInf.rCfgDl;
	pCfgCmm = &grUniMuruManCfgInf.rCfgCmm;

	param_type = arg;
	if (strlen(param_type)) {

		if (strcmp("init", param_type) == 0) {

			/* init */
			*pu4UsrList = 0;
			*pu4ManCfgBmpDl = 0;
			*pu4ManCfgBmpCmm &= ~(MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
			pCfgCmm->u1PpduFmt &= ~MURU_PPDU_HE_MU;
			pCfgCmm->u1SchType &= ~MURU_OFDMA_SCH_TYPE_DL;
			os_zero_mem(pCfgDl, sizeof(struct UNI_MURU_DL_MANUAL_CONFIG));

			if (pAd->CommonCfg.HE_OfdmaUserNum) {
				pCfgDl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
				*pu4ManCfgBmpDl |= MURU_FIXED_TOTAL_USER_CNT;
			}

			if (pAd->CommonCfg.HE_PpduFmt) {
				pCfgCmm->u1PpduFmt = (uint8_t)(pAd->CommonCfg.HE_PpduFmt);
				*pu4ManCfgBmpCmm |= MURU_FIXED_CMM_PPDU_FMT;
			}

			if (pAd->CommonCfg.HE_OfdmaSchType) {
				pCfgCmm->u1SchType = (uint8_t)(pAd->CommonCfg.HE_OfdmaSchType);
				*pu4ManCfgBmpCmm |= MURU_FIXED_CMM_SCH_TYPE;
			}

			Ret = TRUE;
		} else if (strcmp("update", param_type) == 0) {

			/* update */
			if (*pu4UsrList != 0) {
				MTWF_PRINT("%s:cmd=update, "
					"target_updated_user_bmp=0x%x, "
					"not_yet_updated_user_bmp:0x%x\n",
					__func__,
					((1 << pCfgDl->u1UserCnt) - 1),
					*pu4UsrList);
			} else {
				Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&grUniMuruManCfgInf, UNI_CMD_MURU_MANUAL_CONFIG);
			}
		} else {

			param_val = rtstrchr(param_type, sep_val);

			if (param_val) {
				*param_val = 0;
				param_val++;
			}

			if (strlen(param_type) && param_val && strlen(param_val)) {
				Ret = uni_hqa_muru_parse_cmd_param_dltx(pAd, param_type, param_val, &grUniMuruManCfgInf);

				if (Ret == FALSE)
					goto error;
			}
		}
	}

error:
	MTWF_PRINT("%s: cmd sub-group = %s, Ret = %d\n",
			 __func__, param_type, Ret);
	return Ret;
}

INT32 uni_hqa_muru_set_ul_tx_muru_config(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret = TRUE;
	char sep_val = ':';
	RTMP_STRING *param_type, *param_val;

	UINT32	*pu4UsrList;
	UINT32	*pu4ManCfgBmpUl;
	UINT32	*pu4ManCfgBmpCmm;

	struct UNI_MURU_UL_MANUAL_CONFIG *pCfgUl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;

	pu4UsrList = &gu4UniMuruManCfgUsrListUl;
	pu4ManCfgBmpUl = &grUniMuruManCfgInf.u4ManCfgBmpUl;
	pu4ManCfgBmpCmm = &grUniMuruManCfgInf.u4ManCfgBmpCmm;
	pCfgUl = &grUniMuruManCfgInf.rCfgUl;
	pCfgCmm = &grUniMuruManCfgInf.rCfgCmm;

	param_type = arg;
	if (strlen(param_type)) {

		if (strcmp("init", param_type) == 0) {
			/* init */
			*pu4UsrList = 0;
			*pu4ManCfgBmpUl = 0;
			*pu4ManCfgBmpCmm &= ~(MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
			pCfgCmm->u1PpduFmt &= ~MURU_PPDU_HE_TRIG;
			pCfgCmm->u1SchType &= ~MURU_OFDMA_SCH_TYPE_UL;
			os_zero_mem(pCfgUl, sizeof(struct UNI_MURU_UL_MANUAL_CONFIG));

			if (pAd->CommonCfg.HE_OfdmaUserNum) {
				pCfgUl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
				*pu4ManCfgBmpUl |= MURU_FIXED_UL_TOTAL_USER_CNT;
			}

			if (pAd->CommonCfg.HE_PpduFmt) {
				pCfgCmm->u1PpduFmt = (uint8_t)(pAd->CommonCfg.HE_PpduFmt);
				*pu4ManCfgBmpCmm |= MURU_FIXED_CMM_PPDU_FMT;
			}

			if (pAd->CommonCfg.HE_OfdmaSchType) {
				pCfgCmm->u1SchType = (uint8_t)(pAd->CommonCfg.HE_OfdmaSchType);
				*pu4ManCfgBmpCmm |= MURU_FIXED_CMM_SCH_TYPE;
			}

			if (pAd->CommonCfg.HE_TrigPadding) {
				if (pAd->CommonCfg.HE_TrigPadding == 8)
					pCfgUl->u1TfPad = 1;
				else if (pAd->CommonCfg.HE_TrigPadding == 16)
					pCfgUl->u1TfPad = 2;
				else
					pCfgUl->u1TfPad = 2;

				*pu4ManCfgBmpUl |= MURU_FIXED_UL_TF_PAD;
			}

			Ret = TRUE;
		} else if (strcmp("update", param_type) == 0) {

			if (*pu4UsrList != 0) {
				MTWF_PRINT("%s:cmd=update, "
					"target_updated_user_bmp=0x%x, "
					"not_yet_updated_user_bmp:0x%x\n",
					__func__,
					((1 << pCfgUl->u1UserCnt) - 1),
					*pu4UsrList);
			} else {
				Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&grUniMuruManCfgInf, UNI_CMD_MURU_MANUAL_CONFIG);
			}
		} else {

			param_val = rtstrchr(param_type, sep_val);

			if (param_val) {
				*param_val = 0;
				param_val++;
			}

			if (strlen(param_type) && param_val && strlen(param_val)) {
				Ret = uni_hqa_muru_parse_cmd_param_ultx(pAd, param_type, param_val, &grUniMuruManCfgInf);

				if (Ret == FALSE)
					goto error;
			}
		}
	}

error:
	MTWF_PRINT("%s: cmd sub-group = %s, Ret = %d\n",
			 __func__, param_type, Ret);
	return Ret;
}

INT32 uni_hqa_muru_set_mu_tx_pkt_en(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret;
	char *value = NULL;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT rSetMuTxPktCnt;

	os_zero_mem(&rSetMuTxPktCnt, sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT));

	value = strsep(&arg, ":");
	if (value == NULL)
		return 0;

	rSetMuTxPktCnt.u1BandIdx = (UINT8)os_str_tol(value, 0, 10);

	value = strsep(&arg, "");
	if (value == NULL)
		return 0;

	rSetMuTxPktCnt.u1MuTxEn = (UINT8)os_str_tol(value, 0, 10);

	Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&rSetMuTxPktCnt, UNI_CMD_MURU_SET_MU_TX_PKT_EN);

	return Ret;
}

INT32 uni_hqa_muru_set_mu_tx_pkt_cnt(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret;
	char *value = NULL;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT rSetMuTxPktCnt;

	os_zero_mem(&rSetMuTxPktCnt, sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT));

	value = strsep(&arg, ":");
	if (value == NULL)
		return 0;
	rSetMuTxPktCnt.u1BandIdx = (UINT8)os_str_tol(value, 0, 10);

	value = strsep(&arg, "");
	if (value == NULL)
		return 0;
	rSetMuTxPktCnt.u4MuTxPktCnt = (UINT32)os_str_tol(value, 0, 10);

	Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&rSetMuTxPktCnt, UNI_CMD_MURU_SET_MU_TX_PKT_CNT);

	return Ret;
}

INT32 uni_set_pqs_manual_scs(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret;
	char *p;
	RTMP_STRING *sep_val = "-";
	RTMP_STRING *param_val = arg;
	UINT32 auParamArray[UNI_CMD_PQS_MANUAL_SCS_PARA_CNT] = {0};
	UINT8 i = 0;

	p = rstrtok(param_val, sep_val);

	while (p != NULL) {
		auParamArray[i++] = os_str_toul(p, 0, 10);
		p = rstrtok(NULL, sep_val);

		if (i == UNI_CMD_PQS_MANUAL_SCS_PARA_CNT)
			break;
	}

	grUniPqsScsManCfgInf.u1Mode = (UINT8)auParamArray[0];
	grUniPqsScsManCfgInf.u2WlanIdx = (UINT16)auParamArray[1];
	grUniPqsScsManCfgInf.u1ScsId = (UINT8)auParamArray[2];
	grUniPqsScsManCfgInf.u1Dir = (UINT8)auParamArray[3];
	grUniPqsScsManCfgInf.u1Tid = (UINT8)auParamArray[4];
	grUniPqsScsManCfgInf.u4DataRate = (UINT32)auParamArray[5];
	grUniPqsScsManCfgInf.u2DelayBound = (UINT16)auParamArray[6];
	grUniPqsScsManCfgInf.u4StartTime = (UINT32)auParamArray[7];

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"set_manual_scs_cmd: Mode=%d, WlanIdx=%d, ScsId=%d, Dir=%d, Tid=%d, DataRate=%d(kbps), DelayBound=%d(ms), StartTime=%d\n",
			grUniPqsScsManCfgInf.u1Mode,
			grUniPqsScsManCfgInf.u2WlanIdx,
			grUniPqsScsManCfgInf.u1ScsId,
			grUniPqsScsManCfgInf.u1Dir,
			grUniPqsScsManCfgInf.u1Tid,
			grUniPqsScsManCfgInf.u4DataRate,
			grUniPqsScsManCfgInf.u2DelayBound,
			grUniPqsScsManCfgInf.u4StartTime);

	Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&grUniPqsScsManCfgInf, UNI_CMD_PQS_SET_MANUAL_SCS_CMD);

	return Ret;
}

INT32 uni_set_muru_manual_config(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret = TRUE;
	char sep_val = ':';
	RTMP_STRING *param_type, *param_val;

	struct UNI_MURU_DL_MANUAL_CONFIG *pCfgDl = NULL;
	struct UNI_MURU_UL_MANUAL_CONFIG *pCfgUl = NULL;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = NULL;
	UINT32 *pCfgBmpDl, *pCfgBmpUl, *pCfgBmpCmm;
	UINT32 *pUsrLstDl, *pUsrLstUl;

	pCfgDl = &grUniMuruManCfgInf.rCfgDl;
	pCfgUl = &grUniMuruManCfgInf.rCfgUl;
	pCfgCmm = &grUniMuruManCfgInf.rCfgCmm;
	pCfgBmpDl = &grUniMuruManCfgInf.u4ManCfgBmpDl;
	pCfgBmpUl = &grUniMuruManCfgInf.u4ManCfgBmpUl;
	pCfgBmpCmm = &grUniMuruManCfgInf.u4ManCfgBmpCmm;
	pUsrLstDl = &gu4UniMuruManCfgUsrListDl;
	pUsrLstUl = &gu4UniMuruManCfgUsrListUl;

	param_type = arg;
	if (strlen(param_type)) {
		if (strcmp("dl_init", param_type) == 0) {
			/* dl_init */
			*pUsrLstDl = 0;
			*pCfgBmpDl = 0;
			pCfgCmm->u1Band = 0;

			pCfgCmm->u1PpduFmt &= ~MURU_PPDU_HE_MU;
			pCfgCmm->u1SchType &= ~MURU_OFDMA_SCH_TYPE_DL;
			*pCfgBmpCmm &= ~(MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
			os_zero_mem(pCfgDl, sizeof(struct UNI_MURU_DL_MANUAL_CONFIG));

			if (pAd->CommonCfg.HE_OfdmaUserNum) {
				pCfgDl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
				*pCfgBmpDl |= MURU_FIXED_TOTAL_USER_CNT;
			}

			if (pAd->CommonCfg.HE_PpduFmt) {
				pCfgCmm->u1PpduFmt = (uint8_t)(pAd->CommonCfg.HE_PpduFmt);
				*pCfgBmpCmm |= MURU_FIXED_CMM_PPDU_FMT;
			}

			if (pAd->CommonCfg.HE_OfdmaSchType) {
				pCfgCmm->u1SchType = (uint8_t)(pAd->CommonCfg.HE_OfdmaSchType);
				*pCfgBmpCmm |= MURU_FIXED_CMM_SCH_TYPE;
			}

			Ret = TRUE;
		} else if (strcmp("ul_init", param_type) == 0) {
			/* ul_init */
			*pUsrLstUl = 0;
			*pCfgBmpUl = 0;
			pCfgCmm->u1Band = 0;

			pCfgCmm->u1PpduFmt &= ~MURU_PPDU_HE_TRIG;
			pCfgCmm->u1SchType &= ~MURU_OFDMA_SCH_TYPE_UL;
			*pCfgBmpCmm &= ~(MURU_FIXED_CMM_PPDU_FMT | MURU_FIXED_CMM_SCH_TYPE);
			os_zero_mem(pCfgUl, sizeof(struct UNI_MURU_UL_MANUAL_CONFIG));

			if (pAd->CommonCfg.HE_OfdmaUserNum) {
				pCfgUl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
				*pCfgBmpUl |= MURU_FIXED_UL_TOTAL_USER_CNT;
			}

			if (pAd->CommonCfg.HE_PpduFmt) {
				pCfgCmm->u1PpduFmt = (uint8_t)(pAd->CommonCfg.HE_PpduFmt);
				*pCfgBmpCmm |= MURU_FIXED_CMM_PPDU_FMT;
			}

			if (pAd->CommonCfg.HE_OfdmaSchType) {
				pCfgCmm->u1SchType = (uint8_t)(pAd->CommonCfg.HE_OfdmaSchType);
				*pCfgBmpCmm |= MURU_FIXED_CMM_SCH_TYPE;
			}

			if (pAd->CommonCfg.HE_TrigPadding) {
				if (pAd->CommonCfg.HE_TrigPadding == 8)
					pCfgUl->u1TfPad = 1;
				else if (pAd->CommonCfg.HE_TrigPadding == 16)
					pCfgUl->u1TfPad = 2;
				else
					pCfgUl->u1TfPad = 2;

				*pCfgBmpUl |= MURU_FIXED_UL_TF_PAD;
			}

			Ret = TRUE;
		} else if (strcmp("init", param_type) == 0) {
			*pUsrLstDl = 0;
			*pCfgBmpDl = 0;
			*pUsrLstUl = 0;
			*pCfgBmpUl = 0;
			*pCfgBmpCmm = 0;

			os_zero_mem(pCfgDl, sizeof(struct UNI_MURU_DL_MANUAL_CONFIG));
			os_zero_mem(pCfgUl, sizeof(struct UNI_MURU_UL_MANUAL_CONFIG));
			os_zero_mem(pCfgCmm, sizeof(struct UNI_MURU_CMM_MANUAL_CONFIG));
			Ret = TRUE;
		} else if (strcmp("update", param_type) == 0) {
			/* update */
			Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&grUniMuruManCfgInf, UNI_CMD_MURU_MANUAL_CONFIG);
		} else {

			param_val = rtstrchr(param_type, sep_val);

			if (param_val) {
				*param_val = 0;
				param_val++;
			}

			if (strlen(param_type) && param_val && strlen(param_val)) {
				Ret = uni_muru_parse_cmd_param_muru_manual_config(pAd, param_type, param_val, &grUniMuruManCfgInf);

				if (Ret == FALSE)
					goto error;
			}
		}
	}

error:
	MTWF_PRINT("%s: cmd sub-group = %s, Ret = %d\n",
			 __func__, param_type, Ret);
	return Ret;
}


VOID uni_muru_update_he_cfg(
	struct _RTMP_ADAPTER *pAd
)
{
	INT32 Ret = TRUE;
	struct UNI_MURU_DL_MANUAL_CONFIG *pCfgDl = &grUniMuruManCfgInf.rCfgDl;
	struct UNI_MURU_UL_MANUAL_CONFIG *pCfgUl = &grUniMuruManCfgInf.rCfgUl;
	struct UNI_MURU_CMM_MANUAL_CONFIG *pCfgCmm = &grUniMuruManCfgInf.rCfgCmm;
	UINT32 *pCfgBmpDl = &grUniMuruManCfgInf.u4ManCfgBmpDl;
	UINT32 *pCfgBmpUl = &grUniMuruManCfgInf.u4ManCfgBmpUl;
	UINT32 *pCfgBmpCmm = &grUniMuruManCfgInf.u4ManCfgBmpCmm;
	INT32 updateCfg = FALSE;

	if (pAd->CommonCfg.HE_OfdmaUserNum) {
		pCfgDl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
		*pCfgBmpDl |= MURU_FIXED_TOTAL_USER_CNT;

		pCfgUl->u1UserCnt = (uint8_t)(pAd->CommonCfg.HE_OfdmaUserNum);
		*pCfgBmpUl |= MURU_FIXED_UL_TOTAL_USER_CNT;

		updateCfg |= TRUE;
	}

	if (pAd->CommonCfg.HE_PpduFmt) {
		pCfgCmm->u1PpduFmt = (uint8_t)(pAd->CommonCfg.HE_PpduFmt);
		*pCfgBmpCmm |= MURU_FIXED_CMM_PPDU_FMT;
		updateCfg |= TRUE;
	}

	if (pAd->CommonCfg.HE_OfdmaSchType) {
		pCfgCmm->u1SchType = (uint8_t)(pAd->CommonCfg.HE_OfdmaSchType);
		*pCfgBmpCmm |= MURU_FIXED_CMM_SCH_TYPE;
		updateCfg |= TRUE;
	}

	if (pAd->CommonCfg.HE_TrigPadding) {
		if (pAd->CommonCfg.HE_TrigPadding == 8)
			pCfgUl->u1TfPad = 1;
		else if (pAd->CommonCfg.HE_TrigPadding == 16)
			pCfgUl->u1TfPad = 2;
		else
			pCfgUl->u1TfPad = 2;

		*pCfgBmpUl |= MURU_FIXED_UL_TF_PAD;
		updateCfg |= TRUE;
	}

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"set muru_update_he_cfg()!!!!\n");

	if (updateCfg == TRUE) {
		if (UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&grUniMuruManCfgInf, UNI_CMD_MURU_MANUAL_CONFIG) == FALSE) {
			Ret = FALSE;
			goto error;
		}
	}
error:
		MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
				"(Ret = %d_\n", Ret);
}

INT32 UniCmdMuruSetManualConfig(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_MANUAL_CONFIG_T *pCmdManCfgCtrl = (struct UNI_CMD_MURU_MANUAL_CONFIG_T *)pHandle;
	struct UNI_MURU_MANUAL_CONFIG_T *pMuruManCfg = (struct UNI_MURU_MANUAL_CONFIG_T *)arg;

	pCmdManCfgCtrl->u2Tag = UNI_CMD_MURU_MANUAL_CONFIG;
	pCmdManCfgCtrl->u2Length = sizeof(*pCmdManCfgCtrl);
	pCmdManCfgCtrl->u1CmdVersion = (getHWSupportByChip(pAd) == UNI_HW_CHIP_SUPP_EHT) ? UNI_CMD_MURU_VER_EHT : UNI_CMD_MURU_VER_HE;

	memcpy(&pCmdManCfgCtrl->rMuruManCfg, pMuruManCfg, sizeof(*pMuruManCfg));

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPqsSetManualScsConfig(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_PQS_MANUAL_SCS_CONFIG_T *pCmdScsCfgCtrl = (struct UNI_CMD_PQS_MANUAL_SCS_CONFIG_T *)pHandle;
	struct UNI_PQS_MANUAL_SCS_CONFIG_T *pScsManCfg = (struct UNI_PQS_MANUAL_SCS_CONFIG_T *)arg;

	pCmdScsCfgCtrl->u2Tag = UNI_CMD_PQS_SET_MANUAL_SCS_CMD;
	pCmdScsCfgCtrl->u2Length = sizeof(*pCmdScsCfgCtrl);

	memcpy(&pCmdScsCfgCtrl->rPqsScsCfg, pScsManCfg, sizeof(*pScsManCfg));

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetUlTxTrigger(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_UL_TX_TRIG_T *pUniCmd = (struct UNI_CMD_MURU_SET_UL_TX_TRIG_T *)pHandle;
	UINT8 *trig_val = (UINT8 *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_ULTX_TRIGGER;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->u1UlTxTrigger = *trig_val;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetUlTxCntReset(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_UL_TX_CNT_RESET_T *pUniCmd = (struct UNI_CMD_MURU_SET_UL_TX_CNT_RESET_T *)pHandle;
	UINT8 *fgReset = (UINT8 *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_ULTX_CNT_RESET;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->fgReset = *fgReset;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetAggPolicy(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_AGG_POLICY_T *pUniCmd = (struct UNI_CMD_MURU_SET_AGG_POLICY_T *)pHandle;
	struct UNI_CMD_MURU_SET_AGG_POLICY_T *prSetParam = (struct UNI_CMD_MURU_SET_AGG_POLICY_T *)arg;

	pUniCmd->u2Tag = UNI_CMD_MURU_SET_AGGPOLICY;
	pUniCmd->u2Length = sizeof(*pUniCmd);
	pUniCmd->u1AggPolicy = prSetParam->u1AggPolicy;
	pUniCmd->u1DurComp = prSetParam->u1DurComp;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		"u1AggPolicy:%u u1DurComp:%u\n",
		pUniCmd->u1AggPolicy, pUniCmd->u1DurComp);

	return Ret;
}

static INT32 UniCmdMuruSetMuTxPktCnt(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	int32_t Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *pCmdMuTxPktCnt = (struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *)pHandle;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *prSetParam = (struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *)arg;

	pCmdMuTxPktCnt->u2Tag = UNI_CMD_MURU_SET_MU_TX_PKT_CNT;
	pCmdMuTxPktCnt->u2Length = sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT);
	pCmdMuTxPktCnt->u1BandIdx = prSetParam->u1BandIdx;
	pCmdMuTxPktCnt->u4MuTxPktCnt = prSetParam->u4MuTxPktCnt;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"u1BandIdx = %d, u4MuTxPktCnt = %d\n",
		pCmdMuTxPktCnt->u1BandIdx, pCmdMuTxPktCnt->u4MuTxPktCnt);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;

}

static INT32 UniCmdMuruSetMuTxPktEn(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	int32_t Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *pCmdMuTxPktCnt = (struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *)pHandle;
	struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *prSetParam = (struct UNI_CMD_MURU_SET_MU_TXPKT_CNT *)arg;

	pCmdMuTxPktCnt->u2Tag = UNI_CMD_MURU_SET_MU_TX_PKT_EN;
	pCmdMuTxPktCnt->u2Length = sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT);
	pCmdMuTxPktCnt->u1BandIdx = prSetParam->u1BandIdx;
	pCmdMuTxPktCnt->u1MuTxEn = prSetParam->u1MuTxEn;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"u1BandIdx = %d, u1MuTxEn = %d\n",
		pCmdMuTxPktCnt->u1BandIdx, pCmdMuTxPktCnt->u1MuTxEn);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdMuruTestModeTBRXConfig(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_TBRX_CFG_INTERFACER *pTBRXCfgCtrl = (struct UNI_CMD_TBRX_CFG_INTERFACER *)pHandle;
	struct UNI_CMD_TBRX_CFG_INTERFACER *pTBRXCfgArg = (struct UNI_CMD_TBRX_CFG_INTERFACER *)arg;

	memcpy(pTBRXCfgCtrl, pTBRXCfgArg, sizeof(struct UNI_CMD_TBRX_CFG_INTERFACER));

	pTBRXCfgCtrl->u2Tag = UNI_CMD_TEST_MODE_TBRX_CONFIG;
	pTBRXCfgCtrl->u2Length = sizeof(*pTBRXCfgCtrl) - 2*sizeof(uint16_t);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdMuruSetBsrpPerTxop(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_BSRP_PER_TXOP_T *pCtrl = (struct UNI_CMD_MURU_SET_BSRP_PER_TXOP_T *)pHandle;
	UINT8 *fgEnable = (UINT8 *)arg;

	pCtrl->u2Tag = UNI_CMD_MURU_SET_BSRP_PER_TXOP;
	pCtrl->u2Length = sizeof(struct UNI_CMD_MURU_SET_BSRP_PER_TXOP_T);
	pCtrl->u1Enable = *fgEnable;

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d) Enable=%d\n", Ret, *fgEnable);
	return Ret;
}

static INT32 UniCmdMuruTxcTxStatsEn(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_TXC_TX_STATS_EN *pTxcTxStatsEn = (struct UNI_CMD_TXC_TX_STATS_EN *)pHandle;
	UINT8 *txc_tx_enable = (UINT8 *)arg;

	pTxcTxStatsEn->u1TxcTxEnable = *txc_tx_enable;

	pTxcTxStatsEn->u2Tag = UNI_CMD_MURU_SET_TXC_TX_STATS_EN;
	pTxcTxStatsEn->u2Length = sizeof(*pTxcTxStatsEn);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetDvBlacklistCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL *prDrvBlacklistCtrl = (struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL *)pHandle;
	struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL *prDrvBlacklistArg = (struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL *)arg;

	memcpy(prDrvBlacklistCtrl, prDrvBlacklistArg, sizeof(struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL));

	prDrvBlacklistCtrl->u2Tag = UNI_CMD_MURU_SET_DRV_BLACKLIST_CTRL;
	prDrvBlacklistCtrl->u2Length = sizeof(*prDrvBlacklistCtrl);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetQosCfg(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_QOS_CFG *prQosCfg = (struct UNI_CMD_MURU_QOS_CFG *)pHandle;
	struct UNI_CMD_MURU_QOS_CFG *prQosCfgArg = (struct UNI_CMD_MURU_QOS_CFG *)arg;

	memcpy(prQosCfg, prQosCfgArg, sizeof(struct UNI_CMD_MURU_QOS_CFG));

	prQosCfg->u2Tag = UNI_CMD_MURU_SET_QOS_CFG;
	prQosCfg->u2Length = sizeof(*prQosCfg);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetStatisticConfig(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	PCHAR pch = NULL;
	struct UNI_CMD_MURU_STAT_RECORD_CTRL *prStatisticConf = (struct UNI_CMD_MURU_STAT_RECORD_CTRL *)pHandle;

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		prStatisticConf->u1Mode = os_str_tol(pch, 0, 10);
		MTWF_PRINT("ctrl.u1Mode = %u\n", prStatisticConf->u1Mode);
		if (prStatisticConf->u1Mode > MODE_C) {
			Ret = 0;
			goto error;
		}
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		prStatisticConf->u2StartWcid = os_str_tol(pch, 0, 10);
		MTWF_PRINT("ctrl.u2StartWcid = %u\n", prStatisticConf->u2StartWcid);
	} else {
		Ret = 0;
		goto error;
	}

	pch = strsep(&arg, "-");
	if (pch != NULL) {
		prStatisticConf->u2EndWcid = os_str_tol(pch, 0, 10);
		MTWF_PRINT(":(ctrl.u2EndWcid = %u\n", prStatisticConf->u2EndWcid);
	} else {
		Ret = 0;
		goto error;
	}


	pch = strsep(&arg, "-");
	if (pch != NULL) {
		prStatisticConf->u2TimerInterval = os_str_tol(pch, 0, 10);
		MTWF_PRINT(":(ctrl.u2TimerInterval = %u\n", prStatisticConf->u2TimerInterval);
	} else {
		Ret = 0;
		goto error;
	}


	prStatisticConf->u2Tag = UNI_CMD_MURU_SET_STATISTIC_CONFIG;
	prStatisticConf->u2Length = sizeof(*prStatisticConf);

error:
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetIgnoreNav(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_IGNORE_NAV *prIgnore = (struct UNI_CMD_MURU_IGNORE_NAV *)pHandle;
	UINT8 *ignore = (UINT8 *)arg;

	prIgnore->u1Ignore = *ignore;
	prIgnore->u2Tag = UNI_CMD_MURU_SET_IGNORE_NAV;
	prIgnore->u2Length = sizeof(struct UNI_CMD_MURU_IGNORE_NAV);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;

}

static INT32 UniCmdMuruCertSendFrameCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_CERT_FRAME_CTRL *prCertSendFrameCtrl = (struct UNI_CMD_MURU_CERT_FRAME_CTRL *)pHandle;
	struct UNI_CMD_MURU_CERT_FRAME_CTRL *prCertSendFrameArg = (struct UNI_CMD_MURU_CERT_FRAME_CTRL *)arg;

	memcpy(prCertSendFrameCtrl, prCertSendFrameArg, sizeof(struct UNI_CMD_MURU_CERT_FRAME_CTRL));

	prCertSendFrameCtrl->u2Tag = UNI_CMD_MURU_CERT_SEND_FRAME_CTRL;
	prCertSendFrameCtrl->u2Length = sizeof(struct UNI_CMD_MURU_CERT_FRAME_CTRL);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;

}

static INT32 UniCmdMuruCertMuEdcaOverRide(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_CERT_MU_EDCA_OVERRIDE *prEdcaOverRide = (struct UNI_CMD_MURU_CERT_MU_EDCA_OVERRIDE *)pHandle;
	UINT8 *over_ride = (UINT8 *)arg;

	prEdcaOverRide->u1OverRide = *over_ride;
	prEdcaOverRide->u2Tag = UNI_CMD_MURU_SET_CERT_MU_EDCA_OVERRIDE;
	prEdcaOverRide->u2Length = sizeof(struct UNI_CMD_MURU_CERT_MU_EDCA_OVERRIDE);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetMuDlAckPolicy(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_POLICY_TYPE_T *pCmdMuruPolicyCtrl = (struct UNI_CMD_MURU_SET_POLICY_TYPE_T *)pHandle;
	UINT8 *policy_type = (UINT8 *)arg;

	pCmdMuruPolicyCtrl->u1AckPolicy = *policy_type;
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruPolicyCtrl->u1AckPolicy);

	pCmdMuruPolicyCtrl->u2Tag = UNI_CMD_MURU_SET_MUDL_ACK_POLICY;
	pCmdMuruPolicyCtrl->u2Length = sizeof(*pCmdMuruPolicyCtrl);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetTrigType(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_TRIG_TYPE_T *pCmdMuruTrigCtrl = (struct UNI_CMD_MURU_SET_TRIG_TYPE_T *)pHandle;
	UINT8 *trig_type = (UINT8 *)arg;

	pCmdMuruTrigCtrl->u1TrigValue = *trig_type;
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruTrigCtrl->u1TrigValue);

	pCmdMuruTrigCtrl->u2Tag = UNI_CMD_MURU_SET_TRIG_TYPE;
	pCmdMuruTrigCtrl->u2Length = sizeof(*pCmdMuruTrigCtrl);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetTrigVariant(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_TRIG_VARIANT_T *pCmdMuruTrigCtrl = (struct UNI_CMD_MURU_SET_TRIG_VARIANT_T *)pHandle;
	UINT8 *trig_variant = (UINT8 *)arg;

	pCmdMuruTrigCtrl->u1TrigVariant = *trig_variant;
	MTWF_PRINT("%s: %d\n", __func__,  pCmdMuruTrigCtrl->u1TrigVariant);

	pCmdMuruTrigCtrl->u2Tag = UNI_CMD_MURU_SET_TRIG_VARIANT;
	pCmdMuruTrigCtrl->u2Length = sizeof(*pCmdMuruTrigCtrl);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSet20MDynAlgo(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_20M_DYN_ALGO_T *pCmdMuru20MDynCtrl = (struct UNI_CMD_MURU_SET_20M_DYN_ALGO_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuru20MDynCtrl->u1DynAlgoEnable = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		goto error;
	}
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuru20MDynCtrl->u1DynAlgoEnable);

	pCmdMuru20MDynCtrl->u2Tag = UNI_CMD_MURU_SET_20M_DYN_ALGO;
	pCmdMuru20MDynCtrl->u2Length = sizeof(*pCmdMuru20MDynCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruProtFrameThr(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_PROT_FRAME_THR_T *pCmdMuruProtFrameThrCtrl = (struct UNI_CMD_MURU_SET_PROT_FRAME_THR_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruProtFrameThrCtrl->u4ProtFrameThr = os_str_tol(pch, 0, 10);
#ifdef CFG_BIG_ENDIAN
		pCmdMuruProtFrameThrCtrl->u4ProtFrameThr
			= cpu2le32(pCmdMuruProtFrameThrCtrl->u4ProtFrameThr);
#endif
	else {
		Ret = 0;
		goto error;
	}
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruProtFrameThrCtrl->u4ProtFrameThr);

	pCmdMuruProtFrameThrCtrl->u2Tag = UNI_CMD_MURU_PROT_FRAME_THR;
	pCmdMuruProtFrameThrCtrl->u2Length = sizeof(*pCmdMuruProtFrameThrCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetTxopOnOff(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_TXOP_ONOFF_T *pCmdMuruTxopCtrl = (struct UNI_CMD_MURU_SET_TXOP_ONOFF_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruTxopCtrl->u1TxopOnOff = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		goto error;
	}
	MTWF_PRINT("%s: %d\n", __func__, pCmdMuruTxopCtrl->u1TxopOnOff);

	pCmdMuruTxopCtrl->u2Tag = UNI_CMD_MURU_SET_TXOP_ONOFF;
	pCmdMuruTxopCtrl->u2Length = sizeof(*pCmdMuruTxopCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetUlOnOff(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_UL_ONOFF_T *pCmdMuruUlCtrl = (struct UNI_CMD_MURU_UL_ONOFF_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruUlCtrl->u2UlBsrpOnOff = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		MTWF_PRINT("invalid format, iwpriv ra0 set set_muru_ul_off=[bsrp]-[data]\n");
		goto error;
	}

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pCmdMuruUlCtrl->u2UlDataOnOff = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		MTWF_PRINT("invalid format, iwpriv ra0 set set_muru_ul_off=[bsrp]-[data]\n");
		goto error;
	}
	MTWF_PRINT("%s: bsrp=%d data=%d\n", __func__,
		pCmdMuruUlCtrl->u2UlBsrpOnOff, pCmdMuruUlCtrl->u2UlDataOnOff);

	pCmdMuruUlCtrl->u2Tag = UNI_CMD_MURU_UL_ONOFF;
	pCmdMuruUlCtrl->u2Length = sizeof(*pCmdMuruUlCtrl);

error:

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 uni_muru_set_drv_black_list_ctrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg
)
{
	INT32 Ret;
	PCHAR pch = NULL;
	/* prepare command message */
	struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL rMuruDrvBlackCtrl = {0};
	UINT_8 temp = 0;

	pch = strsep(&arg, ":");
	if (pch != NULL)
		rMuruDrvBlackCtrl.u2WlanId = os_str_tol(pch, 0, 10);
	else {
		Ret = FALSE;
		goto error;
	}

	pch = strsep(&arg, ":");
	if (pch != NULL)
		temp = os_str_tol(pch, 0, 10);
	else {
		Ret = FALSE;
		goto error;
	}

	rMuruDrvBlackCtrl.fgDrvBlackListDlOfdmaDisable = (temp & MURU_DRV_BLACK_LIST_DL_OFDMA_DISABLE) ? TRUE : FALSE;
	rMuruDrvBlackCtrl.fgDrvBlackListUlOfdmaDisable = (temp & MURU_DRV_BLACK_LIST_UL_OFDMA_DISABLE) ? TRUE : FALSE;

	Ret = UniCmdMuruParameterSet(pAd, (RTMP_STRING *)&rMuruDrvBlackCtrl, UNI_CMD_MURU_SET_DRV_BLACKLIST_CTRL);

error:

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;

}

static INT32 UniCmdMuruSetCtsRetry(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_CTS_RETRY_CTRL_T *pCmdCtsRetryCtrl = (struct UNI_CMD_MURU_CTS_RETRY_CTRL_T *)pHandle;
	struct UNI_CMD_MURU_CTS_RETRY_CTRL_T *pCtsRetryCtrl = (struct UNI_CMD_MURU_CTS_RETRY_CTRL_T *)arg;

	memcpy(pCmdCtsRetryCtrl, pCtsRetryCtrl, sizeof(*pCmdCtsRetryCtrl));

	pCmdCtsRetryCtrl->u2Tag = UNI_CMD_MURU_CTS_RETRY_CTRL;
	pCmdCtsRetryCtrl->u2Length = sizeof(*pCmdCtsRetryCtrl);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruSetBfInACQ(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_SET_BF_IN_AC01_T *pCmd = (struct UNI_CMD_MURU_SET_BF_IN_AC01_T *)pHandle;
	BOOL *bf_in_acq = (BOOL *)arg;

	pCmd->u2Tag = UNI_CMD_MURU_SET_BF_IN_AC01;
	pCmd->u2Length = sizeof(*pCmd);
	pCmd->u1Enable = *bf_in_acq;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_PHY, DBG_LVL_INFO,
		"(u1Enable = %d)\n", pCmd->u1Enable);
	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdSetMuruTab[] = {
	{
		.u8CmdFeature = UNI_CMD_MURU_BSRP_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_BSRP_CTRL_T),
		.pfHandler = UniCmdMuruBsrpCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_ARB_OP_MODE,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_ARB_OP_MODE_T),
		.pfHandler = UniCmdMuruSetArbOpMode
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_ALGO_DBG_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_ALGO_DBG_CTRL_T),
		.pfHandler = UniCmdMuruSetAlgoDbgCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SUTX_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_SUTX_T),
		.pfHandler = UniCmdMuruSuTxCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_FIXED_RATE_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_FIXED_RATE_CTRL_T),
		.pfHandler = UniCmdMuruSetFixedRate
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_FIXED_GRP_RATE_CTRL_T),
		.pfHandler = UniCmdMuruSetFixedGroupRate
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_IGNORE_NAV,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_IGNORE_NAV),
		.pfHandler = UniCmdMuruSetIgnoreNav
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_CERT_SEND_FRAME_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_CERT_FRAME_CTRL),
		.pfHandler = UniCmdMuruCertSendFrameCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_DBG_INFO,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_DBG_INFO),
		.pfHandler = UniCmdMuruSetDbgInfo
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_FORCE_MU,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_DBG_INFO),
		.pfHandler = UniCmdMuruSetForceMu
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_GET_UL_RU_STATUS,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_GET_ULRU_STATUS_T),
		.pfHandler = UniCmdMuruShowUlRuStatus
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_CFG_DLUL_LIMIT,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_DLUL_LIMITS_T),
		.pfHandler = UniCmdMuruSetDlUlLimits
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_DLUL_EN,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_DLUL_VAL_T),
		.pfHandler = UniCmdMuruSetDlUlConfig
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_MANUAL_CONFIG,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_MANUAL_CONFIG_T),
		.pfHandler = UniCmdMuruSetManualConfig
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_ULTX_TRIGGER,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_UL_TX_TRIG_T),
		.pfHandler = UniCmdMuruSetUlTxTrigger
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_ULTX_CNT_RESET,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_UL_TX_CNT_RESET_T),
		.pfHandler = UniCmdMuruSetUlTxCntReset
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_AGGPOLICY,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_AGG_POLICY_T),
		.pfHandler = UniCmdMuruSetAggPolicy
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_MU_TX_PKT_CNT,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT),
		.pfHandler = UniCmdMuruSetMuTxPktCnt
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_MU_TX_PKT_EN,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_MU_TXPKT_CNT),
		.pfHandler = UniCmdMuruSetMuTxPktEn
	},
	{
		.u8CmdFeature = UNI_CMD_TEST_MODE_TBRX_CONFIG,
		.u4StructSize = sizeof(struct UNI_CMD_TBRX_CFG_INTERFACER),
		.pfHandler = UniCmdMuruTestModeTBRXConfig
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_BSRP_PER_TXOP,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_BSRP_PER_TXOP_T),
		.pfHandler = UniCmdMuruSetBsrpPerTxop
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_TXC_TX_STATS_EN,
		.u4StructSize = sizeof(struct UNI_CMD_TXC_TX_STATS_EN),
		.pfHandler = UniCmdMuruTxcTxStatsEn
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_POLICY_TYPE_T),
		.pfHandler = UniCmdMuruSetMuDlAckPolicy
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_TRIG_TYPE,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_TRIG_TYPE_T),
		.pfHandler = UniCmdMuruSetTrigType
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_20M_DYN_ALGO,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_20M_DYN_ALGO_T),
		.pfHandler = UniCmdMuruSet20MDynAlgo
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_PROT_FRAME_THR,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_PROT_FRAME_THR_T),
		.pfHandler = UniCmdMuruProtFrameThr
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_CERT_MU_EDCA_OVERRIDE,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_CERT_MU_EDCA_OVERRIDE),
		.pfHandler = UniCmdMuruCertMuEdcaOverRide
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_DRV_BLACKLIST_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_DRV_BLACKLIST_CTRL),
		.pfHandler = UniCmdMuruSetDvBlacklistCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_TXOP_ONOFF,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_TXOP_ONOFF_T),
		.pfHandler = UniCmdMuruSetTxopOnOff
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_UL_ONOFF,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_UL_ONOFF_T),
		.pfHandler = UniCmdMuruSetUlOnOff
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_STATISTIC_CONFIG,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_STAT_RECORD_CTRL),
		.pfHandler = UniCmdMuruSetStatisticConfig
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_QOS_CFG,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_QOS_CFG),
		.pfHandler = UniCmdMuruSetQosCfg
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_CTS_RETRY_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_CTS_RETRY_CTRL_T),
		.pfHandler = UniCmdMuruSetCtsRetry
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_MDVT_INFO,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_MDVT_INFO_T),
		.pfHandler = UniCmdMuruSetMdvtInfo
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_TRIG_VARIANT,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_TRIG_VARIANT_T),
		.pfHandler = UniCmdMuruSetTrigVariant
	},
	{
		.u8CmdFeature = UNI_CMD_PQS_SET_MANUAL_SCS_CMD,
		.u4StructSize = sizeof(struct UNI_CMD_PQS_MANUAL_SCS_CONFIG_T),
		.pfHandler = UniCmdPqsSetManualScsConfig
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_SET_BF_IN_AC01,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_SET_BF_IN_AC01_T),
		.pfHandler = UniCmdMuruSetBfInACQ
	},
};

INT32 UniCmdMuruParameterSet(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING *arg, UINT64 u8EnableFeature)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 ucTLVNumber = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 SetMuruTabSize = ARRAY_SIZE(UniCmdSetMuruTab);
	struct UNI_CMD_MURU_T *pCmdMuruUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_MURU_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < SetMuruTabSize; i++) {
		if (UniCmdSetMuruTab[i].u8CmdFeature == u8EnableFeature) {
			u4CmdNeedMaxBufSize += UniCmdSetMuruTab[i].u4StructSize;
			break;
		}
	}

	if (i == SetMuruTabSize) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Can't found this input feature: 0x%lx\n", u8EnableFeature);
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdMuruUpdate = (struct UNI_CMD_MURU_T *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Fill params of  supported feature */
	if (UniCmdSetMuruTab[i].pfHandler != NULL) {
		Ret = ((PFN_MURU_HANDLE)(UniCmdSetMuruTab[i].pfHandler))(pAd, arg, pNextHeadBuf);
		if (Ret == NDIS_STATUS_SUCCESS) {
			pNextHeadBuf += UniCmdSetMuruTab[i].u4StructSize;
			ucTLVNumber++;
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN bNeedFrag = FALSE;
		BOOLEAN bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			if (u8EnableFeature == UNI_CMD_MURU_SET_QOS_CFG)
				SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4N9);
			else
				SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);

			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MURU);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG, "(Ret = %d)\n", Ret);
	if (Ret == NDIS_STATUS_SUCCESS)
		return TRUE;
	else
		return FALSE;
}

static INT32 UniCmdMuruGetGroupTblEntry(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_GET_GROUP_TBL_ENTRY_T *pUniCmd = (struct UNI_CMD_MURU_GET_GROUP_TBL_ENTRY_T *)pHandle;
	UINT16 *index = (UINT16 *)arg;

	pUniCmd->u2Index = *index;
	pUniCmd->u2Tag = UNI_CMD_MURU_GET_GROUP_TBL_ENTRY;
	pUniCmd->u2Length = sizeof(*pUniCmd);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdMuruGetUlTxCnt(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID *pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_GET_UL_TX_CNT_T *pUniCmd = (struct UNI_CMD_MURU_GET_UL_TX_CNT_T *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pUniCmd->u4Index = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		goto error;
	}

	pUniCmd->u2Tag = UNI_CMD_MURU_GET_ULTX_CNT;
	pUniCmd->u2Length = sizeof(*pUniCmd);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);

error:
	return Ret;
}

static INT32 UniCmdMuruGetTxcTxStats(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_TXC_TX_STATS *pUniCmd = (struct UNI_CMD_MURU_TXC_TX_STATS *)pHandle;
	PCHAR pch = NULL;

	pch = strsep(&arg, "-");

	if (pch != NULL)
		pUniCmd->u1BandIdx = os_str_tol(pch, 0, 10);
	else {
		Ret = 0;
		goto error;
	}

	pUniCmd->u2Tag = UNI_CMD_MURU_GET_TXC_TX_STATS;
	pUniCmd->u2Length = sizeof(*pUniCmd);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);

error:
	return Ret;
}

static INT32 UniCmdMuruGetFwBlacklistCtrl(
	struct _RTMP_ADAPTER *pAd,
	RTMP_STRING *arg,
	VOID * pHandle
)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MURU_FW_BLACKLIST_CTRL *pUniCmd = (struct UNI_CMD_MURU_FW_BLACKLIST_CTRL *)pHandle;
	UINT16 *u2WlanIdx = (UINT16 *)arg;

	pUniCmd->u2WlanIdx = *u2WlanIdx;
	pUniCmd->u2Tag = UNI_CMD_MURU_GET_FW_BLACKLIST_CTRL;
	pUniCmd->u2Length = sizeof(*pUniCmd);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);

	return Ret;
}



static UNI_CMD_TAG_HANDLE_T UniCmdGetMuruTab[] = {
	{
		.u8CmdFeature = UNI_CMD_MURU_GET_GROUP_TBL_ENTRY,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_GET_GROUP_TBL_ENTRY_T),
		.pfHandler = UniCmdMuruGetGroupTblEntry
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_GET_ULTX_CNT,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_GET_UL_TX_CNT_T),
		.pfHandler = UniCmdMuruGetUlTxCnt
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_GET_TXC_TX_STATS,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_TXC_TX_STATS),
		.pfHandler = UniCmdMuruGetTxcTxStats
	},
	{
		.u8CmdFeature = UNI_CMD_MURU_GET_FW_BLACKLIST_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_MURU_FW_BLACKLIST_CTRL),
		.pfHandler = UniCmdMuruGetFwBlacklistCtrl
	},

};

UINT16 UniCmdMuruGetRspSize(UINT64 u8EnableFeature)
{
	UINT16 ret_size = 0;

	if (UNI_CMD_MURU_GET_GROUP_TBL_ENTRY)
		ret_size = (UINT16)sizeof(MUCOP_GROUP_TBL_ENTRY_T);
	else if (UNI_CMD_MURU_GET_ULTX_CNT)
		ret_size = (UINT16)sizeof(EVENT_MURU_GET_UL_TX_CNT);

	return ret_size;
}

INT32 UniCmdMuruParameterGet(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING *arg, UINT64 u8EnableFeature)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 ucTLVNumber = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 GetMuruTabSize = ARRAY_SIZE(UniCmdGetMuruTab);
	struct UNI_CMD_MURU_T *pCmdMuruUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
	UINT16 rsp_size;
	UINT8 *rsp = NULL;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_MURU_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < GetMuruTabSize; i++) {
		if (UniCmdGetMuruTab[i].u8CmdFeature == u8EnableFeature) {
			u4CmdNeedMaxBufSize += UniCmdGetMuruTab[i].u4StructSize;
			break;
		}
	}

	if (i == GetMuruTabSize) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"Can't found this input feature: 0x%lx\n", u8EnableFeature);
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	rsp_size = UniCmdMuruGetRspSize(u8EnableFeature) + sizeof(struct _UNI_EVENT_MURU_TLV_T);
	os_alloc_mem(pAd, (UCHAR **)&rsp, rsp_size);
	if (!rsp) {
		Ret = NDIS_STATUS_RESOURCES;
		MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"allocate memory for rsp failed!\n");
		goto error;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdMuruUpdate = (struct UNI_CMD_MURU_T *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Fill params of  supported feature */
	if (UniCmdGetMuruTab[i].pfHandler != NULL) {
		Ret = ((PFN_MURU_HANDLE)(UniCmdGetMuruTab[i].pfHandler))(pAd, arg, pNextHeadBuf);
		if (Ret == NDIS_STATUS_SUCCESS) {
			pNextHeadBuf += UniCmdGetMuruTab[i].u4StructSize;
			ucTLVNumber++;
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN bNeedFrag = FALSE;
		BOOLEAN bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MURU);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, rsp);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, rsp_size);
				SET_CMD_ATTR_RSP_HANDLER(attr, muruUniEventDispatcher);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	if (rsp)
		os_free_mem(rsp);

	if (Ret == NDIS_STATUS_SUCCESS)
		return TRUE;
	else
		return FALSE;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG, "(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef CFG_SUPPORT_FALCON_PP
static INT32 UniCmdPPEnCtrl(struct _RTMP_ADAPTER *pAd, P_PP_CMD_T pp_cmd_cap, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_PP_EN_CTRL_T pPPEnCtrl = (P_UNI_CMD_PP_EN_CTRL_T)pHandle;

	pPPEnCtrl->u2Tag = UNI_CMD_PP_EN_CTRL;
	pPPEnCtrl->u2Length = sizeof(UNI_CMD_PP_EN_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pPPEnCtrl->u2Tag = cpu2le16(pPPEnCtrl->u2Tag);
	pPPEnCtrl->u2Length = cpu2le16(pPPEnCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pPPEnCtrl->u1DbdcIdx = pp_cmd_cap->dbdc_idx;
	pPPEnCtrl->u1PpCtrl = pp_cmd_cap->pp_ctrl;
	pPPEnCtrl->u1PpMgmtEn = pp_cmd_cap->pp_auto_mode;
	pPPEnCtrl->u1PpBitMap = pp_cmd_cap->pp_bitmap;
	pPPEnCtrl->u1PpMgmtMode = pp_cmd_cap->pp_mgmt_mode;
	pPPEnCtrl->fgPpCsaEn = pp_cmd_cap->pp_csa_enable;

	return Ret;
}

static INT32 UniCmdPpDscbCtrl(struct _RTMP_ADAPTER *pAd, struct CMD_STATIC_PP_DSCB_T *pp_dscb, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_DSCB_CTRL_T *pPpDscbCtrl = (struct UNI_CMD_DSCB_CTRL_T *)pHandle;

	if (!pp_dscb)
		return NDIS_STATUS_FAILURE;

	pPpDscbCtrl->u2Tag = UNI_CMD_PP_DSCB_CTRL;
	pPpDscbCtrl->u2Length = sizeof(struct UNI_CMD_DSCB_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pPpDscbCtrl->u2Tag = cpu2le16(pPpDscbCtrl->u2Tag);
	pPpDscbCtrl->u2Length = cpu2le16(pPpDscbCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pPpDscbCtrl->ucBandIdx = pp_dscb->ucBandIdx;
	pPpDscbCtrl->ucOmacIdx = pp_dscb->ucOmacIdx;
	pPpDscbCtrl->fgIsEhtOpPresent = pp_dscb->fgIsEhtOpPresent;
	pPpDscbCtrl->fgIsEhtDscpPresent = pp_dscb->fgIsEhtDscpPresent;
	pPpDscbCtrl->ucEhtCtrl = pp_dscb->ucEhtCtrl;
	pPpDscbCtrl->ucEhtCcfs0 = pp_dscb->ucEhtCcfs0;
	pPpDscbCtrl->ucEhtCcfs1 = pp_dscb->ucEhtCcfs1;
	pPpDscbCtrl->u2EhtDisSubChanBitmap = pp_dscb->u2DscbBitmap;
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"(%d, %d, %d, %d, %x, %x, %x, %x)\n",
		pPpDscbCtrl->ucBandIdx, pPpDscbCtrl->ucOmacIdx, pPpDscbCtrl->fgIsEhtOpPresent,
		pPpDscbCtrl->fgIsEhtDscpPresent, pPpDscbCtrl->ucEhtCtrl,
		pPpDscbCtrl->ucEhtCcfs0, pPpDscbCtrl->ucEhtCcfs1,
		pPpDscbCtrl->u2EhtDisSubChanBitmap);
	return Ret;
}

static INT32 UniCmdPpMuCtrl(struct _RTMP_ADAPTER *pAd, struct CMD_PP_MU_CTRL_T *pp_mu_ctrl, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_PP_MU_CTRL *pPpMuCtrl = (struct UNI_CMD_PP_MU_CTRL *)pHandle;

	if (!pp_mu_ctrl)
		return NDIS_STATUS_FAILURE;

	pPpMuCtrl->u2Tag = UNI_CMD_PP_MU_OFDMA_CTRL;
	pPpMuCtrl->u2Length = sizeof(struct UNI_CMD_PP_MU_CTRL);
#ifdef CFG_BIG_ENDIAN
	pPpMuCtrl->u2Tag = cpu2le16(pPpMuCtrl->u2Tag);
	pPpMuCtrl->u2Length = cpu2le16(pPpMuCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pPpMuCtrl->ucBssIdx = pp_mu_ctrl->ucBssIdx;
	pPpMuCtrl->PpMuBitmap = pp_mu_ctrl->PpMuBitmap;
	pPpMuCtrl->value = pp_mu_ctrl->value;
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"(%d, %d, %d)\n",
		pPpMuCtrl->ucBssIdx, pPpMuCtrl->PpMuBitmap, pPpMuCtrl->value);
	return Ret;
}

static INT32 UniCmdChangePpCapCtrl(struct _RTMP_ADAPTER *pAd, struct CMD_CHANGE_PP_CAP_CTRL_T *pp_cap_ctrl, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_CHANGE_PP_CAP_CTRL *pPpCapCtrl = (struct UNI_CMD_CHANGE_PP_CAP_CTRL *)pHandle;

	if (!pp_cap_ctrl)
		return NDIS_STATUS_FAILURE;

	pPpCapCtrl->u2Tag = UNI_CMD_PP_CHANGE_CAP_CTRL;
	pPpCapCtrl->u2Length = sizeof(struct UNI_CMD_CHANGE_PP_CAP_CTRL);
#ifdef CFG_BIG_ENDIAN
	pPpCapCtrl->u2Tag = cpu2le16(pPpCapCtrl->u2Tag);
	pPpCapCtrl->u2Length = cpu2le16(pPpCapCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pPpCapCtrl->value1 = pp_cap_ctrl->value1;
	pPpCapCtrl->value2 = pp_cap_ctrl->value2;
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"value(%x,%x)\n", pPpCapCtrl->value1, pPpCapCtrl->value2);
	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdPPCapCtrlTab[PP_CMD_NUM] = {
	{
		.u8CmdFeature = PP_CMD_Reserve,
		.u4StructSize = 0,
		.pfHandler = NULL
	},
	{
		.u8CmdFeature = PP_CMD_SET_PP_CAP_CTRL,
		.u4StructSize = sizeof(UNI_CMD_PP_EN_CTRL_T),
		.pfHandler = UniCmdPPEnCtrl
	},
	{
		.u8CmdFeature = PP_CMD_SET_PP_DSCB_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_DSCB_CTRL_T),
		.pfHandler = UniCmdPpDscbCtrl
	},
	{
		.u8CmdFeature = PP_CMD_SET_PP_MU_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_PP_MU_CTRL),
		.pfHandler = UniCmdPpMuCtrl
	},
	{
		.u8CmdFeature = PP_CMD_CHANGE_PP_CAP_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_CHANGE_PP_CAP_CTRL),
		.pfHandler = UniCmdChangePpCapCtrl
	},
};

INT32 UniCmdPPCapCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_PP_CMD_T pp_cmd_cap,
	struct CMD_STATIC_PP_DSCB_T *dscb,
	struct CMD_PP_MU_CTRL_T *mu_ctrl,
	struct CMD_CHANGE_PP_CAP_CTRL_T *pp_cap)
{
	struct cmd_msg			*msg = NULL;
	INT32					Ret = NDIS_STATUS_SUCCESS;
	UINT32					i = 0;
	UINT16					u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	P_UNI_CMD_PP_T			pCmdPP = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_PP_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < PP_CMD_NUM; i++) {
		if (pp_cmd_cap->cmd_sub_id == UniCmdPPCapCtrlTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdPPCapCtrlTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdPP = (P_UNI_CMD_PP_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < PP_CMD_NUM; i++) {
		if (pp_cmd_cap->cmd_sub_id == UniCmdPPCapCtrlTab[i].u8CmdFeature) {
			switch (UniCmdPPCapCtrlTab[i].u8CmdFeature) {
			case PP_CMD_SET_PP_CAP_CTRL:
				if (UniCmdPPCapCtrlTab[i].pfHandler != NULL) {
					Ret = ((PFN_PP_EN_CTRL_HANDLE)(UniCmdPPCapCtrlTab[i].pfHandler))(pAd, pp_cmd_cap, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdPPCapCtrlTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case PP_CMD_SET_PP_DSCB_CTRL:
				if (UniCmdPPCapCtrlTab[i].pfHandler != NULL) {
					Ret = ((PFN_PP_DSCB_CTRL_HANDLE)(UniCmdPPCapCtrlTab[i].pfHandler))(pAd, dscb, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdPPCapCtrlTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case PP_CMD_SET_PP_MU_CTRL:
				if (UniCmdPPCapCtrlTab[i].pfHandler != NULL) {
					Ret = ((PFN_PP_MU_CTRL_HANDLE)(UniCmdPPCapCtrlTab[i].pfHandler))(pAd, mu_ctrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdPPCapCtrlTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case PP_CMD_CHANGE_PP_CAP_CTRL:
				if (UniCmdPPCapCtrlTab[i].pfHandler != NULL) {
					Ret = ((PFN_PP_CHANGE_CAP_CTRL_HANDLE)(UniCmdPPCapCtrlTab[i].pfHandler))(pAd, pp_cap, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdPPCapCtrlTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdPPCapCtrlTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
						"The hanlder of tag (0x%llx) return fail!\n", UniCmdPPCapCtrlTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO, "TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN bNeedFrag = FALSE;
		BOOLEAN bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PP);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPPAlgCtrl(struct _RTMP_ADAPTER *pAd, struct PP_ALG_CTRL_T *pp_cmd_alg_ctrl)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_PP_ALG_CTRL_T *prPPCmdAlgCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_PP_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_PP_ALG_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	prPPCmdAlgCtrl = (struct UNI_CMD_PP_ALG_CTRL_T *) pNextHeadBuf;
	prPPCmdAlgCtrl->u2Tag = cpu2le16(UNI_CMD_PP_ALG_CTRL);
	prPPCmdAlgCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_PP_ALG_CTRL_T));

	/* Step 3: Filled in parameters of UNI_CMD_PP_ALG_CTRL */
	prPPCmdAlgCtrl->u1DbdcIdx = pp_cmd_alg_ctrl->u1DbdcIdx;
	prPPCmdAlgCtrl->u1PpAction = pp_cmd_alg_ctrl->u1PpAction;
	prPPCmdAlgCtrl->u1Reset = pp_cmd_alg_ctrl->u1Reset;
	prPPCmdAlgCtrl->u4PpTimerIntv = cpu2le32(pp_cmd_alg_ctrl->u4PpTimerIntv);
	prPPCmdAlgCtrl->u4ThrX2_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX2_Value);
	prPPCmdAlgCtrl->u4ThrX2_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX2_Shift);
	prPPCmdAlgCtrl->u4ThrX3_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX3_Value);
	prPPCmdAlgCtrl->u4ThrX3_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX3_Shift);
	prPPCmdAlgCtrl->u4ThrX4_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX4_Value);
	prPPCmdAlgCtrl->u4ThrX4_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX4_Shift);
	prPPCmdAlgCtrl->u4ThrX5_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX5_Value);
	prPPCmdAlgCtrl->u4ThrX5_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX5_Shift);
	prPPCmdAlgCtrl->u4ThrX6_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX6_Value);
	prPPCmdAlgCtrl->u4ThrX6_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX6_Shift);
	prPPCmdAlgCtrl->u4ThrX7_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX7_Value);
	prPPCmdAlgCtrl->u4ThrX7_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX7_Shift);
	prPPCmdAlgCtrl->u4ThrX8_Value = cpu2le32(pp_cmd_alg_ctrl->u4ThrX8_Value);
	prPPCmdAlgCtrl->u4ThrX8_Shift = cpu2le32(pp_cmd_alg_ctrl->u4ThrX8_Shift);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PP);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_NOTICE,
			"(ret = %d)\n", Ret);
	return Ret;
}
#endif /* CFG_SUPPORT_FALCON_PP */

#ifdef TXBF_SUPPORT

INT32 UniCmdETxBfSoundingPeriodicTriggerCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1SndgEn,
	UINT32 u4SNDPeriod,
	UINT8  u1Su_Mu,
	UINT8 u1MuNum,
	UINT8 *pwlanidx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_BF_SND *prETxBfSndPeriodicTriggerCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Sounding trigger enable = %d\n", u1SndgEn);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_SND);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	prETxBfSndPeriodicTriggerCtrl = (struct UNI_CMD_BF_SND *) pNextHeadBuf;
	prETxBfSndPeriodicTriggerCtrl->u2Length = sizeof(struct UNI_CMD_BF_SND);

	if (u1Su_Mu < SOUNDING_MAX) {
		msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	} else {
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	/* Step 3: Filled in parameters of UNI_CMD_BF_SND */
	if (u1SndgEn) {
		if (u1Su_Mu < SOUNDING_MAX) {
			prETxBfSndPeriodicTriggerCtrl->u2Tag = UNI_CMD_BF_SOUNDING_ON;
			prETxBfSndPeriodicTriggerCtrl->u1SuMuSndMode = u1Su_Mu;
			prETxBfSndPeriodicTriggerCtrl->u4SndIntv = cpu2le32(u4SNDPeriod);
			if (pwlanidx) {
				prETxBfSndPeriodicTriggerCtrl->u2WlanId[0] = cpu2le16(pwlanidx[0]);
				prETxBfSndPeriodicTriggerCtrl->u2WlanId[1] = cpu2le16(pwlanidx[1]);
				prETxBfSndPeriodicTriggerCtrl->u2WlanId[2] = cpu2le16(pwlanidx[2]);
				prETxBfSndPeriodicTriggerCtrl->u2WlanId[3] = cpu2le16(pwlanidx[3]);
			}
			prETxBfSndPeriodicTriggerCtrl->u1StaNum = u1MuNum;
		}
	} else {
		prETxBfSndPeriodicTriggerCtrl->u2Tag = UNI_CMD_BF_SOUNDING_OFF;
	}

#ifdef CFG_BIG_ENDIAN
		prETxBfSndPeriodicTriggerCtrl->u2Tag = cpu2le16(prETxBfSndPeriodicTriggerCtrl->u2Tag);
		prETxBfSndPeriodicTriggerCtrl->u2Length = cpu2le16(prETxBfSndPeriodicTriggerCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxBfTxApplyCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2WlanId,
	UINT8 fgETxBf,
	UINT8 fgITxBf,
	UINT8 fgMuTxBf,
	UINT8 fgPhaseCali)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_BF_APPLY_CTRL *prTxBfTxApplyCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"TxBf Tx Apply WLanId = %d, fgETxBf = %d, fgITxBf = %d, fgMuTxBf = %d\n",
			  u2WlanId, fgETxBf, fgITxBf, fgMuTxBf);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_APPLY_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_APPLY_CTRL */
	prTxBfTxApplyCtrl = (struct UNI_CMD_BF_APPLY_CTRL *) pNextHeadBuf;
	prTxBfTxApplyCtrl->u2Tag = UNI_CMD_BF_DATA_PACKET_APPLY;
	prTxBfTxApplyCtrl->u2Length = sizeof(struct UNI_CMD_BF_APPLY_CTRL);
	prTxBfTxApplyCtrl->u2WlanIdx = cpu2le16(u2WlanId);
	prTxBfTxApplyCtrl->fgETxBf = fgETxBf;
	prTxBfTxApplyCtrl->fgITxBf = fgITxBf;
	prTxBfTxApplyCtrl->fgMuTxBf = fgMuTxBf;
	prTxBfTxApplyCtrl->fgPhaseCali = fgPhaseCali;

#ifdef CFG_BIG_ENDIAN
	prTxBfTxApplyCtrl->u2Tag = cpu2le16(prTxBfTxApplyCtrl->u2Tag);
	prTxBfTxApplyCtrl->u2Length = cpu2le16(prTxBfTxApplyCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPfmuMemAlloc(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1Su_Mu,
	UINT16 u2WlanId)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_BF_MEM_ALLOC_CTRL *prTxBfMemAllocCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_DEBUG,
			"u2WlanId = %d\n", u2WlanId);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_MEM_ALLOC_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_MEM_ALLOC_CTRL */
	prTxBfMemAllocCtrl = (struct UNI_CMD_BF_MEM_ALLOC_CTRL *) pNextHeadBuf;
	prTxBfMemAllocCtrl->u2Tag = UNI_CMD_BF_PFMU_MEM_ALLOCATE;
	prTxBfMemAllocCtrl->u2Length = sizeof(struct UNI_CMD_BF_MEM_ALLOC_CTRL);
	prTxBfMemAllocCtrl->u2WlanIdx = cpu2le16(u2WlanId);
	prTxBfMemAllocCtrl->u1SuMu = u1Su_Mu;

#ifdef CFG_BIG_ENDIAN
	prTxBfMemAllocCtrl->u2Tag = cpu2le16(prTxBfMemAllocCtrl->u2Tag);
	prTxBfMemAllocCtrl->u2Length = cpu2le16(prTxBfMemAllocCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPfmuMemRelease(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2WlanId)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_BF_MEM_ALLOC_CTRL *prTxBfMemAllocCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_DEBUG,
			"u2WlanId = %d\n", u2WlanId);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_MEM_ALLOC_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_MEM_ALLOC_CTRL */
	prTxBfMemAllocCtrl = (struct UNI_CMD_BF_MEM_ALLOC_CTRL *) pNextHeadBuf;
	prTxBfMemAllocCtrl->u2Tag = UNI_CMD_BF_PFMU_MEM_RELEASE;
	prTxBfMemAllocCtrl->u2Length = sizeof(struct UNI_CMD_BF_MEM_ALLOC_CTRL);
	prTxBfMemAllocCtrl->u2WlanIdx = cpu2le16(u2WlanId);

#ifdef CFG_BIG_ENDIAN
	prTxBfMemAllocCtrl->u2Tag = cpu2le16(prTxBfMemAllocCtrl->u2Tag);
	prTxBfMemAllocCtrl->u2Length = cpu2le16(prTxBfMemAllocCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuProfileTagRead(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PfmuIdx,
	UINT8 fgBFer,
	UINT8 u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_TAG_RW *prETxBfPfmuProfileTag;
	POS_COOKIE pObj = NULL;
	struct wifi_dev *wdev = NULL;

	pObj = (POS_COOKIE) pAd->OS_Cookie;
	wdev = get_wdev_by_ioctl_idx_and_iftype(pAd, pObj->ioctl_if, pObj->ioctl_if_type);
	txbf_set_last_wdev(wdev);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, BFer: %x, Band:%d\n",
			 u1PfmuIdx, fgBFer, u1BandIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_TAG_RW);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_TAG_Read */
	prETxBfPfmuProfileTag = (struct UNI_CMD_BF_PFMU_TAG_RW *) pNextHeadBuf;
	prETxBfPfmuProfileTag->u2Tag = UNI_CMD_BF_PFMU_TAG_READ;
	prETxBfPfmuProfileTag->u2Length = sizeof(struct UNI_CMD_BF_PFMU_TAG_RW);
	prETxBfPfmuProfileTag->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileTag->fgBFer = fgBFer;
	prETxBfPfmuProfileTag->u1TxBf = u1BandIdx;

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileTag->u2Tag = cpu2le16(prETxBfPfmuProfileTag->u2Tag);
	prETxBfPfmuProfileTag->u2Length = cpu2le16(prETxBfPfmuProfileTag->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuProfileTagWrite(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *prPfmuTag1,
	UINT8 *prPfmuTag2,
	UINT8  u1tag1_len,
	UINT8  u1tag2_len,
	UINT8  u1PfmuIdx,
	UINT8  u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_TAG_RW *prETxBfPfmuProfileTag;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, Band:%d\n",
			 u1PfmuIdx, u1BandIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_TAG_RW);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_TAG_Write */
	prETxBfPfmuProfileTag = (struct UNI_CMD_BF_PFMU_TAG_RW *) pNextHeadBuf;
	prETxBfPfmuProfileTag->u2Tag = UNI_CMD_BF_PFMU_TAG_WRITE;
	prETxBfPfmuProfileTag->u2Length = sizeof(struct UNI_CMD_BF_PFMU_TAG_RW);
	prETxBfPfmuProfileTag->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileTag->fgBFer = TRUE;
	prETxBfPfmuProfileTag->u1TxBf = u1BandIdx;

	os_move_mem(prETxBfPfmuProfileTag->au4BfPfmuTag1RawData,
				prPfmuTag1,
				u1tag1_len);

	os_move_mem(prETxBfPfmuProfileTag->au4BfPfmuTag2RawData,
				prPfmuTag2,
				u1tag2_len);

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileTag->u2Tag = cpu2le16(prETxBfPfmuProfileTag->u2Tag);
	prETxBfPfmuProfileTag->u2Length = cpu2le16(prETxBfPfmuProfileTag->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuProfileDataRead(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PfmuIdx,
	UINT8 fgBFer,
	UINT16 u2SubCarrIdx,
	UINT8 u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_DATA_R *prETxBfPfmuProfileData;
	POS_COOKIE pObj = NULL;
	struct wifi_dev *wdev = NULL;

	pObj = (POS_COOKIE) pAd->OS_Cookie;
	wdev = get_wdev_by_ioctl_idx_and_iftype(pAd, pObj->ioctl_if, pObj->ioctl_if_type);
	txbf_set_last_wdev(wdev);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_DATA_R);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_DATA_R */
	prETxBfPfmuProfileData = (struct UNI_CMD_BF_PFMU_DATA_R *) pNextHeadBuf;
	prETxBfPfmuProfileData->u2Tag = UNI_CMD_BF_PROFILE_READ;
	prETxBfPfmuProfileData->u2Length = sizeof(struct UNI_CMD_BF_PFMU_DATA_R);

	prETxBfPfmuProfileData->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileData->fgBFer = fgBFer;
	prETxBfPfmuProfileData->u2SubCarIdx = cpu2le16(u2SubCarrIdx);
	prETxBfPfmuProfileData->u1TxBf = u1BandIdx;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, BFer:%x, Subcarrier:%d, Band:%d\n",
			 prETxBfPfmuProfileData->u1PfmuId, prETxBfPfmuProfileData->fgBFer,
			 prETxBfPfmuProfileData->u2SubCarIdx, prETxBfPfmuProfileData->u1TxBf);

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileData->u2Tag = cpu2le16(prETxBfPfmuProfileData->u2Tag);
	prETxBfPfmuProfileData->u2Length = cpu2le16(prETxBfPfmuProfileData->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuProfileDataWrite(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1PfmuIdx,
	UINT16 u2SubCarrIdx,
	UINT8 *pProfileData,
	UINT8 u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_DATA_W *prETxBfPfmuProfileData;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_DATA_W);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_DATA_W */
	prETxBfPfmuProfileData = (struct UNI_CMD_BF_PFMU_DATA_W *) pNextHeadBuf;
	prETxBfPfmuProfileData->u2Tag = UNI_CMD_BF_PROFILE_WRITE;
	prETxBfPfmuProfileData->u2Length = sizeof(struct UNI_CMD_BF_PFMU_DATA_W);
	prETxBfPfmuProfileData->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileData->u2SubCarIdx = cpu2le16(u2SubCarrIdx);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, Subcarrier:%d, Band:%d\n",
			 u1PfmuIdx, u2SubCarrIdx, u1BandIdx);

	os_move_mem(prETxBfPfmuProfileData->au4BfPfmuRawData, pProfileData, 16);

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileData->u2Tag = cpu2le16(prETxBfPfmuProfileData->u2Tag);
	prETxBfPfmuProfileData->u2Length = cpu2le16(prETxBfPfmuProfileData->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPfmuMemAllocMapRead(
	struct _RTMP_ADAPTER *pAd)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT16 *pu2CmdBuf;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(UINT32);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Fill tag and length */
	pu2CmdBuf = (UINT16 *) pNextHeadBuf;

	pu2CmdBuf[0] = cpu2le16(UNI_CMD_BF_PFMU_MEM_ALLOC_MAP_READ);
	pu2CmdBuf[1] = cpu2le16(sizeof(UINT32));

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfAidSetting(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2Aid,
	UINT8 u1BandIdx,
	UINT8 u1OwnMacIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PEER_AID *prPeerAid;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Aid:%u, Band:%u, OwnMac:%u\n", u2Aid, u1BandIdx, u1OwnMacIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_PEER_AID);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PEER_AID */
	prPeerAid = (struct UNI_CMD_PEER_AID *) pNextHeadBuf;
	prPeerAid->u2Tag = UNI_CMD_BF_AID_SET;
	prPeerAid->u2Length = sizeof(struct UNI_CMD_PEER_AID);
	prPeerAid->u2WlanIdx = 0; /* not use*/
	prPeerAid->u2Aid = cpu2le16(u2Aid);
	prPeerAid->u1OwnMacIdx = u1OwnMacIdx;
	prPeerAid->u1BandIdx = u1BandIdx;

#ifdef CFG_BIG_ENDIAN
	prPeerAid->u2Tag = cpu2le16(prPeerAid->u2Tag);
	prPeerAid->u2Length = cpu2le16(prPeerAid->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdITxBfPhaseCal(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1Group,
	UINT8 u1Group_L_M_H,
	UINT8 u1DbdcBandIdx,
	UINT8 u1PhaseCalType,
	UINT8 u1PhaseVerifyLnaGainLevel,
	UINT8 u1BandIdx,
	UINT8 u1PhaseOutRptVersion)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_IBF_PHASE_CAL_CTRL *prIBfPhaseCal;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Enable iBF phase calibration: Group = %d, Group_L_M_H = %d, u1PhaseOutRptVersion = %d\n",
			  u1Group, u1Group_L_M_H, u1PhaseOutRptVersion);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_IBF_PHASE_CAL_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_IBF_PHASE_CAL_CTRL */
	prIBfPhaseCal = (struct UNI_CMD_IBF_PHASE_CAL_CTRL *) pNextHeadBuf;
	prIBfPhaseCal->u2Tag = UNI_CMD_BF_PHASE_CALIBRATION;
	prIBfPhaseCal->u2Length = sizeof(struct UNI_CMD_IBF_PHASE_CAL_CTRL);
	prIBfPhaseCal->u1Group = u1Group;
	prIBfPhaseCal->u1Group_L_M_H = u1Group_L_M_H;
	prIBfPhaseCal->u1DbdcBandIdx = u1DbdcBandIdx;
	prIBfPhaseCal->u1PhaseCalType = u1PhaseCalType;
	prIBfPhaseCal->u1PhaseVerifyLnaGainLevel = u1PhaseVerifyLnaGainLevel;
	prIBfPhaseCal->u1BandIdx = u1BandIdx;
	prIBfPhaseCal->u1PhaseOutRptVersion = u1PhaseOutRptVersion;

#ifdef CFG_BIG_ENDIAN
	prIBfPhaseCal->u2Tag = cpu2le16(prIBfPhaseCal->u2Tag);
	prIBfPhaseCal->u2Length = cpu2le16(prIBfPhaseCal->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdTxBfLnaGain(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1LnaGain,
	UINT8  u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_IBF_LNA_GAIN *prTxBfLnaGain;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
				"u1LnaGain = %d\n", u1LnaGain);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_IBF_LNA_GAIN);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_IBF_LNA_GAIN */
	prTxBfLnaGain = (struct UNI_CMD_IBF_LNA_GAIN *) pNextHeadBuf;
	prTxBfLnaGain->u2Tag = UNI_CMD_BF_LNA_GAIN_CONFIG;
	prTxBfLnaGain->u2Length = sizeof(struct UNI_CMD_IBF_LNA_GAIN);
	prTxBfLnaGain->u1LnaGain = u1LnaGain;
	prTxBfLnaGain->u1BandIdx = u1BandIdx;

#ifdef CFG_BIG_ENDIAN
	prTxBfLnaGain->u2Tag = cpu2le16(prTxBfLnaGain->u2Tag);
	prTxBfLnaGain->u2Length = cpu2le16(prTxBfLnaGain->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdITxBfPhaseComp(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BW,
	BOOLEAN fgJPCh,
	UINT8 u1DbdcBandIdx,
	UINT8 u1Group,
	UINT8 fgRdFromE2p,
	UINT8 fgDisComp)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_IBF_PHASE_COMP *prIBfPhaseComp;
	struct _RTMP_CHIP_OP *ops = hc_get_chip_ops(pAd->hdev_ctrl);
	struct _RTMP_ADAPTER *ad = NULL;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_ERROR,
			"Enable iBF phase compensation : fgRdFromE2p = %d, BW = %d, BandIdx = %d\n",
			  fgRdFromE2p, u1BW, u1DbdcBandIdx);

	ad = physical_device_get_mac_adapter_by_band(pAd->physical_dev, u1DbdcBandIdx);

	if (!ad) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_IBF_PHASE_COMP);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_IBF_PHASE_CAL_CTRL */
	prIBfPhaseComp = (struct UNI_CMD_IBF_PHASE_COMP *) pNextHeadBuf;
	prIBfPhaseComp->u2Tag = UNI_CMD_BF_IBF_PHASE_COMP;
	prIBfPhaseComp->u2Length = sizeof(struct UNI_CMD_IBF_PHASE_COMP);
	prIBfPhaseComp->u1BW = u1BW;
	prIBfPhaseComp->fgJPCh = fgJPCh;
	prIBfPhaseComp->u1DbdcBandIdx = u1DbdcBandIdx;
	prIBfPhaseComp->fgRdFromE2p = fgRdFromE2p;
	prIBfPhaseComp->fgDisComp = fgDisComp;
	prIBfPhaseComp->u1GroupId = u1Group;

	if ((ops->iBFPhaseComp) && (!fgRdFromE2p))
		ops->iBFPhaseComp(ad, u1Group, prIBfPhaseComp->au1Buf);

#ifdef CFG_BIG_ENDIAN
	prIBfPhaseComp->u2Tag = cpu2le16(prIBfPhaseComp->u2Tag);
	prIBfPhaseComp->u2Length = cpu2le16(prIBfPhaseComp->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuProfileDataWrite20MAll(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PfmuIdx,
	UINT8 u1BandIdx,
	UINT8 *pu1ProfileData)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_DATA_ALL_W *prETxBfPfmuProfileData;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, Band:%d\n",
			 u1PfmuIdx, u1BandIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_DATA_ALL_W);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_DATA_ALL_W */
	prETxBfPfmuProfileData = (struct UNI_CMD_BF_PFMU_DATA_ALL_W *) pNextHeadBuf;
	prETxBfPfmuProfileData->u2Tag = UNI_CMD_BF_PROFILE_WRITE_20M_ALL;
	prETxBfPfmuProfileData->u2Length = sizeof(struct UNI_CMD_BF_PFMU_DATA_ALL_W);
	prETxBfPfmuProfileData->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileData->u1TxBf = u1BandIdx;
	os_move_mem(prETxBfPfmuProfileData->au1Buf, pu1ProfileData, 512);

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileData->u2Tag = cpu2le16(prETxBfPfmuProfileData->u2Tag);
	prETxBfPfmuProfileData->u2Length = cpu2le16(prETxBfPfmuProfileData->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}


INT32 UniCmdETxBfPfmuProfileDataWrite20MAll_5x5(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PfmuIdx,
	UINT8 u1BandIdx,
	UINT8 *pu1ProfileData)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PFMU_DATA_ALL_5X5_W *prETxBfPfmuProfileData;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"PFMU ID = %d, Band:%d\n",
			 u1PfmuIdx, u1BandIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PFMU_DATA_ALL_5X5_W);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PFMU_DATA_ALL_W */
	prETxBfPfmuProfileData = (struct UNI_CMD_BF_PFMU_DATA_ALL_5X5_W *) pNextHeadBuf;
	prETxBfPfmuProfileData->u2Tag = UNI_CMD_BF_PROFILE_WRITE_20M_ALL_5X5;
	prETxBfPfmuProfileData->u2Length = sizeof(struct UNI_CMD_BF_PFMU_DATA_ALL_5X5_W);
	prETxBfPfmuProfileData->u1PfmuId = u1PfmuIdx;
	prETxBfPfmuProfileData->u1TxBf = u1BandIdx;
	os_move_mem(prETxBfPfmuProfileData->au1Buf, pu1ProfileData, 640);

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuProfileData->u2Tag = cpu2le16(prETxBfPfmuProfileData->u2Tag);
	prETxBfPfmuProfileData->u2Length = cpu2le16(prETxBfPfmuProfileData->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}


INT32 UniCmdTxBfApClientCluster(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2WlanIdx,
	UINT16 u2CmmWlanId)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_APCLIENT_BF *prBfApClientCluster;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"WlanIdx = %d, PfmuIdx = %d\n",
			 u2WlanIdx, u2CmmWlanId);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_APCLIENT_BF);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_APCLIENT_BF */
	prBfApClientCluster = (struct UNI_CMD_APCLIENT_BF *) pNextHeadBuf;
	prBfApClientCluster->u2Tag = UNI_CMD_BF_APCLIENT_CLUSTER;
	prBfApClientCluster->u2Length = sizeof(struct UNI_CMD_APCLIENT_BF);
	prBfApClientCluster->u2WlanIdx = cpu2le16(u2WlanIdx);
	prBfApClientCluster->u2CmmWlanIdx = cpu2le16(u2CmmWlanId);

#ifdef CFG_BIG_ENDIAN
	prBfApClientCluster->u2Tag = cpu2le16(prBfApClientCluster->u2Tag);
	prBfApClientCluster->u2Length = cpu2le16(prBfApClientCluster->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxBfHwEnableStatusUpdate(
	struct _RTMP_ADAPTER *pAd,
	UINT8 fgEBf,
	UINT8 fgIBf)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_HW_EN_STATUS_UPDATE *prTxBfHwEnStatusUpdate;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"fgEBfHwEnable = %d, fgIBfHwEnable = %d\n", fgEBf, fgIBf);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_HW_EN_STATUS_UPDATE);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_BF_HW_ENABLE_STATUS_UPDATE */
	prTxBfHwEnStatusUpdate = (struct UNI_CMD_BF_HW_EN_STATUS_UPDATE *) pNextHeadBuf;
	prTxBfHwEnStatusUpdate->u2Tag = UNI_CMD_BF_HW_ENABLE_STATUS_UPDATE;
	prTxBfHwEnStatusUpdate->u2Length = sizeof(struct UNI_CMD_BF_HW_EN_STATUS_UPDATE);
	prTxBfHwEnStatusUpdate->u1EBfHwEnStatus = fgEBf;
	prTxBfHwEnStatusUpdate->u1IBfHwEnStatus = fgIBf;

#ifdef CFG_BIG_ENDIAN
	prTxBfHwEnStatusUpdate->u2Tag = cpu2le16(prTxBfHwEnStatusUpdate->u2Tag);
	prTxBfHwEnStatusUpdate->u2Length = cpu2le16(prTxBfHwEnStatusUpdate->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxBfeeHwCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 fgBfeeHwEn)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_BFEE_CTRL *prTxBfeeHwCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_ERROR,
			"fgTxBfeeHwEnable = %d\n", fgBfeeHwEn);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_BFEE_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_BFEE_CTRL */
	prTxBfeeHwCtrl = (struct UNI_CMD_BF_BFEE_CTRL *) pNextHeadBuf;
	prTxBfeeHwCtrl->u2Tag = UNI_CMD_BF_BFEE_HW_CTRL;
	prTxBfeeHwCtrl->u2Length = sizeof(struct UNI_CMD_BF_BFEE_CTRL);
	prTxBfeeHwCtrl->fgSndReqChkEn = fgBfeeHwEn;

#ifdef CFG_BIG_ENDIAN
	prTxBfeeHwCtrl->u2Tag = cpu2le16(prTxBfeeHwCtrl->u2Tag);
	prTxBfeeHwCtrl->u2Length = cpu2le16(prTxBfeeHwCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmd_txbf_config(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1ConfigType,
	UINT8 config_para[])
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT8 i;
	struct UNI_CMD_BF_CONFIG_CTRL *prBfConfigCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_CONFIG_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"config_type=%d\n", u1ConfigType);

	for (i = 0 ; i < 6 ; i++) {
		MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
				"config_para[%d]=%d\n", i, config_para[i]);
	}

	/* Step 3: Filled in parameters of UNI_CMD_BF_CONFIG_CTRL */
	prBfConfigCtrl = (struct UNI_CMD_BF_CONFIG_CTRL *) pNextHeadBuf;
	prBfConfigCtrl->u2Tag = UNI_CMD_BF_CONFIG;
	prBfConfigCtrl->u2Length = sizeof(struct UNI_CMD_BF_CONFIG_CTRL);
	prBfConfigCtrl->u4ConfigType = u1ConfigType;
	os_move_mem(prBfConfigCtrl->u1ConfigPara, config_para, 6);

#ifdef CFG_BIG_ENDIAN
	prBfConfigCtrl->u2Tag = cpu2le16(prBfConfigCtrl->u2Tag);
	prBfConfigCtrl->u2Length = cpu2le16(prBfConfigCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPfmuFullDimDataWrite(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PfmuIdx,
	UINT16 u2SubCarrIdx,
	UINT8 u1Bfer,
	UINT8 *pu1ProfileData,
	UINT8 u1DataLength,
	UINT8 u1BandIdx)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_ETXBf_PFMU_FULL_DIM_DATA_W *prETxBfPfmuData;

	if (!pu1ProfileData) {
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ETXBf_PFMU_FULL_DIM_DATA_W);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ETXBf_PFMU_FULL_DIM_DATA_W */
	prETxBfPfmuData = (struct UNI_CMD_ETXBf_PFMU_FULL_DIM_DATA_W *) pNextHeadBuf;
	prETxBfPfmuData->u2Tag = UNI_CMD_BF_PFMU_DATA_WRITE;
	prETxBfPfmuData->u2Length = sizeof(struct UNI_CMD_ETXBf_PFMU_FULL_DIM_DATA_W);
	prETxBfPfmuData->u1PfmuIdx = u1PfmuIdx;
	prETxBfPfmuData->u2SubCarr = cpu2le16(u2SubCarrIdx);
	prETxBfPfmuData->u1BandIdx = u1BandIdx;
	prETxBfPfmuData->fgBfer = u1Bfer;
	os_move_mem(prETxBfPfmuData->au1Buf, pu1ProfileData, u1DataLength);

#ifdef CFG_BIG_ENDIAN
	RTMPEndianChange(prETxBfPfmuData->au1Buf, u1DataLength);
	prETxBfPfmuData->u2Tag = cpu2le16(prETxBfPfmuData->u2Tag);
	prETxBfPfmuData->u2Length = cpu2le16(prETxBfPfmuData->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdETxBfPlyInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pu1Data)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_PLY_CMD *prTxSndCmd;
	struct UNI_CMD_BF_PLY_CMD *pBuffer = (struct UNI_CMD_BF_PLY_CMD *)pu1Data;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_PLY_CMD);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_PLY_CMD */
	prTxSndCmd = (struct UNI_CMD_BF_PLY_CMD *) pNextHeadBuf;
	memcpy(prTxSndCmd, pBuffer, sizeof(struct UNI_CMD_BF_PLY_CMD));

	prTxSndCmd->u2Tag = UNI_CMD_BF_CMD_PLY_INFO;
	prTxSndCmd->u2Length = sizeof(struct UNI_CMD_BF_PLY_CMD);

#ifdef CFG_BIG_ENDIAN
	prTxSndCmd->u2Tag = cpu2le16(prTxSndCmd->u2Tag);
	prTxSndCmd->u2Length = cpu2le16(prTxSndCmd->u2Length);
	prTxSndCmd->u2WlanIdx = cpu2le16(prTxSndCmd->u2WlanIdx);
#endif /* CFG_BIG_ENDIAN */

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Action=0x%02X, GloOpt=0x%02X, GrpIBfOpt=0x%02X, GrpEBfOpt=0x%02X,\n",
			prTxSndCmd->u1Action,
			prTxSndCmd->u1GloOpt,
			prTxSndCmd->u1GrpIBfOpt,
			prTxSndCmd->u1GrpEBfOpt);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"WlanIdx=0x%04X, Nss=0x%02X, SSPly=0x%02X\n",
			prTxSndCmd->u2WlanIdx,
			prTxSndCmd->u1Nss,
			prTxSndCmd->u1SSPly);

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);

	if (prTxSndCmd->u1Action == BF_TXCMD_READ_INFO) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdHeRaMuMetricInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pu1Data)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_HERA_MU_METRIC *prMuMetCmd;
	struct UNI_CMD_HERA_MU_METRIC *pBuffer = (struct UNI_CMD_HERA_MU_METRIC *)pu1Data;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_HERA_MU_METRIC);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_HERA_MU_METRIC */
	prMuMetCmd = (struct UNI_CMD_HERA_MU_METRIC *) pNextHeadBuf;
	memcpy(prMuMetCmd, pBuffer, sizeof(struct UNI_CMD_HERA_MU_METRIC));

	prMuMetCmd->u2Tag = UNI_CMD_BF_CMD_MU_METRIC;
	prMuMetCmd->u2Length = sizeof(struct UNI_CMD_HERA_MU_METRIC);

#ifdef CFG_BIG_ENDIAN
	prMuMetCmd->u2Tag = cpu2le16(prMuMetCmd->u2Tag);
	prMuMetCmd->u2Length = cpu2le16(prMuMetCmd->u2Length);
#endif /* CFG_BIG_ENDIAN */

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"u1ReadClr=0x%02X, u1Band=0x%02X, u1NUser=0x%02X, u1DBW=0x%02X,\n",
			prMuMetCmd->u1ReadClr,
			prMuMetCmd->u1Band,
			prMuMetCmd->u1NUser,
			prMuMetCmd->u1DBW);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"u1NTxer=0x%02X, u1PFD=0x%02X, u1RuSize=0x%02X, u1RuIdx=0x%02X\n",
			prMuMetCmd->u1NTxer,
			prMuMetCmd->u1PFD,
			prMuMetCmd->u1RuSize,
			prMuMetCmd->u1RuIdx);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"u1SpeIdx=0x%02X, u1SpeedUp=0x%02X, u1LDPC=0x%02X, u1PollingTime=0x%02X\n",
			prMuMetCmd->u1SpeIdx,
			prMuMetCmd->u1SpeedUp,
			prMuMetCmd->u1LDPC,
			prMuMetCmd->u1PollingTime);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"u1NStsUser0=0x%02X, u1NStsUser1=0x%02X, u1NStsUser2=0x%02X, u1NStsUser3=0x%02X,\n",
			prMuMetCmd->u1NStsUser[0],
			prMuMetCmd->u1NStsUser[1],
			prMuMetCmd->u1NStsUser[2],
			prMuMetCmd->u1NStsUser[3]);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"u2PfidUser0=0x%04X, u2PfidUser1=0x%04X, u2PfidUser2=0x%04X, u2PfidUser3=0x%04X,\n",
			prMuMetCmd->u2PfidUser[0],
			prMuMetCmd->u2PfidUser[1],
			prMuMetCmd->u2PfidUser[2],
			prMuMetCmd->u2PfidUser[3]);

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfTxCmd(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pu1Data)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_TXCMD *prTxBfTxCmd;
	struct UNI_CMD_BF_TXCMD *pBuffer = (struct UNI_CMD_BF_TXCMD *)pu1Data;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_TXCMD);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_TXCMD */
	prTxBfTxCmd = (struct UNI_CMD_BF_TXCMD *) pNextHeadBuf;
	memcpy(prTxBfTxCmd, pBuffer, sizeof(struct UNI_CMD_BF_TXCMD));

	prTxBfTxCmd->u2Tag = UNI_CMD_BF_CMD_TXCMD;
	prTxBfTxCmd->u2Length = sizeof(struct UNI_CMD_BF_TXCMD);

#ifdef CFG_BIG_ENDIAN
	prTxBfTxCmd->u2Tag = cpu2le16(prTxBfTxCmd->u2Tag);
	prTxBfTxCmd->u2Length = cpu2le16(prTxBfTxCmd->u2Length);
#endif /* CFG_BIG_ENDIAN */

	MTWF_PRINT("%s: ucAction=0x%02X, fgTxCmdBfManual=0x%02X, ucTxCmdBfBit=0x%02X\n",
			__func__,
			prTxBfTxCmd->u1Action,
			prTxBfTxCmd->fgTxCmdBfManual,
			prTxBfTxCmd->u1TxCmdBfBit);

	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);

	if (prTxBfTxCmd->u1Action == BF_TXCMD_READ_INFO) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfCfgBfPhy(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1Action,
	UINT8 u1BandIdx,
	UINT8 u1SmthIntlBypass)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_CFG_BF_PHY *prTxBfCfgBfPhy;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_CFG_BF_PHY);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_CFG_BF_PHY */
	prTxBfCfgBfPhy = (struct UNI_CMD_BF_CFG_BF_PHY *) pNextHeadBuf;
	prTxBfCfgBfPhy->u2Tag = UNI_CMD_BF_CMD_CFG_PHY;
	prTxBfCfgBfPhy->u2Length = sizeof(struct UNI_CMD_BF_CFG_BF_PHY);
	prTxBfCfgBfPhy->u1Action = u1Action;
	prTxBfCfgBfPhy->u1BandIdx = u1BandIdx;
	prTxBfCfgBfPhy->u1SmthIntlBypass = u1SmthIntlBypass;

#ifdef CFG_BIG_ENDIAN
	prTxBfCfgBfPhy->u2Tag = cpu2le16(prTxBfCfgBfPhy->u2Tag);
	prTxBfCfgBfPhy->u2Length = cpu2le16(prTxBfCfgBfPhy->u2Length);
#endif /* CFG_BIG_ENDIAN */

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"ucAction=0x%02X, ucBandIdx=0x%02X, ucSmthIntlBypass=0x%02X\n",
			prTxBfCfgBfPhy->u1Action,
			prTxBfCfgBfPhy->u1BandIdx,
			prTxBfCfgBfPhy->u1SmthIntlBypass);

	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfSndCnt(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pu1Data)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_SND_CNT_CMD *prSndCntCmd;
	struct UNI_CMD_BF_SND_CNT_CMD *pBuffer = (struct UNI_CMD_BF_SND_CNT_CMD *)pu1Data;
	POS_COOKIE pObj = NULL;
	struct wifi_dev *wdev = NULL;

	pObj = (POS_COOKIE) pAd->OS_Cookie;
	wdev = get_wdev_by_ioctl_idx_and_iftype(pAd, pObj->ioctl_if, pObj->ioctl_if_type);
	txbf_set_last_wdev(wdev);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_SND_CNT_CMD);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_BF_SND_CNT_CMD */
	prSndCntCmd = (struct UNI_CMD_BF_SND_CNT_CMD *) pNextHeadBuf;
	memcpy(prSndCntCmd, pBuffer, sizeof(struct UNI_CMD_BF_SND_CNT_CMD));

	prSndCntCmd->u2Tag = UNI_CMD_BF_CMD_SND_CNT;
	prSndCntCmd->u2Length = sizeof(struct UNI_CMD_BF_SND_CNT_CMD);

#ifdef CFG_BIG_ENDIAN
	prSndCntCmd->u2Tag = cpu2le16(prSndCntCmd->u2Tag);
	prSndCntCmd->u2Length = cpu2le16(prSndCntCmd->u2Length);
	prSndCntCmd->u2Action = cpu2le16(prSndCntCmd->u2Action);
	prSndCntCmd->u2SndCntLmtMan = cpu2le16(prSndCntCmd->u2SndCntLmtMan);
#endif /* CFG_BIG_ENDIAN */

	MTWF_PRINT("%s: u1Action=%u, u2SndCntLmtMan=%u\n",
			__func__,
			prSndCntCmd->u2Action,
			prSndCntCmd->u2SndCntLmtMan);

	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxBfModuleEnCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BfNum,
	UINT8 u1BfBitmap,
	UINT8 u1BfSelBand[])
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_MOD_ENABLE_CTRL *prTxBfModEnCtrl;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
		"u1BfNum = %d, u1BfBitmap = %d, u1BfSelBand[0] = %d, u1BfSelBand[1] = %d\n",
		u1BfNum, u1BfBitmap, u1BfSelBand[0], u1BfSelBand[1]);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_MOD_ENABLE_CTRL);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_BF_MOD_EN_CTRL */
	prTxBfModEnCtrl = (struct UNI_CMD_BF_MOD_ENABLE_CTRL *) pNextHeadBuf;

	prTxBfModEnCtrl->u2Tag = UNI_CMD_BF_MOD_EN_CTRL;
	prTxBfModEnCtrl->u2Length = sizeof(struct UNI_CMD_BF_MOD_ENABLE_CTRL);
	prTxBfModEnCtrl->u1BfNum = u1BfNum;
	prTxBfModEnCtrl->u1BfBitmap = u1BfBitmap;
	os_move_mem(&(prTxBfModEnCtrl->au1BFSel[0]), u1BfSelBand, 8);

#ifdef CFG_BIG_ENDIAN
	prTxBfModEnCtrl->u2Tag = cpu2le16(prTxBfModEnCtrl->u2Tag);
	prTxBfModEnCtrl->u2Length = cpu2le16(prTxBfModEnCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfTxSndInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pucData)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_SND_CMD *prTxSndCmd;
	struct UNI_CMD_BF_SND_CMD *pBuffer = (struct UNI_CMD_BF_SND_CMD *)pucData;
	POS_COOKIE pObj = NULL;
	struct wifi_dev *wdev = NULL;

	pObj = (POS_COOKIE) pAd->OS_Cookie;
	wdev = get_wdev_by_ioctl_idx_and_iftype(pAd, pObj->ioctl_if, pObj->ioctl_if_type);
	txbf_set_last_wdev(wdev);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_SND_CMD);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_BF_SND_INFO */
	prTxSndCmd = (struct UNI_CMD_BF_SND_CMD *) pNextHeadBuf;
	memcpy(prTxSndCmd, pBuffer, sizeof(struct UNI_CMD_BF_SND_CMD));

	prTxSndCmd->u2Tag = UNI_CMD_BF_CMD_TXSND_INFO;
	prTxSndCmd->u2Length = sizeof(struct UNI_CMD_BF_SND_CMD);

#ifdef CFG_BIG_ENDIAN
	prTxSndCmd->u2Tag = cpu2le16(prTxSndCmd->u2Tag);
	prTxSndCmd->u2Length = cpu2le16(prTxSndCmd->u2Length);
	prTxSndCmd->u2WlanIdx = cpu2le16(prTxSndCmd->u2WlanIdx);
#endif /* CFG_BIG_ENDIAN */

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Action=0x%02X, ReadClr=0x%02X, VhtOpt=0x%02X, HeOpt=0x%02X,\n",
			prTxSndCmd->u1Action,
			prTxSndCmd->u1ReadClr,
			prTxSndCmd->u1VhtOpt,
			prTxSndCmd->u1HeOpt);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"GloOpt=0x%02X, WlanIdx=0x%04X, SndIntv=0x%02X, SndStop:0x%02X\n",
			prTxSndCmd->u1GloOpt,
			prTxSndCmd->u2WlanIdx,
			prTxSndCmd->u1SndIntv,
			prTxSndCmd->u1SndStop);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"MaxSndStas=0x%02X, TxTime=0x%02X, Mcs=0x%02X, LDPC:0x%02X\n",
			prTxSndCmd->u1MaxSndStas,
			prTxSndCmd->u1TxTime,
			prTxSndCmd->u1Mcs,
			prTxSndCmd->u1LDPC);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Inf=0x%02X\n", prTxSndCmd->u1Inf);

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfFbRptDbgInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pucData)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_TXBF_FBRPT_DBG_INFO *prETxBfFbRptData;
	struct UNI_CMD_TXBF_FBRPT_DBG_INFO *pBuffer = (struct UNI_CMD_TXBF_FBRPT_DBG_INFO *)pucData;

#ifdef CONFIG_ATE
#ifdef CONFIG_WLAN_SERVICE
	struct service_test *serv_test = (struct service_test *)(pAd->serv.serv_handle);
#else
	struct _ATE_CTRL *ATECtrl = &pAd->ATECtrl;
#endif /*  CONFIG_WLAN_SERVICE */
#endif/* CONFIG_ATE */

	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
	INT32 if_idx = pObj->ioctl_if;
	struct wifi_dev *pwdev = get_wdev_by_ioctl_idx_and_iftype(pAd, if_idx, pObj->ioctl_if_type);
	UINT8 BandIdx = HcGetBandByWdev(pwdev);

	txbf_set_last_wdev(pwdev);
	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXBF_FBRPT_DBG_INFO);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_TXBF_FBRPT_DBG_INFO */
	prETxBfFbRptData = (struct UNI_CMD_TXBF_FBRPT_DBG_INFO *) pNextHeadBuf;
	memcpy(prETxBfFbRptData, pBuffer, sizeof(struct UNI_CMD_TXBF_FBRPT_DBG_INFO));

#ifdef CONFIG_ATE
	if (ATE_ON(pAd))
#ifdef CONFIG_WLAN_SERVICE
	{
		BandIdx = serv_test->ctrl_band_idx;
	}
#else
	{
		BandIdx = ATECtrl->control_band_idx;
	}
#endif /*  CONFIG_WLAN_SERVICE */
#endif/* CONFIG_ATE */

	prETxBfFbRptData->u2Tag = UNI_CMD_BF_FBRPT_DBG_INFO_READ;
	prETxBfFbRptData->u2Length = sizeof(struct UNI_CMD_TXBF_FBRPT_DBG_INFO);
	prETxBfFbRptData->u1BandIdx = BandIdx;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"Action:%u, BandIdx:%u, PollPFMUIntrStatTimeOut:%u, FbRptDeQInterval:%u, WlanIdx:%u, PFMUUpdateEn:%u\n"
			, prETxBfFbRptData->u1Action, prETxBfFbRptData->u1BandIdx
			, prETxBfFbRptData->u1PollPFMUIntrStatTimeOut
			, prETxBfFbRptData->u1FbRptDeQInterval
			, prETxBfFbRptData->u2WlanIdx
			, prETxBfFbRptData->u1PFMUUpdateEn);

#ifdef CFG_BIG_ENDIAN
	prETxBfFbRptData->u2Tag = cpu2le16(prETxBfFbRptData->u2Tag);
	prETxBfFbRptData->u2Length = cpu2le16(prETxBfFbRptData->u2Length);
	prETxBfFbRptData->u2WlanIdx = cpu2le16(prETxBfFbRptData->u2WlanIdx);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfPseudoTagWrite(
	struct _RTMP_ADAPTER *pAd,
	IN UINT8 lm,
	IN UINT8 nr,
	IN UINT8 nc,
	IN UINT8 bw,
	IN UINT8 codebook,
	IN UINT8 group)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_ETXBF_PFMU_SW_TAG *prETxBfPfmuSwTag;
	UCHAR band = BAND0;
	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
	struct wifi_dev *wdev = get_wdev_by_ioctl_idx_and_iftype(pAd, pObj->ioctl_if, pObj->ioctl_if_type);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO, "\n");

	if (!wdev)
		MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_ERROR, "wdev NULL\n");
	else
		band = HcGetBandByWdev(wdev);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_ETXBF_PFMU_SW_TAG);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_ETXBF_PFMU_SW_TAG */
	prETxBfPfmuSwTag = (struct UNI_CMD_ETXBF_PFMU_SW_TAG *) pNextHeadBuf;
	prETxBfPfmuSwTag->u2Tag = UNI_CMD_BF_PFMU_SW_TAG_WRITE;
	prETxBfPfmuSwTag->u2Length = sizeof(struct UNI_CMD_ETXBF_PFMU_SW_TAG);
	prETxBfPfmuSwTag->u1Lm = lm;
	prETxBfPfmuSwTag->u1Nr = nr;
	prETxBfPfmuSwTag->u1Nc = nc;
	prETxBfPfmuSwTag->u1Bw = bw;
	prETxBfPfmuSwTag->u1Codebook = codebook;
	prETxBfPfmuSwTag->u1group = group;
	prETxBfPfmuSwTag->u1TxBf = band;

#ifdef CFG_BIG_ENDIAN
	prETxBfPfmuSwTag->u2Tag = cpu2le16(prETxBfPfmuSwTag->u2Tag);
	prETxBfPfmuSwTag->u2Length = cpu2le16(prETxBfPfmuSwTag->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdETxBfStaRecRead(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2WlanId)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_BF_STAREC_READ *prTxBfStarecRead;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"WLAN ID = %d\n", u2WlanId);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_BF);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_BF_STAREC_READ);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of CMD_BF_MOD_EN_CTRL */
	prTxBfStarecRead = (struct UNI_CMD_BF_STAREC_READ *) pNextHeadBuf;
	prTxBfStarecRead->u2Tag = UNI_CMD_BF_STA_REC_READ;
	prTxBfStarecRead->u2Length = sizeof(struct UNI_CMD_BF_STAREC_READ);
	prTxBfStarecRead->u2WlanIdx = u2WlanId;

#ifdef CFG_BIG_ENDIAN
	prTxBfStarecRead->u2Tag = cpu2le16(prTxBfStarecRead->u2Tag);
	prTxBfStarecRead->u2Length = cpu2le16(prTxBfStarecRead->u2Length);
	prTxBfStarecRead->u2WlanIdx = cpu2le16(prTxBfStarecRead->u2WlanIdx);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_BF);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

#endif /* TXBF_SUPPORT */

#ifdef WIFI_EAP_FEATURE
INT32 UniCmdEapInitIPICtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_EAP_INIT_IPI_CTRL_T *prInitIPICtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EAP_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EAP_INIT_IPI_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_EAP_INIT_IPI_CTRL */
	prInitIPICtrl = (struct UNI_CMD_EAP_INIT_IPI_CTRL_T *) pNextHeadBuf;
	prInitIPICtrl->u2Tag = cpu2le16(UNI_CMD_EAP_INIT_IPI_CTRL);
	prInitIPICtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_EAP_INIT_IPI_CTRL_T));
	prInitIPICtrl->u4EapCtrlCmdId = cpu2le32(INIT_IPI_CTRL);
	prInitIPICtrl->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EAP_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EAP, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEapGetIPIValue(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_EAP_INIT_IPI_CTRL_T *prGetIPIVal;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EAP_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EAP_INIT_IPI_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_EAP_GET_IPI_VALUE */
	prGetIPIVal = (struct UNI_CMD_EAP_INIT_IPI_CTRL_T *) pNextHeadBuf;
	prGetIPIVal->u2Tag = cpu2le16(UNI_CMD_EAP_GET_IPI_VALUE);
	prGetIPIVal->u2Length = cpu2le16(sizeof(struct UNI_CMD_EAP_INIT_IPI_CTRL_T));
	prGetIPIVal->u4EapCtrlCmdId = cpu2le32(GET_IPI_VALUE);
	prGetIPIVal->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EAP_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEapHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EAP, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEapSetDataTxPwrOffset(
	struct _RTMP_ADAPTER *pAd,
	UINT16 u2WlanIdx,
	INT8  i1TxPowerOffset,
	UINT8 u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET_T *prSetDataTxPwrOffset;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EAP_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET */
	prSetDataTxPwrOffset = (struct UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET_T *) pNextHeadBuf;
	prSetDataTxPwrOffset->u2Tag = cpu2le16(UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET);
	prSetDataTxPwrOffset->u2Length = cpu2le16(sizeof(struct UNI_CMD_EAP_SET_DATA_TXPWR_OFFSET_T));
	prSetDataTxPwrOffset->u4EapCtrlCmdId = cpu2le32(SET_DATA_TXPWR_OFFSET);
	prSetDataTxPwrOffset->u1WlanIdx = (UINT8) u2WlanIdx;
	prSetDataTxPwrOffset->i1TxPwrOffset = i1TxPowerOffset;
	prSetDataTxPwrOffset->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EAP_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EAP, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEapSetRaTable(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BandIdx,
	UINT8 u1TblType,
	UINT8 u1TblIndex,
	UINT16 u2TblLength,
	UINT8 *Buffer,
	UINT16 u2Len
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT16 u2Length = 0;
	struct UNI_CMD_EAP_SET_RA_TABLE_T *prSetRaTblParams;

	u2Length = sizeof(struct UNI_CMD_EAP_SET_RA_TABLE_T) + u2Len;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EAP_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + u2Length;

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_EAP_SET_RA_TABLE_DATA */
	prSetRaTblParams = (struct UNI_CMD_EAP_SET_RA_TABLE_T *) pNextHeadBuf;
	prSetRaTblParams->u2Tag = cpu2le16(UNI_CMD_EAP_SET_RA_TABLE_DATA);
	prSetRaTblParams->u2Length = cpu2le16(sizeof(struct UNI_CMD_EAP_SET_RA_TABLE_T));
	prSetRaTblParams->u4EapCtrlCmdId = cpu2le32(SET_RA_TABLE_DATA);
	prSetRaTblParams->u1BandIdx = u1BandIdx;
	prSetRaTblParams->u1RaTblTypeIdx = u1TblType;
	prSetRaTblParams->u1RaTblIdx = u1TblIndex;
	prSetRaTblParams->u2RaTblLength = u2TblLength;
	os_move_mem(prSetRaTblParams->ucBuf, Buffer, u2TblLength);

#ifdef CFG_BIG_ENDIAN
	RTMPEndianChange(prSetRaTblParams->ucBuf, prSetRaTblParams->u2RaTblLength);
#endif

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EAP_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EAP, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdEapGetRaTblInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8 BandIdx,
	UINT8 TblType,
	UINT8 TblIndex,
	UINT8 ReadnWrite
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_EAP_SHOW_RATE_TABLE_T *prGetRaTbl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EAP_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EAP_SHOW_RATE_TABLE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_EAP_GET_RATE_INFO */
	prGetRaTbl = (struct UNI_CMD_EAP_SHOW_RATE_TABLE_T *) pNextHeadBuf;
	prGetRaTbl->u2Tag = cpu2le16(UNI_CMD_EAP_GET_RATE_INFO);
	prGetRaTbl->u2Length = cpu2le16(sizeof(struct UNI_CMD_EAP_SHOW_RATE_TABLE_T));
	prGetRaTbl->u4EapCtrlCmdId = cpu2le32(GET_RATE_INFO);
	prGetRaTbl->u1RaTblTypeIdx = TblType;
	prGetRaTbl->u1RaTblIdx = TblIndex;
	prGetRaTbl->u1BandIdx = BandIdx;
	prGetRaTbl->u1RW = ReadnWrite;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EAP_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventEapHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_EAP, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}
#endif

INT32 UniCmdTxPowerSKUCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  tx_pwr_sku_en,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_SKU_CTRL_T prPowerSKUCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
		"BandIdx %d, tx_pwr_sku_en: %d\n", u1BandIdx, tx_pwr_sku_en);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_SKU_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_SKU_POWER_LIMIT_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_SKU_POWER_LIMIT_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_SKU_CTRL_T));
	prPowerSKUCtrl = (P_CMD_POWER_SKU_CTRL_T) prtlvbuffer->aucBuffer;

	prPowerSKUCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_SKU_POWER_LIMIT_CTRL;
	prPowerSKUCtrl->ucSKUEnable = tx_pwr_sku_en;
	prPowerSKUCtrl->ucBandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxPowerPercentCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  fgTxPowerPercentEn,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_PERCENTAGE_CTRL_T prPowerPercentCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
		"BandIdx %d, fgTxPowerPercentEn: %d\n", u1BandIdx, fgTxPowerPercentEn);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_PERCENTAGE_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_PERCENTAGE_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_PERCENTAGE_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_PERCENTAGE_CTRL_T));
	prPowerPercentCtrl = (P_CMD_POWER_PERCENTAGE_CTRL_T) prtlvbuffer->aucBuffer;

	prPowerPercentCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_PERCENTAGE_CTRL;
	prPowerPercentCtrl->ucPercentageEnable = fgTxPowerPercentEn;
	prPowerPercentCtrl->ucBandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxPowerDropCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  cPowerDropLevel,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_PERCENTAGE_DROP_CTRL_T prPowerDropCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
		"BandIdx %d, cPowerDropLevel: %d\n", u1BandIdx, cPowerDropLevel);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_PERCENTAGE_DROP_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_PERCENTAGE_DROP_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_PERCENTAGE_DROP_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_PERCENTAGE_DROP_CTRL_T));
	prPowerDropCtrl = (P_CMD_POWER_PERCENTAGE_DROP_CTRL_T) prtlvbuffer->aucBuffer;

	prPowerDropCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_PERCENTAGE_DROP_CTRL;
	prPowerDropCtrl->cPowerDropLevel = cPowerDropLevel;
	prPowerDropCtrl->ucBandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxBfBackoffCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  fgTxBFBackoffEn,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_BF_BACKOFF_CTRL_T prTxBFBackoffCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_ERROR,
		"BandIdx %d, fgTxBFBackoffEn: %d\n", u1BandIdx, fgTxBFBackoffEn);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_BF_BACKOFF_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_BACKOFF_POWER_LIMIT_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_BACKOFF_POWER_LIMIT_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_BF_BACKOFF_CTRL_T));
	prTxBFBackoffCtrl = (P_CMD_POWER_BF_BACKOFF_CTRL_T) prtlvbuffer->aucBuffer;

	prTxBFBackoffCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_BACKOFF_POWER_LIMIT_CTRL;
	prTxBFBackoffCtrl->ucBFBackoffEnable = fgTxBFBackoffEn;
	prTxBFBackoffCtrl->ucBandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_BF, CATBF_CFG, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPwrLimitTblUpdate(
	struct _RTMP_ADAPTER *pAd,
	P_CMD_POWER_LIMIT_TABLE_CTRL_T prBuffer
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_LIMIT_TABLE_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_POWER_LIMIT_TABLE_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_POWER_LIMIT_TABLE_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_LIMIT_TABLE_CTRL_T));
	os_move_mem(prtlvbuffer->aucBuffer, prBuffer, sizeof(CMD_POWER_LIMIT_TABLE_CTRL_T));

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdATEModeCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1ATEMode
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_ATE_MODE_CTRL_T prATEModeCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
		"ATEMode %d\n", u1ATEMode);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_ATE_MODE_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_ATEMODE_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_ATEMODE_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_ATE_MODE_CTRL_T));
	prATEModeCtrl = (P_CMD_ATE_MODE_CTRL_T) prtlvbuffer->aucBuffer;

	prATEModeCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_ATEMODE_CTRL;
	prATEModeCtrl->fgATEModeEn = u1ATEMode;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxPwrShowInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8  ucTxPowerInfoCatg,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_TX_POWER_SHOW_INFO_T prTxPowerShowInfoCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
		"u1BandIdx %d, ucTxPowerInfoCatg = %u\n", u1BandIdx, ucTxPowerInfoCatg);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_TX_POWER_SHOW_INFO_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_TX_POWER_SHOW_INFO*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_TX_POWER_SHOW_INFO);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_TX_POWER_SHOW_INFO_T));
	prTxPowerShowInfoCtrl = (P_CMD_TX_POWER_SHOW_INFO_T) prtlvbuffer->aucBuffer;

	prTxPowerShowInfoCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_TX_POWER_SHOW_INFO;
	prTxPowerShowInfoCtrl->ucTxPowerInfoCatg = ucTxPowerInfoCatg;
	prTxPowerShowInfoCtrl->ucBandIdx = u1BandIdx;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTxPowerHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

#ifdef TPC_SUPPORT
INT32 UniCmdTpcFeatureCtrl(
	struct _RTMP_ADAPTER *pAd,
	INT8   TpcPowerValue,
	UINT8  u1BandIdx,
	UINT8  CentralChannel
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32  u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_TPC_CTRL_T prTpcMaxPwrCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	if (CentralChannel == 0) {
		MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
			"(X) invalid Channel setting\n");
		Ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_TPC_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_TPC_FEATURE_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_TPC_FEATURE_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_TPC_CTRL_T));
	prTpcMaxPwrCtrl = (P_CMD_POWER_TPC_CTRL_T) prtlvbuffer->aucBuffer;

	prTpcMaxPwrCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_TPC_FEATURE_CTRL;
	prTpcMaxPwrCtrl->cTPCPowerValue = TpcPowerValue;
	prTpcMaxPwrCtrl->ucBand = u1BandIdx;
	prTpcMaxPwrCtrl->ucCentralChannel = CentralChannel;
	prTpcMaxPwrCtrl->ucChannelBand = TxPowerGetChBand(u1BandIdx, CentralChannel);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"pwr=%d=0x%02X, BandIdx=%d, CentralChannel=%d, ChBand=%d\n",
			  TpcPowerValue, TpcPowerValue, prTpcMaxPwrCtrl->ucBand,
			  prTpcMaxPwrCtrl->ucCentralChannel, prTpcMaxPwrCtrl->ucChannelBand);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}
#endif

INT32 UniCmdHwcfgGet(
	struct _RTMP_ADAPTER *pAd,
	UINT16 dump_offset,
	UINT16 dump_size,
	UINT8 *epprom_content
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_HWCFG_READ_T *prHwcfgRead;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_HWCFG_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_HWCFG_READ_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_GET_SPECTRUM_STATUS*/
	prHwcfgRead = (struct UNI_CMD_HWCFG_READ_T *) pNextHeadBuf;
	prHwcfgRead->u2Tag = cpu2le16(UNI_CMD_HWCFG_READ);
	prHwcfgRead->u2Length = cpu2le16(sizeof(struct UNI_CMD_HWCFG_READ_T));
	prHwcfgRead->u2Offset = cpu2le16(dump_offset);
	prHwcfgRead->u2Count = cpu2le16(dump_size);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_HWCFG_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, epprom_content);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventHwcfgRDRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetTestTrParam(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *tr_param, VOID *pHandle, uint64_t u8TestTrParamFeature)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *pTrParam = (struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *)pHandle;

	/* Fill TLV format */
	pTrParam->u2Tag = UNI_CMD_TEST_TR_PARAM_CTRL;
	pTrParam->u2Length = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T);
	pTrParam->ucDbdcIdx = tr_param->ucDbdcIdx;
	pTrParam->ucAteTestModeEn = tr_param->ucAteTestModeEn;
	pTrParam->ucAction = ENUM_TR_PARAM_SET;
	pTrParam->Data = tr_param->Data;

	switch (u8TestTrParamFeature) {
	case UNI_ATE_TRX_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_TRX;
		break;

	case UNI_ATE_RX_FILTER_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RX_FILTER;
		break;

	case UNI_ATE_RX_FILTER_PKT_LEN_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RX_FILTER_PKT_LEN;
		break;

	case UNI_ATE_SLOT_TIME_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_SLOT_TIME;
		break;

	case UNI_ATE_CLEAN_PERSTA_TXQUEUE_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_CLEAN_PERSTA_TXQUEUE;
		break;

	case UNI_ATE_AMPDU_WTBL_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_AMPDU_WTBL;
		break;

	case UNI_ATE_MU_RX_AID_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_MU_RX_AID;
		break;

	case UNI_ATE_PHY_MANUAL_TX_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_PHY_MANUAL_TX;
		break;

	case UNI_ATE_RX_PATH_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RX_PATH;
		break;

	case UNI_ATE_TX_STREAM_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_TX_STREAM;
		break;

	case UNI_ATE_TSSI_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_TSSI_STATUS;
		break;

	case UNI_ATE_DPD_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_DPD_STATUS;
		break;

	case UNI_ATE_RATE_POWER_OFFSET_ON_OFF_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RATE_POWER_OFFSET_ON_OFF;
		break;

	case UNI_ATE_THERMO_COMP_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_THERMO_COMP_STATUS;
		break;

	case UNI_ATE_FREQ_OFFSET_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_FREQ_OFFSET;
		break;

	case UNI_ATE_FAGC_RSSI_PATH_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_FAGC_RSSI_PATH;
		break;

	case UNI_ATE_PHY_STATUS_COUNT_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_PHY_STATUS_COUNT;
		break;

	case UNI_ATE_RXV_INDEX_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RXV_INDEX;
		break;

	case UNI_ATE_ANTENNA_PORT_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_ANTENNA_PORT;
		break;

	case UNI_ATE_THERMAL_ONOFF_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_THERMAL_ONOFF;
		break;

	case UNI_ATE_TX_POWER_CONTROL_ALL_RF_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_TX_POWER_CONTROL_ALL_RF;
		break;

	case UNI_ATE_RATE_POWER_OFFSET_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RATE_POWER_OFFSET;
		break;

	case UNI_ATE_SLT_CMD_TEST_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_SLT_CMD_TEST;
		break;

	case UNI_ATE_SKU_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_SKU;
		break;

	case UNI_ATE_POWER_PERCENTAGE_ON_OFF_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_POWER_PERCENTAGE_ON_OFF;
		break;

	case UNI_ATE_BF_BACKOFF_ON_OFF_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_BF_BACKOFF_ON_OFF;
		break;

	case UNI_ATE_POWER_PERCENTAGE_LEVEL_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_POWER_PERCENTAGE_LEVEL;
		break;

	case UNI_ATE_FRTBL_CFG_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_FRTBL_CFG;
		break;

	case UNI_ATE_PREAMBLE_PUNC_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_PREAMBLE_PUNC_ON_OFF;
		break;

	default:
		Ret = NDIS_STATUS_INVALID_DATA;
		break;
	}
	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdATESetTestTab[UNI_ATE_MAX_NUM] = {
/*MAC*/
	{
		.u8CmdFeature = UNI_ATE_TRX_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RX_FILTER_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RX_FILTER_PKT_LEN_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_SLOT_TIME_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_CLEAN_PERSTA_TXQUEUE_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_AMPDU_WTBL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_MU_RX_AID_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_PHY_MANUAL_TX_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
/*PHY*/
	{
		.u8CmdFeature = UNI_ATE_RX_PATH_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_TX_STREAM_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_TSSI_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_DPD_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RATE_POWER_OFFSET_ON_OFF_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},

	{
		.u8CmdFeature = UNI_ATE_THERMO_COMP_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_FREQ_OFFSET_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_FAGC_RSSI_PATH_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_PHY_STATUS_COUNT_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RXV_INDEX_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_ANTENNA_PORT_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_THERMAL_ONOFF_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_TX_POWER_CONTROL_ALL_RF_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RATE_POWER_OFFSET_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_SLT_CMD_TEST_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_SKU_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_POWER_PERCENTAGE_ON_OFF_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_BF_BACKOFF_ON_OFF_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_POWER_PERCENTAGE_LEVEL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
/* Fr table*/
	{
		.u8CmdFeature = UNI_ATE_FRTBL_CFG_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_PREAMBLE_PUNC_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdSetTestTrParam
	},
};

INT32 UniCmdGetTestTrParam(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *tr_param, VOID *pHandle, uint64_t u8TestTrParamFeature)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *pTrParam = (struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *)pHandle;

	/* Fill TLV format */
	pTrParam->u2Tag = UNI_CMD_TEST_TR_PARAM_CTRL;
	pTrParam->u2Length = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T);
	pTrParam->ucDbdcIdx = tr_param->ucDbdcIdx;
	pTrParam->ucAteTestModeEn = tr_param->ucAteTestModeEn;
	pTrParam->ucAction = ENUM_TR_PARAM_GET;
	pTrParam->Data = tr_param->Data;

	switch (u8TestTrParamFeature) {
	case UNI_ATE_TSSI_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_TSSI_STATUS;
		break;

	case UNI_ATE_DPD_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_DPD_STATUS;
		break;

	case UNI_ATE_THERMO_COMP_STATUS_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_THERMO_COMP_STATUS;
		break;

	case UNI_ATE_FREQ_OFFSET_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_FREQ_OFFSET;
		break;

	case UNI_ATE_RATE_POWER_OFFSET_FEATURE:
		pTrParam->u2ParamIdx = UNI_ATE_RATE_POWER_OFFSET;
		break;

	default:
		Ret = NDIS_STATUS_INVALID_DATA;
		break;
	}

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdATEGetTestTab[UNI_ATE_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_ATE_TSSI_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdGetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_DPD_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdGetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_THERMO_COMP_STATUS_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdGetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_FREQ_OFFSET_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdGetTestTrParam
	},
	{
		.u8CmdFeature = UNI_ATE_RATE_POWER_OFFSET_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_TR_PARAM_CTRL_T),
		.pfHandler = UniCmdGetTestTrParam
	},
};



INT32 UniCmdSetATETest(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *tr_param, uint64_t u8TestTrParamFeature, uint8_t ucParamNum)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	uint16_t ucTLVNumber = 0;
	uint8_t *pTempBuf = NULL;
	uint8_t *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;

	struct UNI_CMD_TEST_TR_PARAM_T *pCmdTrParam = NULL;
	UINT32 TrParamTabSize = ARRAY_SIZE(UniCmdATESetTestTab);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TEST_TR_PARAM_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < TrParamTabSize; i++) {
		if (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdATESetTestTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdTrParam = (struct UNI_CMD_TEST_TR_PARAM_T *)pNextHeadBuf;
	pCmdTrParam->ucParamNum = ucParamNum;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < TrParamTabSize; i++) {
		switch (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature) {
		case UNI_ATE_TRX_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_RX_FILTER_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_RX_FILTER_PKT_LEN_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_SLOT_TIME_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_CLEAN_PERSTA_TXQUEUE_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_AMPDU_WTBL_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_MU_RX_AID_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_PHY_MANUAL_TX_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_RX_PATH_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_TX_STREAM_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_TSSI_STATUS_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_DPD_STATUS_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_RATE_POWER_OFFSET_ON_OFF_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_THERMO_COMP_STATUS_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_FREQ_OFFSET_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_FAGC_RSSI_PATH_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_PHY_STATUS_COUNT_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_RXV_INDEX_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_ANTENNA_PORT_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_THERMAL_ONOFF_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_TX_POWER_CONTROL_ALL_RF_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_RATE_POWER_OFFSET_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_SLT_CMD_TEST_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_SKU_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_POWER_PERCENTAGE_ON_OFF_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_BF_BACKOFF_ON_OFF_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_POWER_PERCENTAGE_LEVEL_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_FRTBL_CFG_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		case UNI_ATE_PREAMBLE_PUNC_FEATURE:
			if (UniCmdATESetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATESetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATESetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;
		default:
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if ((u8TestTrParamFeature & UniCmdATESetTestTab[i].u8CmdFeature) && (Ret != NDIS_STATUS_SUCCESS)) {
			MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
				"The handler of feature (0x%llx) return fail!\n",
				(UniCmdATESetTestTab[i].u8CmdFeature & u8TestTrParamFeature));
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_PRINT("%s(): TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		__func__, ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);


	/* Step 6: Send data packet and wrap fragement process if need */
	{
		uint8_t uSeqNum = AndesGetCmdMsgSeq(pAd);
		uint8_t uFragNum = 0;
		uint8_t uTotalFrag = 0;
		uint8_t bNeedFrag = FALSE;
		uint8_t bLastFrag = FALSE;

		if (u4RealUseBufSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % UNI_CMD_MAX_INBAND_CMD_LEN) == 0) ?
						  (u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) : ((u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;

		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
				bNeedFrag = TRUE;
				u4SendBufSize = UNI_CMD_MAX_INBAND_CMD_LEN;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TEST_TR_PARAM);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
#ifdef CONFIG_ATE
				SET_CMD_ATTR_RSP_HANDLER(attr, MtCmdATETestResp);
#else
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
#endif
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);


			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_PRINT("(Ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdGetATETest(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *tr_param, uint64_t u8TestTrParamFeature, uint8_t ucParamNum, uint32_t *pu4Status)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	uint16_t ucTLVNumber = 0;
	uint8_t *pTempBuf = NULL;
	uint8_t *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;

	struct UNI_CMD_TEST_TR_PARAM_T *pCmdTrParam = NULL;
	UINT32 TrParamTabSize = ARRAY_SIZE(UniCmdATEGetTestTab);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TEST_TR_PARAM_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < TrParamTabSize; i++) {
		if (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdATEGetTestTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdTrParam = (struct UNI_CMD_TEST_TR_PARAM_T *)pNextHeadBuf;
	pCmdTrParam->ucParamNum = ucParamNum;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < TrParamTabSize; i++) {
		switch (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature) {
		case UNI_ATE_TSSI_STATUS_FEATURE:
			if (UniCmdATEGetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATEGetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATEGetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_DPD_STATUS_FEATURE:
			if (UniCmdATEGetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATEGetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATEGetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_THERMO_COMP_STATUS_FEATURE:
			if (UniCmdATEGetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATEGetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATEGetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_FREQ_OFFSET_FEATURE:
			if (UniCmdATEGetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATEGetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATEGetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		case UNI_ATE_RATE_POWER_OFFSET_FEATURE:
			if (UniCmdATEGetTestTab[i].pfHandler != NULL) {
				Ret = ((PFN_TEST_TR_PARAM_CTRL_HANDLE)(UniCmdATEGetTestTab[i].pfHandler))(pAd, tr_param, pNextHeadBuf, (u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature));
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdATEGetTestTab[i].u4StructSize;
					ucTLVNumber++;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if ((u8TestTrParamFeature & UniCmdATEGetTestTab[i].u8CmdFeature) && (Ret != NDIS_STATUS_SUCCESS)) {
			MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
				"The handler of feature (0x%llx) return fail!\n",
				(UniCmdATEGetTestTab[i].u8CmdFeature & u8TestTrParamFeature));
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_PRINT("%s(): TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			__func__, ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);


	/* Step 6: Send data packet and wrap fragement process if need */
	{
		uint8_t uSeqNum = AndesGetCmdMsgSeq(pAd);
		uint8_t uFragNum = 0;
		uint8_t uTotalFrag = 0;
		uint8_t bNeedFrag = FALSE;
		uint8_t bLastFrag = FALSE;

		if (u4RealUseBufSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % UNI_CMD_MAX_INBAND_CMD_LEN) == 0) ?
						  (u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) : ((u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;

		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
				bNeedFrag = TRUE;
				u4SendBufSize = UNI_CMD_MAX_INBAND_CMD_LEN;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TEST_TR_PARAM);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pu4Status);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTrParamHandleEvent);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);


			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_PRINT("(Ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdATETest(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_TR_PARAM_CTRL_T *tr_param, uint64_t u8TestTrParamFeature, uint8_t ucParamNum, uint32_t *pu4Status)
{
	if (tr_param->ucAction == ENUM_TR_PARAM_SET)
		return UniCmdSetATETest(pAd, tr_param, u8TestTrParamFeature, ucParamNum);
	else if (tr_param->ucAction == ENUM_TR_PARAM_GET)
		return UniCmdGetATETest(pAd, tr_param, u8TestTrParamFeature, ucParamNum, pu4Status);
	else
		return NDIS_STATUS_INVALID_DATA;

}

INT32 UniCmdTestmodeRxStatInfo(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_T *p_RxStatInfo, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_T *pRxStatInfo = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_T *)pHandle;

	/* Fill TLV format */
	pRxStatInfo->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT;
	pRxStatInfo->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_T);
	pRxStatInfo->u1BandIdx = p_RxStatInfo->u1BandIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxvCtrl(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_SET_RXV_CTRL_T *p_RxvCtrl, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_SET_RXV_CTRL_T *pRxvCtrl = (struct _UNI_CMD_TESTMODE_SET_RXV_CTRL_T *)pHandle;

	/* Fill TLV format */
	pRxvCtrl->u2Tag = UNI_CMD_TESTMODE_SET_RXV_CTRL;
	pRxvCtrl->u2Length = sizeof(struct _UNI_CMD_TESTMODE_SET_RXV_CTRL_T);
	pRxvCtrl->fgRxvEnable = p_RxvCtrl->fgRxvEnable;

	return Ret;
}

INT32 UniCmdTestmodeRxvRuCtrl(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_T *p_RxvRuCtrl, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_T *pRxvRuCtrl = (struct _UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_T *)pHandle;

	/* Fill TLV format */
	pRxvRuCtrl->u2Tag = UNI_CMD_TESTMODE_SET_RXV_RU_CTRL;
	pRxvRuCtrl->u2Length = sizeof(struct _UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_T);
	pRxvRuCtrl->u1RxvRuIdx = p_RxvRuCtrl->u1RxvRuIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxStatInfoBand(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_BAND_T *p_RxStatInfoBand, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_BAND_T *pRxStatInfoBand = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_BAND_T *)pHandle;

	/* Fill TLV format */
	pRxStatInfoBand->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT_BAND;
	pRxStatInfoBand->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_BAND_T);
	pRxStatInfoBand->u1BandIdx = p_RxStatInfoBand->u1BandIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxStatInfoPath(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_PATH_T *p_RxStatInfoPath, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_PATH_T *pRxStatInfoPath = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_PATH_T *)pHandle;

	/* Fill TLV format */
	pRxStatInfoPath->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT_PATH;
	pRxStatInfoPath->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_PATH_T);
	pRxStatInfoPath->u1PathIdx = p_RxStatInfoPath->u1PathIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxStatInfoUser(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_USER_T *p_RxStatInfoUser, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_USER_T *pRxStatInfoUser = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_USER_T *)pHandle;

	/* Fill TLV format */
	pRxStatInfoUser->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT_USER;
	pRxStatInfoUser->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_USER_T);
	pRxStatInfoUser->u1UserIdx = p_RxStatInfoUser->u1UserIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxStatInfoComm(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_COMM_T *p_RxStatInfoComm, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_COMM_T *pRxStatInfoComm = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_COMM_T *)pHandle;

	/* Fill TLV format */
	pRxStatInfoComm->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT_COMM;
	pRxStatInfoComm->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_COMM_T);

	return Ret;
}

INT32 UniCmdTestmodeRxStatUserCtrl(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T *p_RxStatUserCtrl, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T *pRxStatUserCtrl = (struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T *)pHandle;

	/* Fill TLV format */
	pRxStatUserCtrl->u2Tag = UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL;
	pRxStatUserCtrl->u2Length = sizeof(struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T);
	pRxStatUserCtrl->u1BandIdx = p_RxStatUserCtrl->u1BandIdx;
	pRxStatUserCtrl->u2UserIdx = p_RxStatUserCtrl->u2UserIdx;

	return Ret;
}

INT32 UniCmdTestmodeRxStatGetAll(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T *p_RxStatAll, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TESTMODE_GET_RX_STAT_ALL_T *pRxStatAll = (struct _UNI_CMD_TESTMODE_GET_RX_STAT_ALL_T *)pHandle;

	/* Fill TLV format */
	pRxStatAll->u2Tag = UNI_CMD_TESTMODE_GET_RX_STAT_ALL_V2;
	pRxStatAll->u2Length = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_ALL_T);
	pRxStatAll->u1BandIdx = p_RxStatAll->u1BandIdx;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdTestmodeRxStatTab[UNI_CMD_TESTMODE_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_T),
		.pfHandler = UniCmdTestmodeRxStatInfo
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_SET_RXV_CTRL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_SET_RXV_CTRL_T),
		.pfHandler = UniCmdTestmodeRxvCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_T),
		.pfHandler = UniCmdTestmodeRxvRuCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_BAND_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_BAND_T),
		.pfHandler = UniCmdTestmodeRxStatInfoBand
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_PATH_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_PATH_T),
		.pfHandler = UniCmdTestmodeRxStatInfoPath
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_USER_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_USER_T),
		.pfHandler = UniCmdTestmodeRxStatInfoUser
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_COMM_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_INFO_COMM_T),
		.pfHandler = UniCmdTestmodeRxStatInfoComm
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_T),
		.pfHandler = UniCmdTestmodeRxStatUserCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_TESTMODE_GET_RX_STAT_ALL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TESTMODE_GET_RX_STAT_ALL_T),
		.pfHandler = UniCmdTestmodeRxStatGetAll
	},
};

INT32 UniCmdTestmodeRxStat(struct _RTMP_ADAPTER *pAd,
	struct _UNI_CMD_TESTMODE_RX_T *prTestmodeRx,
	uint64_t u8TestmodeRxFeature,
	uint8_t *pucTestmodeRxWb,
	uint8_t band_idx)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	uint16_t ucTLVNumber = 0;
	uint8_t *pTempBuf = NULL;
	uint8_t *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 TestmodeRxTabSize = ARRAY_SIZE(UniCmdTestmodeRxStatTab);
	UINT32 u4LastAttrCtrlFlag = 0;
	UINT32 u4MidAttrCtrlFlag = 0;
	struct _UNI_CMD_TESTMODE_RX_STAT_T *pCmdRxStat = NULL;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct _UNI_CMD_TESTMODE_RX_STAT_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < TestmodeRxTabSize; i++) {
		if (u8TestmodeRxFeature & UniCmdTestmodeRxStatTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdTestmodeRxStatTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdRxStat = (struct _UNI_CMD_TESTMODE_RX_STAT_T *)pNextHeadBuf;
	pCmdRxStat->u1Band = band_idx;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < TestmodeRxTabSize; i++) {
		switch (u8TestmodeRxFeature & UniCmdTestmodeRxStatTab[i].u8CmdFeature) {
		case UNI_CMD_TESTMODE_GET_RX_STAT_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_SET_RXV_CTRL_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RXV_CTRL_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxvCtrlCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_SET_RXV_RU_CTRL_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RXV_RU_CTRL_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxvRuCtrlCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_GET_RX_STAT_BAND_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_INFO_BAND_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatBandCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_GET_RX_STAT_PATH_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_INFO_PATH_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatPathCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_GET_RX_STAT_USER_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_INFO_USER_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatUserCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_GET_RX_STAT_COMM_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_INFO_COMM_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatCommCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_SET_RX_STAT_USER_CTRL_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_USER_CTRL_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatUserCtrlCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		case UNI_CMD_TESTMODE_GET_RX_STAT_ALL_FEATURE:
			if (UniCmdTestmodeRxStatTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RX_STAT_ALL_HANDLE)(UniCmdTestmodeRxStatTab[i].pfHandler))(pAd, &prTestmodeRx->rRxStatAllCmd, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestmodeRxStatTab[i].u4StructSize;
					ucTLVNumber++;
					u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
					u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if ((u8TestmodeRxFeature & UniCmdTestmodeRxStatTab[i].u8CmdFeature) && (Ret != NDIS_STATUS_SUCCESS)) {
			MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
				"The handler of feature (0x%llx) return fail!\n",
				(UniCmdTestmodeRxStatTab[i].u8CmdFeature & u8TestmodeRxFeature));
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);


	/* Step 6: Send data packet and wrap fragement process if need */
	{
		uint8_t uSeqNum = AndesGetCmdMsgSeq(pAd);
		uint8_t uFragNum = 0;
		uint8_t uTotalFrag = 0;
		uint8_t bNeedFrag = FALSE;
		uint8_t bLastFrag = FALSE;

		if (u4RealUseBufSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % UNI_CMD_MAX_INBAND_CMD_LEN) == 0) ?
						  (u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) : ((u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;

		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
				bNeedFrag = TRUE;
				u4SendBufSize = UNI_CMD_MAX_INBAND_CMD_LEN;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TESTMODE_RX_STAT);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pucTestmodeRxWb);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, u4LastAttrCtrlFlag);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTestmodeRxStat);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, u4MidAttrCtrlFlag);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
		"(Ret = %d)\n", Ret);

	return Ret;
}

#ifdef SWACI_MECHANISM
INT32 UniCmdSetSwlnaTestMode(
	struct _RTMP_ADAPTER *pAd,
	UINT32 u4TestMode
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_SET_TESTMODE *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_SET_TESTMODE);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_TIMER_ENABLE*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_SET_TESTMODE *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_TESTMODE);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_SET_TESTMODE));
	prSwaciCtrl->u4TestMode = cpu2le32(u4TestMode);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSwlnaTimerCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1BandIdx,
	UINT8 u1Enable
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_TIMER_ENABLE *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_TIMER_ENABLE);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_TIMER_ENABLE*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_TIMER_ENABLE *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_TIMER_CONTROL);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_TIMER_ENABLE));
	prSwaciCtrl->u1DbdcIdx = u1BandIdx;
	prSwaciCtrl->fgEnable = u1Enable;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSwlnaEnable(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1Enable
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_ENABLE_T *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_ENABLE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_ENABLE*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_ENABLE_T *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_ENABLE);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_ENABLE_T));
	prSwaciCtrl->fgEnable = u1Enable;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetSwlnaThresh(
	struct _RTMP_ADAPTER *pAd,
	UINT32 u4Threshold
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_SET_THRESH *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_SET_THRESH);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_SET_THRESH*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_SET_THRESH *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_SET_THRESH_PARAMS);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_SET_THRESH));
	prSwaciCtrl->u4Threshold = cpu2le32(u4Threshold);

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetSwlnaCondition(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1Swcr0,
	UINT8 u1Swcr1,
	UINT8 u1Swcr2,
	INT8 i1Swcr4
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWCR_PARAMS *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWCR_PARAMS);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWCR_PARAMS*/
	prSwaciCtrl = (struct UNI_CMD_SWCR_PARAMS *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_CONDITION_PARAM);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWCR_PARAMS));
	prSwaciCtrl->u1SWCR0 = u1Swcr0;
	prSwaciCtrl->u1SWCR1 = u1Swcr1;
	prSwaciCtrl->u1SWCR2 = u1Swcr2;
	prSwaciCtrl->i1SWCR4 = i1Swcr4;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetSwlnaDenseParam(
	struct _RTMP_ADAPTER *pAd,
	INT8 i1MaxRcpi,
	INT8 i1MinSubRssi,
	UINT8 u1ReadCount,
	UINT8 u1MinDenseCount,
	UINT8 u1MaxDenseCount,
	UINT8 u1DenseCRValue
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_DENSE_LNA_PARAM *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_DENSE_LNA_PARAM);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_SET_DENSE_PARAMS*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_DENSE_LNA_PARAM *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_SET_DENSE_PARAMS);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_DENSE_LNA_PARAM));
	prSwaciCtrl->i1MinSubRssi = i1MinSubRssi;
	prSwaciCtrl->i1MaxRcpi = i1MaxRcpi;
	prSwaciCtrl->u1ReadCount = u1ReadCount;
	prSwaciCtrl->u1MinDenseCount = u1MinDenseCount;
	prSwaciCtrl->u1MaxDenseCount = u1MaxDenseCount;
	prSwaciCtrl->u1DenseCRValue = u1DenseCRValue;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetSwlnaTable(
	struct _RTMP_ADAPTER *pAd,
	UINT8 u1PhyBw,
	INT8 i4LnaIdx0,
	INT8 i4LnaIdx1,
	INT8 i4LnaIdx2,
	INT8 i4LnaIdx3,
	INT8 i4LnaIdx4
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_TABLE_PARAMS *prSwaciCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_TABLE_PARAMS);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_LNA_TABLE_PARAM*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_TABLE_PARAMS *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_LNA_TABLE_PARAM);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_TABLE_PARAMS));
	prSwaciCtrl->u1PhyBw = u1PhyBw;
	prSwaciCtrl->i1LnaParam[0] = i4LnaIdx0;
	prSwaciCtrl->i1LnaParam[1] = i4LnaIdx1;
	prSwaciCtrl->i1LnaParam[2] = i4LnaIdx2;
	prSwaciCtrl->i1LnaParam[3] = i4LnaIdx3;
	prSwaciCtrl->i1LnaParam[4] = i4LnaIdx4;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetSwaciGain(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;

	struct UNI_CMD_SWACI_GAIN_ADJUST_PARAMS *prSwaciCtrl;
	struct _EXT_CMD_LNA_GAIN_ADJUST_PARAMS *prGainAdjustParam = (struct _EXT_CMD_LNA_GAIN_ADJUST_PARAMS *)pData;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_GAIN_ADJUST_PARAMS);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_GAIN_ADJUST*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_GAIN_ADJUST_PARAMS *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_GAIN_ADJUST);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_GAIN_ADJUST_PARAMS));
	prSwaciCtrl->i1AdcSetPointAci = prGainAdjustParam->i1AdcSetPointAci;
	prSwaciCtrl->i1AdcSetPointAAciBw20 = prGainAdjustParam->i1AdcSetPointAAciBw20;
	prSwaciCtrl->i1AdcSetPointAAciBw40 = prGainAdjustParam->i1AdcSetPointAAciBw40;
	prSwaciCtrl->i1AdcSetPointAAciBw80 = prGainAdjustParam->i1AdcSetPointAAciBw80;
	prSwaciCtrl->i1AdcSetPointWanted = prGainAdjustParam->i1AdcSetPointWanted;
	prSwaciCtrl->i1MaxRfGain = prGainAdjustParam->i1MaxRfGain;
	prSwaciCtrl->i1RfdgcSetPointAci = prGainAdjustParam->i1RfdgcSetPointAci;
	prSwaciCtrl->i1RfdgcSetPointWanted = prGainAdjustParam->i1RfdgcSetPointWanted;
	prSwaciCtrl->i1MaxTotalGain = prGainAdjustParam->i1MaxTotalGain;
	prSwaciCtrl->i1FarGainBoundLong = prGainAdjustParam->i1FarGainBoundLong;
	prSwaciCtrl->i1FarGainBoundShort = prGainAdjustParam->i1FarGainBoundShort;
	prSwaciCtrl->i1AdcSetPoint = prGainAdjustParam->i1AdcSetPoint;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}

INT32 UniCmdSetTestModeRcpi(
	struct _RTMP_ADAPTER *pAd,
	UINT8 *pData
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT8 i, j;

	struct UNI_CMD_SWACI_SET_RCPI_TEST *prSwaciCtrl;
	struct _EXT_CMD_SET_RCPI_TEST *prRcpiTest = (struct _EXT_CMD_SET_RCPI_TEST *)pData;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SWACI_CTRL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_SWACI_SET_RCPI_TEST);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_SWACI_GAIN_ADJUST*/
	prSwaciCtrl = (struct UNI_CMD_SWACI_SET_RCPI_TEST *) pNextHeadBuf;
	prSwaciCtrl->u2Tag = cpu2le16(UNI_CMD_SWACI_SET_RCPI);
	prSwaciCtrl->u2Length = cpu2le16(sizeof(struct UNI_CMD_SWACI_SET_RCPI_TEST));

	for (i = 0; i < 2; i++)
		for (j = 0; j < 4; j++)
			prSwaciCtrl->au2Rcpi[i][j] = prRcpiTest->au2Rcpi[i][j];

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SWACI_CTRL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			 "(ret = %d)\n", Ret);
	return Ret;

}
#endif

INT32 UniCmdMuPwrCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  fgMuTxPwrManEn,
	INT8   cMuTxPwr,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_MU_CTRL_T prMUPowerCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_PRINT("%s: u1BandIdx: %d, fgMuTxPwrManEn: %d, cMuTxPwr: %d\n",
		__func__, u1BandIdx, fgMuTxPwrManEn, cMuTxPwr);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_MU_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_MU_TX_POWER_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_MU_TX_POWER_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_MU_CTRL_T));
	prMUPowerCtrl = (P_CMD_POWER_MU_CTRL_T) prtlvbuffer->aucBuffer;

	prMUPowerCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_MU_TX_POWER_CTRL;
	prMUPowerCtrl->fgMuTxPwrManEn = fgMuTxPwrManEn;
	prMUPowerCtrl->u1BandIdx = u1BandIdx;
	prMUPowerCtrl->cMuTxPwr = cMuTxPwr;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTxPwrDataPktCtrl(
	RTMP_ADAPTER * pAd,
	IN UINT16 u2Wcid,
	IN INT8 i1MaxBasePwr,
	IN INT8 i1PowerOffset,
	IN UINT8 u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct CMD_SET_PER_PKT_TX_POWER_T *prPerPktTxPower;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"%s: wcid: %d, MaxBasePwr: %d, Poweroffset: %d\n", __func__, u2Wcid, i1MaxBasePwr, i1PowerOffset);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct CMD_SET_PER_PKT_TX_POWER_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_MU_TX_POWER_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TX_POWER_SET_PER_PKT_POWER);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct CMD_SET_PER_PKT_TX_POWER_T));
	prPerPktTxPower = (struct CMD_SET_PER_PKT_TX_POWER_T *) prtlvbuffer->aucBuffer;

	prPerPktTxPower->u1PowerCtrlFormatId = UNI_CMD_TX_POWER_SET_PER_PKT_POWER;
	prPerPktTxPower->u1BandIdx = u1BandIdx;
	prPerPktTxPower->i1MaxBasePwr = i1MaxBasePwr;
	prPerPktTxPower->i1PowerOffset = i1PowerOffset;
	prPerPktTxPower->u2WlanIdx = u2Wcid;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"%s:(ret = %d)\n", __func__, Ret);
	return Ret;

}

INT32 UniCmdTxPwrMinDataPktCtrl(
	RTMP_ADAPTER * pAd,
	IN INT8 i1MinBasePwr,
	IN UINT8 u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	struct CMD_SET_MIN_TX_POWER_T *prMinTxPower;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"%s: MinBasePwr: %d, BandIdx: %d\n", __func__, i1MinBasePwr, u1BandIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct CMD_SET_MIN_TX_POWER_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_MU_TX_POWER_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TX_POWER_SET_PER_PKT_MIN_POWER);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct CMD_SET_MIN_TX_POWER_T));
	prMinTxPower = (struct CMD_SET_MIN_TX_POWER_T *) prtlvbuffer->aucBuffer;

	prMinTxPower->u1PowerCtrlFormatId = UNI_CMD_TX_POWER_SET_PER_PKT_MIN_POWER;
	prMinTxPower->u1BandIdx = u1BandIdx;
	prMinTxPower->i1MinBasePwr = i1MinBasePwr;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"%s:(ret = %d)\n", __func__, Ret);
	return Ret;

}

INT32 UniCmdTxPwrUpCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1BandIdx,
	INT8   cPwrUpCat,
	CHAR cPwrUpValue[POWER_UP_CATEGORY_RATE_NUM_V2]
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	P_CMD_POWER_BOOST_TABLE_CTRL_T prTxPwrUpTblCtrl = NULL;
	struct _CMD_POWER_BOOST_TABLE_CTRL_T_V2 *prTxPwrUpTblCtrl_V2 = NULL;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"ucBandIdx: %d, cPwrUpCat: %d\n",
		 u1BandIdx, cPwrUpCat);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"cPwrUpValue: (%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)-(%d)\n",
		 cPwrUpValue[0], cPwrUpValue[1], cPwrUpValue[2],
		 cPwrUpValue[3], cPwrUpValue[4], cPwrUpValue[5],
		 cPwrUpValue[6], cPwrUpValue[7], cPwrUpValue[8],
		 cPwrUpValue[9], cPwrUpValue[10], cPwrUpValue[11],
		 cPwrUpValue[12], cPwrUpValue[13], cPwrUpValue[14],
		 cPwrUpValue[15]);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	if (cap->tx_power_boost_ver == 2)
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct _CMD_POWER_BOOST_TABLE_CTRL_T_V2);
	else
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_BOOST_TABLE_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_UP_TABLE_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_UP_TABLE_CTRL);
	if (cap->tx_power_boost_ver == 2) {
		prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(struct _CMD_POWER_BOOST_TABLE_CTRL_T_V2));
		prTxPwrUpTblCtrl_V2 = (struct _CMD_POWER_BOOST_TABLE_CTRL_T_V2 *) prtlvbuffer->aucBuffer;
		prTxPwrUpTblCtrl_V2->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_UP_TABLE_CTRL;
		prTxPwrUpTblCtrl_V2->ucBandIdx = u1BandIdx;
		prTxPwrUpTblCtrl_V2->cPwrUpCat = cPwrUpCat;

		/* update Power Up Table value to buffer structure */
		os_move_mem(prTxPwrUpTblCtrl_V2->cPwrUpValue, cPwrUpValue,
			sizeof(CHAR) * POWER_UP_CATEGORY_RATE_NUM_V2);
	} else {
		prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_BOOST_TABLE_CTRL_T));
		prTxPwrUpTblCtrl = (P_CMD_POWER_BOOST_TABLE_CTRL_T) prtlvbuffer->aucBuffer;
		prTxPwrUpTblCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_UP_TABLE_CTRL;
		prTxPwrUpTblCtrl->ucBandIdx = u1BandIdx;
		prTxPwrUpTblCtrl->cPwrUpCat = cPwrUpCat;

		/* update Power Up Table value to buffer structure */
		os_move_mem(prTxPwrUpTblCtrl->cPwrUpValue, cPwrUpValue,
			sizeof(CHAR) * POWER_UP_CATEGORY_RATE_NUM);
	}

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}


INT32 UniCmdSetTxPowerCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1DbdcIdx,
	INT8   i1TargetPower,
	UINT8  u1AntIdx,
	UINT8  u1CenterChannel
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_EXT_CMD_TX_POWER_CTRL_T prCmdTxPwrCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_PRINT("%s: BandIdx: %d, Power: %d, AntIdx: %d\n",
			__func__, u1DbdcIdx, i1TargetPower, u1AntIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(EXT_CMD_TX_POWER_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_SET_TARGET_POWER*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_SET_TARGET_POWER);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(EXT_CMD_TX_POWER_CTRL_T));
	prCmdTxPwrCtrl = (P_EXT_CMD_TX_POWER_CTRL_T) prtlvbuffer->aucBuffer;

	prCmdTxPwrCtrl->u1PowerCtrlFormatId = UNI_CMD_TXPOWER_SET_TARGET_POWER;
	prCmdTxPwrCtrl->u1DbdcIdx = u1DbdcIdx;
	prCmdTxPwrCtrl->i1TargetPower = i1TargetPower;
	prCmdTxPwrCtrl->u1AntIdx = u1AntIdx;
	prCmdTxPwrCtrl->u1CenterChannel = u1CenterChannel;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdGetTxPower(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1DbdcIdx,
	UINT8  u1CenterChannel,
	UINT8  u1AntIdx,
	P_EXT_EVENT_ID_GET_TX_POWER_T prTxPwrResult
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_EXT_CMD_GET_TX_POWER_T prCmdTxPwrGetCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_PRINT("%s: u1CenterCh: %d, u1BandIdx: %d, u1AntIdx: %d\n",
			 __func__, u1CenterChannel, u1DbdcIdx, u1AntIdx);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(EXT_CMD_GET_TX_POWER_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_GET_TARGET_POWER*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_GET_TARGET_POWER);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(EXT_CMD_GET_TX_POWER_T));
	prCmdTxPwrGetCtrl = (P_EXT_CMD_GET_TX_POWER_T) prtlvbuffer->aucBuffer;

	prCmdTxPwrGetCtrl->u1PowerCtrlFormatId = UNI_CMD_TXPOWER_GET_TARGET_POWER;
	prCmdTxPwrGetCtrl->u1DbdcIdx = u1DbdcIdx;
	prCmdTxPwrGetCtrl->u1AntIdx = u1AntIdx;
	prCmdTxPwrGetCtrl->u1CenterCh = u1CenterChannel;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prTxPwrResult);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, (sizeof(struct UNI_EVENT_TXPOWER) + sizeof(EXT_EVENT_ID_GET_TX_POWER_T)));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTxPowerHandleEvent);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdSetForceTxPowerCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1BandIdx,
	INT8   i1TxPower,
	UINT8  u1PhyMode,
	UINT8  u1TxRate,
	UINT8  u1BW
)
{
	struct cmd_msg *msg;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;

	P_CMD_POWER_RATE_TXPOWER_CTRL_T prCmdTxPwrCtrl;
	struct UNI_CMD_TXPOWER_TLV *prtlvbuffer;

	MTWF_PRINT("%s: Band(%d), TxMode(%d), MCS(%d), BW(%d), TxPower(%d)\n",
			__func__, u1BandIdx, u1PhyMode, u1TxRate, u1BW, i1TxPower);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TXPOWER_CONFIG);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_RATE_TXPOWER_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TXPOWER_TX_RATE_POWER_CTRL*/
	prtlvbuffer = (struct UNI_CMD_TXPOWER_TLV *) pNextHeadBuf;
	prtlvbuffer->u2Tag = cpu2le16(UNI_CMD_TXPOWER_TX_RATE_POWER_CTRL);
	prtlvbuffer->u2Length = cpu2le16(sizeof(struct UNI_CMD_TXPOWER_TLV) + sizeof(CMD_POWER_RATE_TXPOWER_CTRL_T));
	prCmdTxPwrCtrl = (P_CMD_POWER_RATE_TXPOWER_CTRL_T) prtlvbuffer->aucBuffer;

	prCmdTxPwrCtrl->ucPowerCtrlFormatId = UNI_CMD_TXPOWER_TX_RATE_POWER_CTRL;
	prCmdTxPwrCtrl->ucPhyMode = u1PhyMode;
	prCmdTxPwrCtrl->ucTxRate = u1TxRate;
	prCmdTxPwrCtrl->ucBW = u1BW;
	prCmdTxPwrCtrl->ucBandIdx = u1BandIdx;
	prCmdTxPwrCtrl->cTxPower = i1TxPower;

	/* Step 4: Send data packet*/
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TXPOWER);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);
	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

static INT32 UniCmdTPCManCtrlHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_MAN_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_MAN_CTRL_T pTPCManCtrl = (P_UNI_CMD_TPC_MAN_CTRL_T)pHandle;

	pTPCManCtrl->u2Tag = UNI_CMD_TPC_ACT_MANUAL_MODE;
	pTPCManCtrl->u2Length = sizeof(UNI_CMD_TPC_MAN_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCManCtrl->u2Tag = cpu2le16(pTPCManCtrl->u2Tag);
	pTPCManCtrl->u2Length = cpu2le16(pTPCManCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCManCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCManCtrl->fgTpcEnable = pParam->fgTpcEnable;
	pTPCManCtrl->eTpcParamMode = pParam->eTpcParamMode;

	return Ret;
}

static INT32 UniCmdTPCUlAlgoCtrlHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pTPCUlAlgoCtrl = (P_UNI_CMD_TPC_UL_ALGO_CTRL_T)pHandle;

	pTPCUlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_UL_TX_POWER_CONFIG;
	pTPCUlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCUlAlgoCtrl->u2Tag = cpu2le16(pTPCUlAlgoCtrl->u2Tag);
	pTPCUlAlgoCtrl->u2Length = cpu2le16(pTPCUlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCUlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCUlAlgoCtrl->u1ApTxPwr = pParam->u1ApTxPwr;
	pTPCUlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCUlAlgoCtrl->u1TargetRssi = pParam->u1TargetRssi;
	pTPCUlAlgoCtrl->u1UPH = pParam->u1UPH;
	pTPCUlAlgoCtrl->fgMinPwrFlag = pParam->fgMinPwrFlag;

	return Ret;
}

static INT32 UniCmdTPCUlTargetRSSIConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pTPCUlAlgoCtrl = (P_UNI_CMD_TPC_UL_ALGO_CTRL_T)pHandle;

	pTPCUlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_UL_TARGET_RSSI_CONFIG;
	pTPCUlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCUlAlgoCtrl->u2Tag = cpu2le16(pTPCUlAlgoCtrl->u2Tag);
	pTPCUlAlgoCtrl->u2Length = cpu2le16(pTPCUlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCUlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCUlAlgoCtrl->u1ApTxPwr = pParam->u1ApTxPwr;
	pTPCUlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCUlAlgoCtrl->u1TargetRssi = pParam->u1TargetRssi;
	pTPCUlAlgoCtrl->u1UPH = pParam->u1UPH;
	pTPCUlAlgoCtrl->fgMinPwrFlag = pParam->fgMinPwrFlag;

	return Ret;
}

static INT32 UniCmdTPCUlUPHMinPwrFGConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_UL_ALGO_CTRL_T pTPCUlAlgoCtrl = (P_UNI_CMD_TPC_UL_ALGO_CTRL_T)pHandle;

	pTPCUlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_UL_UPH_MIN_PWR_FG_CONFIG;
	pTPCUlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCUlAlgoCtrl->u2Tag = cpu2le16(pTPCUlAlgoCtrl->u2Tag);
	pTPCUlAlgoCtrl->u2Length = cpu2le16(pTPCUlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCUlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCUlAlgoCtrl->u1ApTxPwr = pParam->u1ApTxPwr;
	pTPCUlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCUlAlgoCtrl->u1TargetRssi = pParam->u1TargetRssi;
	pTPCUlAlgoCtrl->u1UPH = pParam->u1UPH;
	pTPCUlAlgoCtrl->fgMinPwrFlag = pParam->fgMinPwrFlag;

	return Ret;
}

static INT32 UniCmdTPCDlTxPwrCmdCtrlConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pTPCDlAlgoCtrl = (P_UNI_CMD_TPC_DL_ALGO_CTRL_T)pHandle;

	pTPCDlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_DL_TX_POWER_CMD_CTRL_CONFIG;
	pTPCDlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCDlAlgoCtrl->u2Tag = cpu2le16(pTPCDlAlgoCtrl->u2Tag);
	pTPCDlAlgoCtrl->u2Length = cpu2le16(pTPCDlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCDlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCDlAlgoCtrl->i1DlTxPwr = pParam->i1DlTxPwr;
	pTPCDlAlgoCtrl->fgDlTxPwrCmdCtrl = pParam->fgDlTxPwrCmdCtrl;
	pTPCDlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCDlAlgoCtrl->i2DlTxPwrAlpha = cpu2le16(pParam->i2DlTxPwrAlpha);
	pTPCDlAlgoCtrl->eTpcDlTxType = pParam->eTpcDlTxType;

	return Ret;
}

static INT32 UniCmdTPCDlTxPwrConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pTPCDlAlgoCtrl = (P_UNI_CMD_TPC_DL_ALGO_CTRL_T)pHandle;

	pTPCDlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_DL_TX_POWER_CONFIG;
	pTPCDlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCDlAlgoCtrl->u2Tag = cpu2le16(pTPCDlAlgoCtrl->u2Tag);
	pTPCDlAlgoCtrl->u2Length = cpu2le16(pTPCDlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCDlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCDlAlgoCtrl->i1DlTxPwr = pParam->i1DlTxPwr;
	pTPCDlAlgoCtrl->fgDlTxPwrCmdCtrl = pParam->fgDlTxPwrCmdCtrl;
	pTPCDlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCDlAlgoCtrl->i2DlTxPwrAlpha = cpu2le16(pParam->i2DlTxPwrAlpha);
	pTPCDlAlgoCtrl->eTpcDlTxType = pParam->eTpcDlTxType;

	return Ret;
}

static INT32 UniCmdTPCDlTxPwrAlphaConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_DL_ALGO_CTRL_T pTPCDlAlgoCtrl = (P_UNI_CMD_TPC_DL_ALGO_CTRL_T)pHandle;

	pTPCDlAlgoCtrl->u2Tag = UNI_CMD_TPC_ACT_DL_TX_POWER_ALPHA_CONFIG;
	pTPCDlAlgoCtrl->u2Length = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCDlAlgoCtrl->u2Tag = cpu2le16(pTPCDlAlgoCtrl->u2Tag);
	pTPCDlAlgoCtrl->u2Length = cpu2le16(pTPCDlAlgoCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCDlAlgoCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCDlAlgoCtrl->i1DlTxPwr = pParam->i1DlTxPwr;
	pTPCDlAlgoCtrl->fgDlTxPwrCmdCtrl = pParam->fgDlTxPwrCmdCtrl;
	pTPCDlAlgoCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCDlAlgoCtrl->i2DlTxPwrAlpha = cpu2le16(pParam->i2DlTxPwrAlpha);
	pTPCDlAlgoCtrl->eTpcDlTxType = pParam->eTpcDlTxType;

	return Ret;
}

static INT32 UniCmdTPCManTblInfoHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_MAN_TBL_INFO_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_MAN_TBL_INFO_T pTPCManTblInfo = (P_UNI_CMD_TPC_MAN_TBL_INFO_T)pHandle;

	pTPCManTblInfo->u2Tag = UNI_CMD_TPC_ACT_MAN_TBL_INFO;
	pTPCManTblInfo->u2Length = sizeof(UNI_CMD_TPC_MAN_TBL_INFO_T);
#ifdef CFG_BIG_ENDIAN
	pTPCManTblInfo->u2Tag = cpu2le16(pTPCManTblInfo->u2Tag);
	pTPCManTblInfo->u2Length = cpu2le16(pTPCManTblInfo->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCManTblInfo->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCManTblInfo->fgUplink = pParam->fgUplink;

	return Ret;
}

static INT32 UniCmdTPCManWlanIDCtrlHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_MAN_WLAN_ID_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_MAN_WLAN_ID_CTRL_T pTPCManWlanIDCtrl = (P_UNI_CMD_TPC_MAN_WLAN_ID_CTRL_T)pHandle;

	pTPCManWlanIDCtrl->u2Tag = UNI_CMD_TPC_ACT_WLANID_CTRL;
	pTPCManWlanIDCtrl->u2Length = sizeof(UNI_CMD_TPC_MAN_WLAN_ID_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCManWlanIDCtrl->u2Tag = cpu2le16(pTPCManWlanIDCtrl->u2Tag);
	pTPCManWlanIDCtrl->u2Length = cpu2le16(pTPCManWlanIDCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCManWlanIDCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCManWlanIDCtrl->u1EntryIdx = pParam->u1EntryIdx;
	pTPCManWlanIDCtrl->u2WlanId = cpu2le16(pParam->u2WlanId);
	pTPCManWlanIDCtrl->fgUplink = pParam->fgUplink;
	pTPCManWlanIDCtrl->eTpcDlTxType = pParam->eTpcDlTxType;

	return Ret;
}

static INT32 UniCmdTPCUlUnitTestConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_UL_UT_VAR_CFG_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_UL_UT_VAR_CFG_T pTPCUlUnitTestConfig = (P_UNI_CMD_TPC_UL_UT_VAR_CFG_T)pHandle;

	pTPCUlUnitTestConfig->u2Tag = UNI_CMD_TPC_ACT_UL_UNIT_TEST_CONFIG;
	pTPCUlUnitTestConfig->u2Length = sizeof(UNI_CMD_TPC_UL_UT_VAR_CFG_T);
#ifdef CFG_BIG_ENDIAN
	pTPCUlUnitTestConfig->u2Tag = cpu2le16(pTPCUlUnitTestConfig->u2Tag);
	pTPCUlUnitTestConfig->u2Length = cpu2le16(pTPCUlUnitTestConfig->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCUlUnitTestConfig->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCUlUnitTestConfig->u1EntryIdx = pParam->u1EntryIdx;
	pTPCUlUnitTestConfig->i2Value = cpu2le16(pParam->i2Value);
	pTPCUlUnitTestConfig->u1VarType = pParam->u1VarType;

	return Ret;
}

static INT32 UniCmdTPCUlUnitTestGoHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_UL_UT_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_UL_UT_CTRL_T pTPCUlUnitTestGo = (P_UNI_CMD_TPC_UL_UT_CTRL_T)pHandle;

	pTPCUlUnitTestGo->u2Tag = UNI_CMD_TPC_ACT_UL_UNIT_TEST_GO;
	pTPCUlUnitTestGo->u2Length = sizeof(UNI_CMD_TPC_UL_UT_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCUlUnitTestGo->u2Tag = cpu2le16(pTPCUlUnitTestGo->u2Tag);
	pTPCUlUnitTestGo->u2Length = cpu2le16(pTPCUlUnitTestGo->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCUlUnitTestGo->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCUlUnitTestGo->fgTpcUtGo = pParam->fgTpcUtGo;

	return Ret;
}

static INT32 UniCmdTPCEnableConfigHook(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_TPC_MAN_CTRL_T pParam,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_TPC_MAN_CTRL_T pTPCManCtrl = (P_UNI_CMD_TPC_MAN_CTRL_T)pHandle;

	pTPCManCtrl->u2Tag = UNI_CMD_TPC_ACT_ENABLE_CONFIG;
	pTPCManCtrl->u2Length = sizeof(UNI_CMD_TPC_MAN_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	pTPCManCtrl->u2Tag = cpu2le16(pTPCManCtrl->u2Tag);
	pTPCManCtrl->u2Length = cpu2le16(pTPCManCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pTPCManCtrl->u1TpcCtrlFormatId = pParam->u1TpcCtrlFormatId;
	pTPCManCtrl->fgTpcEnable = pParam->fgTpcEnable;
	pTPCManCtrl->eTpcParamMode = pParam->eTpcParamMode;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdTPCTab[UNI_CMD_TPC_ALGO_ACTION_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_MANUAL_MODE,
		.u4StructSize = sizeof(UNI_CMD_TPC_MAN_CTRL_T),
		.pfHandler = UniCmdTPCManCtrlHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_UL_TX_POWER_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCUlAlgoCtrlHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_UL_TARGET_RSSI_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCUlTargetRSSIConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_UL_UPH_MIN_PWR_FG_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_UL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCUlUPHMinPwrFGConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_DL_TX_POWER_CMD_CTRL_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCDlTxPwrCmdCtrlConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_DL_TX_POWER_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCDlTxPwrConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_DL_TX_POWER_ALPHA_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_DL_ALGO_CTRL_T),
		.pfHandler = UniCmdTPCDlTxPwrAlphaConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_MAN_TBL_INFO,
		.u4StructSize = sizeof(UNI_CMD_TPC_MAN_TBL_INFO_T),
		.pfHandler = UniCmdTPCManTblInfoHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_WLANID_CTRL,
		.u4StructSize = sizeof(UNI_CMD_TPC_MAN_WLAN_ID_CTRL_T),
		.pfHandler = UniCmdTPCManWlanIDCtrlHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_UL_UNIT_TEST_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_UL_UT_VAR_CFG_T),
		.pfHandler = UniCmdTPCUlUnitTestConfigHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_UL_UNIT_TEST_GO,
		.u4StructSize = sizeof(UNI_CMD_TPC_UL_UT_CTRL_T),
		.pfHandler = UniCmdTPCUlUnitTestGoHook
	},
	{
		.u8CmdFeature = UNI_CMD_TPC_ACT_ENABLE_CONFIG,
		.u4StructSize = sizeof(UNI_CMD_TPC_MAN_CTRL_T),
		.pfHandler = UniCmdTPCEnableConfigHook
	},
};

INT32 UniCmdTPC(struct _RTMP_ADAPTER *pAd, P_UNI_CMD_TPC_PARAM_T pParamCtrl)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	P_UNI_CMD_TPC_T	pCmdTPC = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_TPC_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_TPC_ALGO_ACTION_NUM; i++) {
		if (pParamCtrl->TPCTagValid[i])
			u4CmdNeedMaxBufSize += UniCmdTPCTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdTPC = (P_UNI_CMD_TPC_T)pNextHeadBuf;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_TPC_ALGO_ACTION_NUM; i++) {
		if (pParamCtrl->TPCTagValid[i]) {
			switch (i) {
			case UNI_CMD_TPC_ACT_MANUAL_MODE:
			case UNI_CMD_TPC_ACT_ENABLE_CONFIG:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_MAN_CTRL_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCManCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_UL_TX_POWER_CONFIG:
			case UNI_CMD_TPC_ACT_UL_TARGET_RSSI_CONFIG:
			case UNI_CMD_TPC_ACT_UL_UPH_MIN_PWR_FG_CONFIG:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_UL_ALGO_CTRL_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCUlAlgoCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_DL_TX_POWER_CMD_CTRL_CONFIG:
			case UNI_CMD_TPC_ACT_DL_TX_POWER_CONFIG:
			case UNI_CMD_TPC_ACT_DL_TX_POWER_ALPHA_CONFIG:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_DL_ALGO_CTRL_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCDlAlgoCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_MAN_TBL_INFO:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_MAN_TBL_INFO_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCManTblInfo, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_WLANID_CTRL:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_MAN_WLAN_ID_CTRL_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCManWlanIDCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_UL_UNIT_TEST_CONFIG:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_UL_UT_VAR_CFG_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCUlUTVarCfg, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_TPC_ACT_UL_UNIT_TEST_GO:
				if (UniCmdTPCTab[i].pfHandler != NULL) {
					Ret = ((PFN_TPC_UL_UT_CTRL_HANDLE)(UniCmdTPCTab[i].pfHandler))(pAd, &pParamCtrl->TPCUlUTCtrl, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdTPCTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) not support!\n", UniCmdTPCTab[i].u8CmdFeature);
				break;
			}

			if (Ret != NDIS_STATUS_SUCCESS)
				MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
					"The hanlder of tag (0x%llx) return fail!\n", UniCmdTPCTab[i].u8CmdFeature);
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE 	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TPC);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (pParamCtrl->bQuery) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTPCHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				}
			} else {
				if (pParamCtrl->bQuery)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTPCManCtrl(struct _RTMP_ADAPTER *pAd, BOOLEAN fgTpcManual)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: fgTpcManual: %d\n", __func__, fgTpcManual);

	TPCParam.TPCManCtrl.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_MANUAL_MODE;
	if (fgTpcManual == TRUE)
		TPCParam.TPCManCtrl.eTpcParamMode = UNI_TPC_PARAM_MAN_MODE;
	else
		TPCParam.TPCManCtrl.eTpcParamMode = UNI_TPC_PARAM_AUTO_MODE;

	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_MANUAL_MODE] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCUlAlgoCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8	u1TpcCmd,
	UINT8	u1ApTxPwr,
	UINT8	u1EntryIdx,
	UINT8	u1TargetRssi,
	UINT8	u1UPH,
	BOOLEAN	fgMinPwrFlag
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: u1TpcCmd: %d, u1ApTxPwr: %d\n",
		__func__, u1TpcCmd, u1ApTxPwr);

	MTWF_PRINT("u1EntryIdx: %d, u1TargetRssi: %d, u1UPH: %d, fgMinPwrFlag: %d\n",
				u1EntryIdx, u1TargetRssi, u1UPH, fgMinPwrFlag);

	TPCParam.TPCUlAlgoCtrl.u1TpcCtrlFormatId = (u1TpcCmd + 1);
	TPCParam.TPCUlAlgoCtrl.u1ApTxPwr = u1ApTxPwr;
	TPCParam.TPCUlAlgoCtrl.u1EntryIdx = u1EntryIdx;
	TPCParam.TPCUlAlgoCtrl.u1TargetRssi = u1TargetRssi;
	TPCParam.TPCUlAlgoCtrl.u1UPH = u1UPH;
	TPCParam.TPCUlAlgoCtrl.fgMinPwrFlag = fgMinPwrFlag;

	if (((u1TpcCmd + 1) >= UNI_CMD_TPC_ACT_UL_TX_POWER_CONFIG) &&
		((u1TpcCmd + 1) <= UNI_CMD_TPC_ACT_UL_UPH_MIN_PWR_FG_CONFIG))
		TPCParam.TPCTagValid[(u1TpcCmd + 1)] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCDlAlgoCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8	u1TpcCmd,
	BOOLEAN	fgCmdCtrl,
	UINT8	u1DlTxType,
	CHAR	DlTxPwr,
	UINT8	u1EntryIdx,
	INT16	DlTxpwrAlpha
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: u1TpcCmd: %d, fgCmdCtrl: %d\n",
		__func__, u1TpcCmd, fgCmdCtrl);

	MTWF_PRINT("u1DlTxType: %d, DlTxPwr: %d, u1EntryIdx: %d, DlTxpwrAlpha: %d\n",
			u1DlTxType, DlTxPwr, u1EntryIdx, DlTxpwrAlpha);

	TPCParam.TPCDlAlgoCtrl.u1TpcCtrlFormatId = (u1TpcCmd + 4);
	TPCParam.TPCDlAlgoCtrl.i1DlTxPwr = DlTxPwr;
	TPCParam.TPCDlAlgoCtrl.fgDlTxPwrCmdCtrl = fgCmdCtrl;
	TPCParam.TPCDlAlgoCtrl.u1EntryIdx = u1EntryIdx;
	TPCParam.TPCDlAlgoCtrl.i2DlTxPwrAlpha = DlTxpwrAlpha;
	TPCParam.TPCDlAlgoCtrl.eTpcDlTxType = (UNI_ENUM_TPC_DL_TX_TYPE)u1DlTxType;

	if (((u1TpcCmd + 4) >= UNI_CMD_TPC_ACT_DL_TX_POWER_CMD_CTRL_CONFIG) &&
		((u1TpcCmd + 4) <= UNI_CMD_TPC_ACT_DL_TX_POWER_ALPHA_CONFIG))
		TPCParam.TPCTagValid[(u1TpcCmd + 4)] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCManTblInfo(
	struct _RTMP_ADAPTER *pAd,
	BOOLEAN fgUplink
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: fgUplink: %d\n", __func__, fgUplink);

	TPCParam.bQuery = TRUE;
	TPCParam.TPCManTblInfo.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_MAN_TBL_INFO;
	TPCParam.TPCManTblInfo.fgUplink = fgUplink;
	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_MAN_TBL_INFO] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCWlanIdCtrl(
	struct _RTMP_ADAPTER *pAd,
	BOOLEAN fgUplink,
	UINT8   u1EntryIdx,
	UINT16  u2WlanId,
	UINT8 u1DlTxType
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: fgUplink: %d, u1EntryIdx: %d, u2WlanId: %d, u1DlTxType: %d\n",
				__func__, fgUplink, u1EntryIdx, u2WlanId, u1DlTxType);

	TPCParam.TPCManWlanIDCtrl.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_WLANID_CTRL;
	TPCParam.TPCManWlanIDCtrl.u1EntryIdx = u1EntryIdx;
	TPCParam.TPCManWlanIDCtrl.u2WlanId = u2WlanId;
	TPCParam.TPCManWlanIDCtrl.fgUplink = fgUplink;
	TPCParam.TPCManWlanIDCtrl.eTpcDlTxType = (UNI_ENUM_TPC_DL_TX_TYPE)u1DlTxType;
	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_WLANID_CTRL] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCUlUtVarCfg(
	struct _RTMP_ADAPTER *pAd,
	UINT8	u1EntryIdx,
	UINT8	u1VarType,
	INT16	i2Value)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("u1EntryIdx: %d, VarType:%d, Value: %d\n",
		u1EntryIdx, u1VarType, i2Value);

	TPCParam.TPCUlUTVarCfg.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_UL_UNIT_TEST_CONFIG;
	TPCParam.TPCUlUTVarCfg.u1EntryIdx = u1EntryIdx;
	TPCParam.TPCUlUTVarCfg.i2Value = i2Value;
	TPCParam.TPCUlUTVarCfg.u1VarType = u1VarType;
	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_UL_UNIT_TEST_CONFIG] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCUlUtGo(
	struct _RTMP_ADAPTER *pAd,
	BOOLEAN fgTpcUtGo
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: fgTpcUtGo: %d\n", __func__, fgTpcUtGo);

	TPCParam.TPCUlUTCtrl.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_UL_UNIT_TEST_GO;
	TPCParam.TPCUlUTCtrl.fgTpcUtGo = fgTpcUtGo;
	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_UL_UNIT_TEST_GO] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdTPCEnableCfg(
	struct _RTMP_ADAPTER *pAd,
	BOOLEAN fgTpcEnable
)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_TPC_PARAM_T TPCParam;

	os_zero_mem(&TPCParam, sizeof(TPCParam));

	MTWF_PRINT("%s: fgTpcEnable: %d\n", __func__, fgTpcEnable);

	TPCParam.TPCManCtrl.u1TpcCtrlFormatId = UNI_CMD_TPC_ACT_ENABLE_CONFIG;
	TPCParam.TPCManCtrl.fgTpcEnable = fgTpcEnable;
	TPCParam.TPCTagValid[UNI_CMD_TPC_ACT_ENABLE_CONFIG] = TRUE;

	ret = UniCmdTPC(pAd, &TPCParam);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(Ret = %d)\n", ret);

	return ret;
}

INT32 UniCmdMecCtrl(
	struct _RTMP_ADAPTER *pAd,
	struct UNI_CMD_MEC_CTRL_PARAM_T *pParamCtrl
)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_MEC_T *pCmdMec = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_MEC_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_MEC_MAX_NUM; i++) {
		if (pParamCtrl->MecTagValid[i]) {
			switch (i) {
			case UNI_CMD_MEC_READ_INFO:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_read_info_t);
				break;

			case UNI_CMD_MEC_AMSDU_ALGO_EN_STA:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_algo_en_sta_t);
				break;

			case UNI_CMD_MEC_AMSDU_PARA_STA:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_amsdu_para_sta_t);
				break;

			case UNI_CMD_MEC_AMSDU_ALGO_THRESHOLD:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_amsdu_algo_thr);
				break;

			case UNI_CMD_MEC_IFAC_SPEED:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_ifac_speed);
				break;
			case UNI_CMD_MEC_CTRL_ACTION_AMSDU_MAX_LEN:
				u4CmdNeedMaxBufSize += sizeof(pParamCtrl->mec_set_amsdu_max_size_t);
				break;
			default:
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
						"Unknown type!\n");
				break;
			}
		}
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdMec = (struct UNI_CMD_MEC_T *)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_MEC_MAX_NUM; i++) {
		if (pParamCtrl->MecTagValid[i]) {
			switch (i) {
			case UNI_CMD_MEC_READ_INFO:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_read_info_t,
							sizeof(pParamCtrl->mec_read_info_t));
				pNextHeadBuf += sizeof(pParamCtrl->mec_read_info_t);
				break;

			case UNI_CMD_MEC_AMSDU_ALGO_EN_STA:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_algo_en_sta_t,
							sizeof(pParamCtrl->mec_algo_en_sta_t));
				pNextHeadBuf += sizeof(pParamCtrl->mec_algo_en_sta_t);
				break;

			case UNI_CMD_MEC_AMSDU_PARA_STA:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_amsdu_para_sta_t,
							sizeof(pParamCtrl->mec_amsdu_para_sta_t));
				pNextHeadBuf += sizeof(pParamCtrl->mec_amsdu_para_sta_t);
				break;

			case UNI_CMD_MEC_AMSDU_ALGO_THRESHOLD:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_amsdu_algo_thr,
							sizeof(pParamCtrl->mec_amsdu_algo_thr));
				pNextHeadBuf += sizeof(pParamCtrl->mec_amsdu_algo_thr);
				break;

			case UNI_CMD_MEC_IFAC_SPEED:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_ifac_speed,
							sizeof(pParamCtrl->mec_ifac_speed));
				pNextHeadBuf += sizeof(pParamCtrl->mec_ifac_speed);
				break;
			case UNI_CMD_MEC_CTRL_ACTION_AMSDU_MAX_LEN:
				os_move_mem(pNextHeadBuf, &pParamCtrl->mec_set_amsdu_max_size_t,
							sizeof(pParamCtrl->mec_set_amsdu_max_size_t));
				pNextHeadBuf += sizeof(pParamCtrl->mec_set_amsdu_max_size_t);
				break;
			default:
				MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
						"Unknown type!\n");
				break;
			}
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);
	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_INFO,
			"CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN bNeedFrag = FALSE;
		BOOLEAN bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */
			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MEC);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_MAC, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

#ifdef CFG_SUPPORT_CSI
INT32 UniCmdCSICtrl(
	struct _RTMP_ADAPTER *pAd,
	struct CMD_CSI_CONTROL_T *prCSICtrl)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_CSI_T CmdCSI = {0};
	struct UNI_CMD_CSI_STOP_T CmdCSIModeStop = {0};
	struct UNI_CMD_CSI_START_T CmdCSIModeStart = {0};
	struct UNI_CMD_CSI_SET_FRAME_TYPE_T CmdCSISetFrameType = {0};
	struct UNI_CMD_CSI_SET_CHAIN_NUMBER_T CmdCSISetChainNum = {0};
	struct UNI_CMD_CSI_SET_FILTER_MODE_T CmdCSISetFilterMode = {0};
	struct UNI_CMD_CSI_SET_ACTIVE_MODE_T CmdCSISetActiveMode = {0};
	struct _CMD_ATTRIBUTE attr = {0};

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CSI, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdCSI);
	os_zero_mem(&CmdCSI, u4ComCmdSize);
	os_zero_mem(&CmdCSIModeStop, sizeof(CmdCSIModeStop));
	os_zero_mem(&CmdCSIModeStart, sizeof(CmdCSIModeStart));
	os_zero_mem(&CmdCSISetFrameType, sizeof(CmdCSISetFrameType));
	os_zero_mem(&CmdCSISetChainNum, sizeof(CmdCSISetChainNum));
	os_zero_mem(&CmdCSISetFilterMode, sizeof(CmdCSISetFilterMode));
	os_zero_mem(&CmdCSISetActiveMode, sizeof(CmdCSISetActiveMode));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize;
	switch (prCSICtrl->ucMode) {
	case CSI_CONTROL_MODE_STOP:
		u4CmdNeedMaxBufSize += sizeof(CmdCSIModeStop);
		break;

	case CSI_CONTROL_MODE_START:
		u4CmdNeedMaxBufSize += sizeof(CmdCSIModeStart);
		break;

	case CSI_CONTROL_MODE_SET:
		if (prCSICtrl->ucCfgItem == CSI_CONFIG_FRAME_TYPE) {
			u4CmdNeedMaxBufSize += sizeof(CmdCSISetFrameType);
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_CHAIN_NUMBER) {
			u4CmdNeedMaxBufSize += sizeof(CmdCSISetChainNum);
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_FILTER_MODE) {
			u4CmdNeedMaxBufSize += sizeof(CmdCSISetFilterMode);
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_ACTIVE_MODE) {
			u4CmdNeedMaxBufSize += sizeof(CmdCSISetActiveMode);
		} else {
			MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CSI, DBG_LVL_ERROR,
			"Wrong input on ucCfgItem(%d) or not support!!!\n", prCSICtrl->ucCfgItem);
			Ret = NDIS_STATUS_FAILURE;
			goto error;
		}
		break;

	default:
		MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CSI, DBG_LVL_ERROR,
			"Wrong input on ucMode(%d) or not support!!!\n", prCSICtrl->ucMode);
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CSI);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	CmdCSI.ucBandIdx = prCSICtrl->BandIdx;
	AndesAppendCmdMsg(msg, (char *)&CmdCSI, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	switch (prCSICtrl->ucMode) {
	case CSI_CONTROL_MODE_STOP:
		CmdCSIModeStop.u2Tag = UNI_CMD_CSI_STOP;
		CmdCSIModeStop.u2Length = sizeof(CmdCSIModeStop);
#ifdef CFG_BIG_ENDIAN
		CmdCSIModeStop.u2Tag = cpu2le16(CmdCSIModeStop.u2Tag);
		CmdCSIModeStop.u2Length = cpu2le16(CmdCSIModeStop.u2Length);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&CmdCSIModeStop, sizeof(CmdCSIModeStop));
		break;

	case CSI_CONTROL_MODE_START:
		CmdCSIModeStart.u2Tag = UNI_CMD_CSI_START;
		CmdCSIModeStart.u2Length = sizeof(CmdCSIModeStart);
#ifdef CFG_BIG_ENDIAN
		CmdCSIModeStart.u2Tag = cpu2le16(CmdCSIModeStart.u2Tag);
		CmdCSIModeStart.u2Length = cpu2le16(CmdCSIModeStart.u2Length);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&CmdCSIModeStart, sizeof(CmdCSIModeStart));
		break;

	case CSI_CONTROL_MODE_SET:
		if (prCSICtrl->ucCfgItem == CSI_CONFIG_FRAME_TYPE) {
			CmdCSISetFrameType.u2Tag = UNI_CMD_CSI_SET_FRAME_TYPE;
			CmdCSISetFrameType.u2Length = sizeof(CmdCSISetFrameType);
#ifdef CFG_BIG_ENDIAN
			CmdCSISetFrameType.u2Tag = cpu2le16(CmdCSISetFrameType.u2Tag);
			CmdCSISetFrameType.u2Length = cpu2le16(CmdCSISetFrameType.u2Length);
#endif /* CFG_BIG_ENDIAN */
			CmdCSISetFrameType.ucFrameTypeIndex = prCSICtrl->ucValue1;
			CmdCSISetFrameType.ucFrameType = prCSICtrl->ucValue2;
			AndesAppendCmdMsg(msg, (char *)&CmdCSISetFrameType, sizeof(CmdCSISetFrameType));
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_CHAIN_NUMBER) {
			CmdCSISetChainNum.u2Tag = UNI_CMD_CSI_SET_CHAIN_NUMBER;
			CmdCSISetChainNum.u2Length = sizeof(CmdCSISetChainNum);
#ifdef CFG_BIG_ENDIAN
			CmdCSISetChainNum.u2Tag = cpu2le16(CmdCSISetChainNum.u2Tag);
			CmdCSISetChainNum.u2Length = cpu2le16(CmdCSISetChainNum.u2Length);
#endif /* CFG_BIG_ENDIAN */
			CmdCSISetChainNum.function = prCSICtrl->ucValue1;
			CmdCSISetChainNum.chain_value = prCSICtrl->ucValue2;
			AndesAppendCmdMsg(msg, (char *)&CmdCSISetChainNum, sizeof(CmdCSISetChainNum));
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_FILTER_MODE) {
			CmdCSISetFilterMode.u2Tag = UNI_CMD_CSI_SET_FILTER_MODE;
			CmdCSISetFilterMode.u2Length = sizeof(CmdCSISetFilterMode);
#ifdef CFG_BIG_ENDIAN
			CmdCSISetFilterMode.u2Tag = cpu2le16(CmdCSISetFilterMode.u2Tag);
			CmdCSISetFilterMode.u2Length = cpu2le16(CmdCSISetFilterMode.u2Length);
#endif /* CFG_BIG_ENDIAN */
			CmdCSISetFilterMode.ucOperation = prCSICtrl->ucValue2;
			NdisMoveMemory(CmdCSISetFilterMode.aucMACAddr, prCSICtrl->mac_addr, MAC_ADDR_LEN);
			AndesAppendCmdMsg(msg, (char *)&CmdCSISetFilterMode, sizeof(CmdCSISetFilterMode));
		} else if (prCSICtrl->ucCfgItem == CSI_CONFIG_ACTIVE_MODE) {
			CmdCSISetActiveMode.u2Tag = UNI_CMD_CSI_SET_ACTIVE_MODE;
			CmdCSISetActiveMode.u2Length = sizeof(CmdCSISetActiveMode);
#ifdef CFG_BIG_ENDIAN
			CmdCSISetActiveMode.u2Tag = cpu2le16(CmdCSISetActiveMode.u2Tag);
			CmdCSISetActiveMode.u2Length = cpu2le16(CmdCSISetActiveMode.u2Length);
#endif /* CFG_BIG_ENDIAN */
			CmdCSISetActiveMode.bitmap = prCSICtrl->wcid_bitmap;
			CmdCSISetActiveMode.interval = prCSICtrl->ucValue2;
			CmdCSISetActiveMode.frame_type_idx = GET_CSI_FRAME_TYPE(prCSICtrl->ucValue1);
			CmdCSISetActiveMode.subframe_type_idx = GET_CSI_SUBFRAME_TYPE(prCSICtrl->ucValue1);
			AndesAppendCmdMsg(msg, (char *)&CmdCSISetActiveMode, sizeof(CmdCSISetActiveMode));
		}
		break;

	default:
		break;
	}

	Ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_CHN, CATCHN_CSI, DBG_LVL_INFO,
			 "(Ret = %d)\n", Ret);

	return Ret;
}
#endif /* CFG_SUPPORT_CSI */

#ifdef VLAN_SUPPORT
INT32 UniCmdVLANUpdate(
	struct _RTMP_ADAPTER *pAd,
	UCHAR band_idx,
	UINT8 omac_idx,
	UINT8 op_code,
	UINT16 value)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_VLAN_CFG_T CmdVlanCfg = {0};
	struct UNI_CMD_VLAN_TCI_INFO_T CmdVlanTCIInfo = {0};
	struct _CMD_ATTRIBUTE	attr = {0};

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_TX, CATTX_VLAN, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(CmdVlanCfg);
	os_zero_mem(&CmdVlanCfg, u4ComCmdSize);
	os_zero_mem(&CmdVlanTCIInfo, sizeof(CmdVlanTCIInfo));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(CmdVlanTCIInfo);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_VLAN_CFG);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&CmdVlanCfg, u4ComCmdSize);

	/* Step 4: Fill TLV parameters here */
	CmdVlanTCIInfo.u2Tag = UNI_CMD_VLAN_TCI_INFO;
	CmdVlanTCIInfo.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	CmdVlanTCIInfo.u2Tag = cpu2le16(CmdVlanTCIInfo.u2Tag);
	CmdVlanTCIInfo.u2Length = cpu2le16(CmdVlanTCIInfo.u2Length);
#endif /* CFG_BIG_ENDIAN */
	CmdVlanTCIInfo.ucOmacId = omac_idx;
	CmdVlanTCIInfo.ucBandId = band_idx;
	CmdVlanTCIInfo.ucOpCode = op_code;
	if (op_code == UNI_CMD_VLAN_OP_VID)
		CmdVlanTCIInfo.u2TCI_VID = cpu2le16(value);
	else if (op_code == UNI_CMD_VLAN_OP_CFI)
		CmdVlanTCIInfo.ucTCI_CFI = value;
	else if (op_code == UNI_CMD_VLAN_OP_PCP)
		CmdVlanTCIInfo.ucTCI_PCP = value;

	AndesAppendCmdMsg(msg, (char *)&CmdVlanTCIInfo, (u4CmdNeedMaxBufSize - u4ComCmdSize));
	Ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_TX, CATTX_VLAN, DBG_LVL_INFO,
			 "(Ret = %d)\n", Ret);

	return Ret;
}
#endif /* VLAN_SUPPORT */

INT32 UniCmdThermalGetTemp(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1ActionIdx,
	UINT8  u1BandIdx,
	UINT32 *pu4SensorResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_SENSOR_INFO_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_THERMAL_SENSOR_INFO_T);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"ActionIdx: %d, uBandIdx: %d\n", u1ActionIdx, u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_SENSOR_INFO_T */
	prThermalParams = (struct UNI_CMD_THERMAL_SENSOR_INFO_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_FEATURE_TEMPERATURE_QUERY;
	prThermalParams->u2Length = sizeof(struct UNI_CMD_THERMAL_SENSOR_INFO_T);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1ActionIdx = u1ActionIdx;
	prThermalParams->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pu4SensorResult);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventThemalSensorRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalGetAdcTemp(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1SensorType,
	UINT8  u1BandIdx,
	UINT8 * pu4SensorResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_TEMP_ADC_INFO_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_THERMAL_TEMP_ADC_INFO_T);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"SensorType:%u, Band index: %u\n", u1SensorType, u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_SENSOR_INFO_T */
	prThermalParams = (struct UNI_CMD_THERMAL_TEMP_ADC_INFO_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_FEATURE_TEMP_ADC_QUERY;
	prThermalParams->u2Length = sizeof(struct UNI_CMD_THERMAL_TEMP_ADC_INFO_T);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SensorType = u1SensorType;
	prThermalParams->u1BandIndex = u1BandIdx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pu4SensorResult);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventThemalTempAdcRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalManCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1BandIdx,
	UINT8  fgManualMode,
	UINT8  u1ThermalAdc
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_SET_MAN_CTRL_T *prThermalManCtrl;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_THERMAL_SET_MAN_CTRL_T);

	MTWF_PRINT("%s(): u1BandIdx: %d, fgManualMode: %d, u1ThermalAdc: %d\n",
			__func__, u1BandIdx, fgManualMode, u1ThermalAdc);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_SET_MAN_CTRL_T */
	prThermalManCtrl = (struct UNI_CMD_THERMAL_SET_MAN_CTRL_T *) pNextHeadBuf;
	prThermalManCtrl->u2Tag = UNI_CMD_THERMAL_FEATURE_MANUAL_CTRL;
	prThermalManCtrl->u2Length = sizeof(struct UNI_CMD_THERMAL_SET_MAN_CTRL_T);
#ifdef CFG_BIG_ENDIAN
	prThermalManCtrl->u2Tag = cpu2le16(prThermalManCtrl->u2Tag);
	prThermalManCtrl->u2Length = cpu2le16(prThermalManCtrl->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalManCtrl->fgManualMode = fgManualMode;
	prThermalManCtrl->u1ThermalAdc = u1ThermalAdc;
	prThermalManCtrl->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalBasicInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1BandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_BASIC_INFO_T *prThermalBasicInfo;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_THERMAL_BASIC_INFO_T);

	MTWF_PRINT("%s(): u1BandIdx: %d\n", __func__, u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_BASIC_INFO_T */
	prThermalBasicInfo = (struct UNI_CMD_THERMAL_BASIC_INFO_T *) pNextHeadBuf;
	prThermalBasicInfo->u2Tag = UNI_CMD_THERMAL_FEATURE_BASIC_INFO_QUERY;
	prThermalBasicInfo->u2Length = sizeof(struct UNI_CMD_THERMAL_BASIC_INFO_T);
#ifdef CFG_BIG_ENDIAN
	prThermalBasicInfo->u2Tag = cpu2le16(prThermalBasicInfo->u2Tag);
	prThermalBasicInfo->u2Length = cpu2le16(prThermalBasicInfo->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalBasicInfo->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalTaskCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1BandIdx,
	UINT8  fgTrigEn,
	UINT8  u1Thres,
	UINT32 u4FuncPtr)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_SENSOR_TASK_T *prThermalSensorTask;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_THERMAL_SENSOR_TASK_T);

	MTWF_PRINT("%s(): u1BandIdx: %d, fgTrigEn: %d, u1Thres: %d\n",
				__func__, u1BandIdx, fgTrigEn, u1Thres);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_SENSOR_TASK_T */
	prThermalSensorTask = (struct UNI_CMD_THERMAL_SENSOR_TASK_T *) pNextHeadBuf;
	prThermalSensorTask->u2Tag = UNI_CMD_THERMAL_FEATURE_TASK_MANUAL_CTRL;
	prThermalSensorTask->u2Length = sizeof(struct UNI_CMD_THERMAL_SENSOR_TASK_T);
#ifdef CFG_BIG_ENDIAN
	prThermalSensorTask->u2Tag = cpu2le16(prThermalSensorTask->u2Tag);
	prThermalSensorTask->u2Length = cpu2le16(prThermalSensorTask->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalSensorTask->fgTrigEn = fgTrigEn;
	prThermalSensorTask->u1Thres = u1Thres;
	prThermalSensorTask->u4FuncPtr = u4FuncPtr;
	prThermalSensorTask->u1BandIdx = u1BandIdx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtect(
	struct _RTMP_ADAPTER *pAd,
	UINT8  u1Band,
	UINT8  u1HighEn,
	CHAR   cHighTempTh,
	UINT8  u1LowEn,
	CHAR   cLowTempTh,
	UINT32 u4RechkTimer,
	UINT8  u1RFOffEn,
	CHAR   cRFOffTh,
	UINT8  u1Type
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: Band:%u, HighEn:%u, HighTempTh:%d, LowEn:%u, LowTempTh:%d, RechkTimer:%u\n",
		__func__, u1Band, u1HighEn, cHighTempTh, u1LowEn, cLowTempTh, u4RechkTimer);

	MTWF_PRINT("%s: RFOffEn:%u, RFOffTh:%d, ucType:%u\n",
		__func__, u1RFOffEn, cRFOffTh, u1Type);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_PARAMETER_CTRL;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1BandIdx = u1Band;
	prThermalParams->u1HighEnable = u1HighEn;
	prThermalParams->i1HighTempThreshold = cHighTempTh;
	prThermalParams->u1LowEnable = u1LowEn;
	prThermalParams->i1LowTempThreshold = cLowTempTh;
	prThermalParams->u4RecheckTimer = cpu2le32(u4RechkTimer);
	prThermalParams->u1RFOffEnable = u1RFOffEn;
	prThermalParams->i1RFOffThreshold = cRFOffTh;
	prThermalParams->u1Type = u1Type;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectAdmitDutyInfo(
	struct _RTMP_ADAPTER *pAd
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: Enter\n", __func__);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_BASIC_INFO;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prThermalParams->u1ThermalCtrlFormatId = UNI_CMD_THERMAL_PROTECT_BASIC_INFO;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectEnable(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx,
	UINT8  protection_type,
	UINT8  trigger_type,
	INT32  trigger_temp,
	INT32  restore_temp,
	UINT16 recheck_time
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_ENABLE_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d, protect_type: %d\n", __func__,
		band_idx, protection_type);

	MTWF_PRINT("%s: trigger_type: %d, trigger_temp: %d\n", __func__,
		trigger_type, trigger_temp);

	MTWF_PRINT("%s: restore_temp: %d, recheck_time: %d\n", __func__,
		restore_temp, recheck_time);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_ENABLE_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_ENABLE_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_ENABLE;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_ENABLE;
	prThermalParams->u1BandIdx = band_idx;
	prThermalParams->u1ProtectionType = protection_type;
	prThermalParams->u1TriggerType = trigger_type;
	prThermalParams->i4TriggerTemp = trigger_temp;
	prThermalParams->i4RestoreTemp = restore_temp;
	prThermalParams->u2RecheckTime = recheck_time;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectDisable(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx,
	UINT8  protection_type,
	UINT8  trigger_type
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_DISABLE_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d, protect_type: %d\n", __func__,
		band_idx, protection_type);

	MTWF_PRINT("%s: trigger_type: %d\n", __func__,
		trigger_type);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_DISABLE_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_DISABLE_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_DISABLE;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_DISABLE;
	prThermalParams->u1BandIdx = band_idx;
	prThermalParams->u1ProtectionType = protection_type;
	prThermalParams->u1TriggerType = trigger_type;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectDutyCfg(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx,
	UINT8  level_idx,
	UINT8  duty
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_DUTY_CFG_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d, level_idx: %d\n", __func__,
		band_idx, level_idx);

	MTWF_PRINT("%s: duty: %d\n", __func__, duty);


	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_DUTY_CFG_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_DUTY_CFG_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_DUTY_CONFIG;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_DUTY_CONFIG;
	prThermalParams->u1BandIdx = band_idx;
	prThermalParams->u1LevelIndex = level_idx;
	prThermalParams->u1Duty = duty;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_INFO_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d\n", __func__, band_idx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_INFO_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_INFO_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_MECH_INFO;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_MECH_INFO;
	prThermalParams->u1BandIdx = band_idx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdThermalProtectDutyInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_DUTY_INFO_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d\n", __func__, band_idx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_DUTY_INFO_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_DUTY_INFO_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_DUTY_INFO;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_DUTY_INFO;
	prThermalParams->u1BandIdx = band_idx;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32
UniCmdThermalProtectStateAct(
	struct _RTMP_ADAPTER *pAd,
	UINT8  band_idx,
	UINT8  protect_type,
	UINT8  trig_type,
	UINT8  state
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_THERMAL_PROTECT_STATE_ACT_T *prThermalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_THERMAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prThermalParams);

	MTWF_PRINT("%s: band_idx: %d, protect_type: %d\n", __func__,
		band_idx, protect_type);

	MTWF_PRINT("%s: trig_type: %d, state: %d\n", __func__,
		trig_type, state);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_THERMAL_PROTECT_STATE_ACT_T */
	prThermalParams = (struct UNI_CMD_THERMAL_PROTECT_STATE_ACT_T *) pNextHeadBuf;

	prThermalParams->u2Tag = UNI_CMD_THERMAL_PROTECT_STATE_ACT;
	prThermalParams->u2Length = sizeof(*prThermalParams);
#ifdef CFG_BIG_ENDIAN
	prThermalParams->u2Tag = cpu2le16(prThermalParams->u2Tag);
	prThermalParams->u2Length = cpu2le16(prThermalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prThermalParams->u1SubCmdId = UNI_CMD_THERMAL_PROTECT_STATE_ACT;
	prThermalParams->u1BandIdx = band_idx;
	prThermalParams->u1ProtectType = protect_type;
	prThermalParams->u1TrigType = trig_type;
	prThermalParams->u1State = state;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_THERMAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

/*****************************************
 * Command ID: UNI_CMD_ID_NOISE_FLOOR 036
 *****************************************/
INT32
UniCmdSetNoiseFloorMode(
	struct _RTMP_ADAPTER *pAd,
	UINT8  Mode,
	UINT8  Action
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_NOISE_FLOOR_MODE_CTRL_T *prNoiseFloorParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_NOISE_FLOOR_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prNoiseFloorParams);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"Mode: %d, Action: %d\n",
		Mode, Action);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_NOISE_FLOOR_MODE_CTRL_T */
	prNoiseFloorParams = (struct UNI_CMD_NOISE_FLOOR_MODE_CTRL_T *) pNextHeadBuf;

	prNoiseFloorParams->u2Tag = Mode;
	prNoiseFloorParams->u2Length = sizeof(*prNoiseFloorParams);
#ifdef CFG_BIG_ENDIAN
	prNoiseFloorParams->u2Tag = cpu2le16(prNoiseFloorParams->u2Tag);
	prNoiseFloorParams->u2Length = cpu2le16(prNoiseFloorParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prNoiseFloorParams->u1Mode = Mode;
	prNoiseFloorParams->u1Action = Action;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_NOISE_FLOOR);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32
UniCmdSetNoiseFloorControl(
	struct _RTMP_ADAPTER *pAd,
	UINT16  Tag,
	BOOLEAN  bEnable,
	UINT8  Timeout,
	UINT8  Count,
	UINT8  EventCount
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_NF_INFO_T *prNoiseFloorParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_NOISE_FLOOR_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_NF_INFO_T);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
		"Tag: %d Enable: %d, Timeout: %d, Count: %d, EventCount: %d\n",
		Tag, bEnable, Timeout, Count, EventCount);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_NOISE_FLOOR_MODE_CTRL_T */
	prNoiseFloorParams = (struct UNI_CMD_NF_INFO_T *) pNextHeadBuf;

	prNoiseFloorParams->u2Tag = Tag;
	prNoiseFloorParams->u2Length = sizeof(*prNoiseFloorParams);
#ifdef CFG_BIG_ENDIAN
	prNoiseFloorParams->u2Tag = cpu2le16(prNoiseFloorParams->u2Tag);
	prNoiseFloorParams->u2Length = cpu2le16(prNoiseFloorParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prNoiseFloorParams->fgEnable = bEnable;
	prNoiseFloorParams->u1TimeOut = Timeout;
	prNoiseFloorParams->u1Count = Count;
	prNoiseFloorParams->u1EventCount = EventCount;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_NOISE_FLOOR);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}


/*****************************************
 * Command ID: UNI_CMD_ID_CAL 04C
 *****************************************/
INT32
UniCmdSetCalMode(
	struct _RTMP_ADAPTER *pAd,
	UINT8  Mode,
	UINT8  Action
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8  *pTempBuf = NULL;
	UINT8  *pNextHeadBuf = NULL;
	struct UNI_CMD_CAL_MODE_CTRL_T *prCalParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_CAL_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prCalParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
		"Mode: %d, Action: %d\n",
		Mode, Action);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_CAL_MODE_CTRL_T */
	prCalParams = (struct UNI_CMD_CAL_MODE_CTRL_T *) pNextHeadBuf;

	prCalParams->u2Tag = Mode;
	prCalParams->u2Length = sizeof(*prCalParams);
#ifdef CFG_BIG_ENDIAN
	prCalParams->u2Tag = cpu2le16(prCalParams->u2Tag);
	prCalParams->u2Length = cpu2le16(prCalParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prCalParams->u1Mode = Mode;
	prCalParams->u1Action = Action;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CAL);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}

#ifdef CONFIG_AP_SUPPORT
/*****************************************
 * UNI_CMD_ID_VOW (Tag 0x37)
 *****************************************/
/* UNI_CMD_VOW_DRR_CTRL (TAG 0x00): for station DWRR configration */
INT32 uni_cmd_vow_set_sta(PRTMP_ADAPTER pad, UINT16 sta_id, UINT32 subcmd)
{
	UINT32 Setting = 0;
	INT32 ret = 0;
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_DRR_CTRL_T pVowDrrCtrl = &(VOWParam.VowDrrCtrl);
	struct wifi_dev *wdev = NULL;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	pVowDrrCtrl->u4CtrlFieldID = subcmd;
	pVowDrrCtrl->u2StaID = sta_id;

	pVowDrrCtrl->u1BandIdx = hc_get_hw_band_idx(pad);

	wdev = uni_cmd_wdev_band_by_ad(pad);
	if (wdev && wdev->pHObj) {
		pVowDrrCtrl->u1WmmSet = HcGetWmmIdx(pad, wdev);
		pVowDrrCtrl->u1OMACIdx = HcGetOmacIdx(pad, wdev);
	}

	switch (subcmd) {
	case ENUM_VOW_DRR_CTRL_FIELD_STA_ALL:
		/* station configuration */
		Setting |= pad->vow_sta_cfg[sta_id].group;
		Setting |= (pad->vow_sta_cfg[sta_id].ac_change_rule << pad->vow_gen.VOW_STA_AC_PRIORITY_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BK] << pad->vow_gen.VOW_STA_WMM_AC0_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BE] << pad->vow_gen.VOW_STA_WMM_AC1_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VI] << pad->vow_gen.VOW_STA_WMM_AC2_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VO] << pad->vow_gen.VOW_STA_WMM_AC3_OFFSET);
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = Setting;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n", subcmd, Setting);
		break;
	case ENUM_VOW_DRR_CTRL_FIELD_STA_EXCLUDE_GROUP:
		/* station configuration */
		Setting |= pad->vow_sta_cfg[sta_id].group;
		Setting |= (pad->vow_sta_cfg[sta_id].ac_change_rule << pad->vow_gen.VOW_STA_AC_PRIORITY_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BK] << pad->vow_gen.VOW_STA_WMM_AC0_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BE] << pad->vow_gen.VOW_STA_WMM_AC1_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VI] << pad->vow_gen.VOW_STA_WMM_AC2_OFFSET);
		Setting |= (pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VO] << pad->vow_gen.VOW_STA_WMM_AC3_OFFSET);
		if (pad->vow_gen.VOW_FEATURE & VOW_FEATURE_BWCG)
			Setting |= ((pad->vow_sta_cfg[sta_id].group + pad->vow_gen.VOW_BWC_GROUP_MIN) << pad->vow_gen.VOW_STA_BWC_GROUP_OFFSET);
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = cpu2le32(Setting);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n", subcmd, Setting);
		break;
	case ENUM_VOW_DRR_CTRL_FIELD_STA_BSS_GROUP:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].group;
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_BWC_GROUP:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].group + pad->vow_gen.VOW_BWC_GROUP_MIN;
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_WMM_ID:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].wmm_idx;
		break;
	case ENUM_VOW_DRR_CTRL_FIELD_STA_PRIORITY:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].ac_change_rule;
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_AC0_QUA_ID:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BK];
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_AC1_QUA_ID:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_BE];
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_AC2_QUA_ID:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VI];
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_AC3_QUA_ID:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].dwrr_quantum[WMM_AC_VO];
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L0:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L1:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L2:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L3:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L4:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L5:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L6:
	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L7:
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_cfg.vow_sta_dwrr_quantum[subcmd - ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L0];
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(SubCmd %x, Value = 0x%x)\n",
			subcmd, pad->vow_cfg.vow_sta_dwrr_quantum[subcmd - ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_L0]);
		break;

	case ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_QUANTUM_ALL: {
		UINT32 i;

		/* station quantum configruation */
		for (i = 0; i < VOW_MAX_STA_DWRR_NUM; i++) {
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(vow_sta_dwrr_quantum[%d] = 0x%x)\n", i, pad->vow_cfg.vow_sta_dwrr_quantum[i]);
			pVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[i] = pad->vow_cfg.vow_sta_dwrr_quantum[i];
		}

		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(SubCmd %x, Value = 0x%x)\n", subcmd, Setting);
	}
	break;

	case ENUM_VOW_DRR_CTRL_FIELD_STA_PAUSE_SETTING: {
		pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_sta_cfg[sta_id].paused;
		MTWF_DBG(NULL, DBG_CAT_AP, CATTX_VOW, DBG_LVL_INFO,
			"(SubCmd %x, Value = 0x%x)\n",
			subcmd, pad->vow_sta_cfg[sta_id].paused);
	}
	break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(No such command = 0x%x)\n", subcmd);
		break;
	}

	VOWParam.VOWTagValid[UNI_CMD_VOW_DRR_CTRL] = TRUE;
	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"(ret = %d), sizeof %zu\n", ret, sizeof(EXT_CMD_VOW_DRR_CTRL_T));
	return ret;
}

/* UNI_CMD_VOW_DRR_CTRL (TAG 0x00): for DWRR max wait time configuration */
INT uni_cmd_vow_set_sta_DWRR_max_time(PRTMP_ADAPTER pad)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_DRR_CTRL_T pVowDrrCtrl = &(VOWParam.VowDrrCtrl);
	INT32 ret;
	struct wifi_dev *wdev = NULL;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	pVowDrrCtrl->u1BandIdx = hc_get_hw_band_idx(pad);
	wdev = uni_cmd_wdev_band_by_ad(pad);
	if (wdev && wdev->pHObj) {
		pVowDrrCtrl->u1WmmSet = HcGetWmmIdx(pad, wdev);
		pVowDrrCtrl->u1OMACIdx = HcGetOmacIdx(pad, wdev);
	}

	pVowDrrCtrl->u4CtrlFieldID = ENUM_VOW_DRR_CTRL_FIELD_AIRTIME_DEFICIT_BOUND;
	pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_cfg.sta_max_wait_time;
	MTWF_DBG(NULL, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(sta_max_wait_time = 0x%x)\n", pad->vow_cfg.sta_max_wait_time);

	VOWParam.VOWTagValid[UNI_CMD_VOW_DRR_CTRL] = TRUE;
	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	MTWF_DBG(NULL, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(ret = %d), sizeof %zu\n", ret, sizeof(EXT_CMD_VOW_DRR_CTRL_T));
	return ret;
}

/* UNI_CMD_VOW_DRR_CTRL (TAG 0x00): for dbgmode */
INT uni_cmd_vow_set_drr_dbg(PRTMP_ADAPTER pad, UINT32 dbg_mode)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_DRR_CTRL_T pVowDrrCtrl = &(VOWParam.VowDrrCtrl);
	INT32 ret;
	struct wifi_dev *wdev = NULL;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	pVowDrrCtrl->u1BandIdx = hc_get_hw_band_idx(pad);
	wdev = uni_cmd_wdev_band_by_ad(pad);
	if (wdev && wdev->pHObj) {
		pVowDrrCtrl->u1WmmSet = HcGetWmmIdx(pad, wdev);
		pVowDrrCtrl->u1OMACIdx = HcGetOmacIdx(pad, wdev);
	}

	pVowDrrCtrl->u4CtrlFieldID = ENUM_VOW_DRR_CTRL_FIELD_DBG;
	pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = dbg_mode;

	VOWParam.VOWTagValid[UNI_CMD_VOW_DRR_CTRL] = TRUE;
	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(ret = %d), sizeof %zu\n", ret, sizeof(EXT_CMD_VOW_DRR_CTRL_T));
	return ret;
}

/* UNI_CMD_VOW_DRR_CTRL (TAG 0x00): for DWRR max wait time configuration */
INT uni_cmd_vow_set_group_DWRR_max_time(PRTMP_ADAPTER pad)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_DRR_CTRL_T pVowDrrCtrl = &(VOWParam.VowDrrCtrl);
	INT32 ret;
	struct wifi_dev *wdev = NULL;

	if (!(pad->vow_gen.VOW_FEATURE & VOW_FEATURE_BWCTRL))
		return 0;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	pVowDrrCtrl->u1BandIdx = hc_get_hw_band_idx(pad);
	wdev = uni_cmd_wdev_band_by_ad(pad);
	if (wdev && wdev->pHObj) {
		pVowDrrCtrl->u1WmmSet = HcGetWmmIdx(pad, wdev);
		pVowDrrCtrl->u1OMACIdx = HcGetOmacIdx(pad, wdev);
	}

	pVowDrrCtrl->u4CtrlFieldID = ENUM_VOW_DRR_CTRL_FIELD_BW_DEFICIT_BOUND;
	pVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = pad->vow_cfg.group_max_wait_time;
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group_max_wait_time = 0x%x)\n",
			pad->vow_cfg.group_max_wait_time);

	VOWParam.VOWTagValid[UNI_CMD_VOW_DRR_CTRL] = TRUE;
	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);

	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(ret = %d), sizeof %zu\n", ret, sizeof(EXT_CMD_VOW_DRR_CTRL_T));

	return ret;
}

/*
* Unified command UNI_CMD_VOW_DRR_CTRL (TAG 0x00) handler
*/
static INT32 UniCmdVowDrrCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_DRR_CTRL_T pUniCmdVowDrrCtrl = (P_UNI_CMD_VOW_DRR_CTRL_T)pHandle;
	P_UNI_CMD_VOW_DRR_CTRL_T pUniCmdVowDrrCtrlParam = &(pVowParam->VowDrrCtrl);

	memcpy(pUniCmdVowDrrCtrl, pUniCmdVowDrrCtrlParam, sizeof(UNI_CMD_VOW_DRR_CTRL_T));

	/* Fill TLV format */
	pUniCmdVowDrrCtrl->u2Tag = cpu2le16(UNI_CMD_VOW_DRR_CTRL);
	pUniCmdVowDrrCtrl->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_DRR_CTRL_T));

	pUniCmdVowDrrCtrl->u2StaID = cpu2le16(pUniCmdVowDrrCtrl->u2StaID);
	pUniCmdVowDrrCtrl->u4CtrlFieldID = cpu2le32(pUniCmdVowDrrCtrl->u4CtrlFieldID);
	pUniCmdVowDrrCtrl->rAirTimeCtrlValue.u4ComValue = cpu2le32(pUniCmdVowDrrCtrl->rAirTimeCtrlValue.u4ComValue);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, u2StaID=%d, u4CtrlFieldID=%d, u4ComValue=%d, aucAirTimeQuantum=%d-%d-%d-%d-%d-%d-%d-%d\n",
		le2cpu16(pUniCmdVowDrrCtrl->u2Tag), le2cpu16(pUniCmdVowDrrCtrl->u2Length),
		le2cpu16(pUniCmdVowDrrCtrl->u2StaID), le2cpu32(pUniCmdVowDrrCtrl->u4CtrlFieldID),
		le2cpu32(pUniCmdVowDrrCtrl->rAirTimeCtrlValue.u4ComValue),
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[0],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[1],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[2],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[3],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[4],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[5],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[6],
		pUniCmdVowDrrCtrl->rAirTimeCtrlValue.rAirTimeQuantumAllField.aucAirTimeQuantum[7]);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_DRR_CTRL_T);
	return Ret;

}

/* UNI_CMD_VOW_FEATURE_CTRL (TAG 0x01): for group configuration */
INT uni_cmd_vow_set_feature_all(PRTMP_ADAPTER pad)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_FEATURE_CTRL_T pVowFeatureCtrl = &(VOWParam.VowFeatureCtrl);
	INT32 ret, i;
	UINT_8 band_idx;
	struct physical_device *ph_dev = pad->physical_dev;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	/* DW0 - flags */
	pVowFeatureCtrl->u1BandIdx = hc_get_hw_band_idx(pad);
	pVowFeatureCtrl->u2IfApplyBss_0_to_16_CtrlFlag = 0xFFFF; /* 16'b */
	pVowFeatureCtrl->u2IfApplyRefillPerildFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyDbdc1SearchRuleFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyDbdc0SearchRuleFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyEnTxopNoChangeBssFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyAirTimeFairnessFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyWeightedAirTimeFairnessFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyEnbwrefillFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u2IfApplyEnbwCtrlFlag = TRUE; /* 1'b */
	pVowFeatureCtrl->u4IfApplyKeepQuantumFlag = TRUE; /* 1'b */
	/* DW1 - flags */
	pVowFeatureCtrl->u2IfApplyBssCheckTimeToken_0_to_16_CtrlFlag = 0xFFFF;
	/* DW2 - flags */
	pVowFeatureCtrl->u2IfApplyBssCheckLengthToken_0_to_16_CtrlFlag = 0xFFFF;
	/* DW5 - ctrl values */
	pVowFeatureCtrl->u2Bss_0_to_16_CtrlValue = pad->vow_cfg.per_bss_enable; /* 16'b */
	pVowFeatureCtrl->u2RefillPerildValue = pad->vow_cfg.refill_period; /* 8'b */
	pVowFeatureCtrl->u2Dbdc1SearchRuleValue = pad->vow_cfg.dbdc1_search_rule; /* 1'b */
	pVowFeatureCtrl->u2Dbdc0SearchRuleValue = pad->vow_cfg.dbdc0_search_rule; /* 1'b */
	pVowFeatureCtrl->u2WeightedAirTimeFairnessValue = pad->vow_watf_en; /* 1'b */
	pVowFeatureCtrl->u2EnTxopNoChangeBssValue = pad->vow_cfg.en_txop_no_change_bss; /* 1'b */
	pVowFeatureCtrl->u2AirTimeFairnessValue = pad->vow_cfg.en_airtime_fairness; /* 1'b */
	pVowFeatureCtrl->u2EnbwrefillValue = pad->vow_cfg.en_bw_refill; /* 1'b */

	if (ph_dev->bw_en_mask)
		pVowFeatureCtrl->u2EnbwCtrlValue = 1; /* 1'b */
	else
		pVowFeatureCtrl->u2EnbwCtrlValue = pad->vow_cfg.en_bw_ctrl; /* 1'b */

	pVowFeatureCtrl->u4KeepQuantumValue = pad->vow_misc_cfg.keep_quantum; /* 1'b */

	band_idx = hc_get_hw_band_idx(pad);

	if (band_idx < CFG_WIFI_RAM_BAND_NUM) {

		ph_dev->bw_group_at_on_mask[band_idx] = 0;
		ph_dev->bw_group_bw_on_mask[band_idx] = 0;

		for (i = 0; i < VOW_MAX_GROUP_NUM; i++)
			ph_dev->bw_group_at_on_mask[band_idx] |= (pad->vow_bss_cfg[i].at_on << i);

		for (i = 0; i < VOW_MAX_GROUP_NUM; i++)
			ph_dev->bw_group_bw_on_mask[band_idx] |= (pad->vow_bss_cfg[i].bw_on << i);
	}

	for (i = 0; i < CFG_WIFI_RAM_BAND_NUM; i++)
		pVowFeatureCtrl->u2BssCheckTimeToken_0_to_16_CtrlValue |= ph_dev->bw_group_at_on_mask[i];

	for (i = 0; i < CFG_WIFI_RAM_BAND_NUM; i++)
		pVowFeatureCtrl->u2BssCheckLengthToken_0_to_16_CtrlValue |= ph_dev->bw_group_bw_on_mask[i];

	/* DW6 - ctrl values */
	for (i = 0; i < VOW_MAX_GROUP_NUM; i++)
		pVowFeatureCtrl->u2BssCheckTimeToken_0_to_16_CtrlValue |= (pad->vow_bss_cfg[i].at_on << i);

	/* DW7 - ctrl values */
	for (i = 0; i < VOW_MAX_GROUP_NUM; i++)
		pVowFeatureCtrl->u2BssCheckLengthToken_0_to_16_CtrlValue |= (pad->vow_bss_cfg[i].bw_on << i);

	if ((!pad->vow_cfg.en_bw_ctrl) && ph_dev->bw_en_mask) {
		pVowFeatureCtrl->u2IfApplyBss_0_to_16_CtrlFlag = 0;
		pVowFeatureCtrl->u2IfApplyBssCheckTimeToken_0_to_16_CtrlFlag = 0;
		pVowFeatureCtrl->u2IfApplyBssCheckLengthToken_0_to_16_CtrlFlag = 0;
	}

	if ((pad->vow_gen.VOW_GEN == VOW_GEN_2) ||
		(pad->vow_gen.VOW_GEN == VOW_GEN_TALOS) ||
		(pad->vow_gen.VOW_GEN >= VOW_GEN_FALCON)) {
		/* DW8 - misc */
		pVowFeatureCtrl->u4IfApplyStaLockForRtsFlag = TRUE; /* 1'b */
		pVowFeatureCtrl->u4RtsStaLockValue = pad->vow_misc_cfg.rts_sta_lock; /* 1'b */
		/* VOW is disabled, skip all setting */
		if (vow_is_enabled(pad)) {
			pVowFeatureCtrl->u4IfApplyTxCountModeFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4TxCountValue = pad->vow_misc_cfg.tx_rr_count; /* 4'b */
			pVowFeatureCtrl->u4IfApplyTxMeasurementModeFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4TxMeasurementModeValue = pad->vow_misc_cfg.measurement_mode; /* 1'b */
			pVowFeatureCtrl->u4IfApplyTxBackOffBoundFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4TxBackOffBoundEnable = pad->vow_misc_cfg.max_backoff_bound_en; /* 1'b */
			pVowFeatureCtrl->u4TxBackOffBoundValue = pad->vow_misc_cfg.max_backoff_bound; /* 4'b */
			pVowFeatureCtrl->u4IfApplyRtsFailedChargeDisFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4RtsFailedChargeDisValue = pad->vow_misc_cfg.rts_failed_charge_time_en; /* 1'b */
			pVowFeatureCtrl->u4IfApplyRxEifsToZeroFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4ApplyRxEifsToZeroValue = pad->vow_misc_cfg.zero_eifs_time; /* 1'b */
			pVowFeatureCtrl->u4IfApplyRxRifsModeforCckCtsFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4RxRifsModeforCckCtsValue = pad->vow_misc_cfg.rx_rifs_mode; /* 1'b */
			pVowFeatureCtrl->u4IfApplyKeepVoWSettingForSerFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4VowKeepSettingValue = pad->vow_misc_cfg.keep_vow_sram_setting; /* 1'b */
			pVowFeatureCtrl->u4VowKeepSettingBit = pad->vow_misc_cfg.keep_vow_sram_setting_bit; /* 1'b */
			if (pad->vow_gen.VOW_GEN < VOW_GEN_FALCON) {
				pVowFeatureCtrl->u4IfApplySplFlag = TRUE; /* 1'b */
				pVowFeatureCtrl->u4SplStaNumValue = pad->vow_misc_cfg.spl_sta_count; /* 3'b */
			}
		}
	}

	pVowFeatureCtrl->u4DbgPrnLvl = (pad->vow_show_en == 0) ? 0 : (pad->vow_show_en - 1);

	/* DW9 - schedule */
	pVowFeatureCtrl->u4IfApplyVowSchCtrl = pad->vow_sch_cfg.apply_sch_ctrl;
	pVowFeatureCtrl->u4VowScheduleType = pad->vow_sch_cfg.sch_type;
	pVowFeatureCtrl->u4VowSchedulePolicy = pad->vow_sch_cfg.sch_policy;

	if (pad->vow_gen.VOW_GEN >= VOW_GEN_FALCON) {
		if (vow_is_enabled(pad)) {
			pVowFeatureCtrl->u4IfApplyRxEifsToZeroFlag = TRUE; /* 1'b */
			pVowFeatureCtrl->u4ApplyRxEifsToZeroValue = pad->vow_misc_cfg.zero_eifs_time; /* 1'b */
		}
	}

	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2Bss_0_to_16_CtrlValue	= 0x%x)\n",
			pad->vow_cfg.per_bss_enable);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2RefillPerildValue = 0x%x)\n", pad->vow_cfg.refill_period);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2Dbdc1SearchRuleValue = 0x%x)\n",
			pad->vow_cfg.dbdc1_search_rule);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2Dbdc0SearchRuleValue = 0x%x)\n",
			pad->vow_cfg.dbdc0_search_rule);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2EnTxopNoChangeBssValue = 0x%x)\n",
			pad->vow_cfg.en_txop_no_change_bss);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2AirTimeFairnessValue = 0x%x)\n",
			pad->vow_cfg.en_airtime_fairness);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2EnbwrefillValue = 0x%x)\n", pad->vow_cfg.en_bw_refill);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2EnbwCtrlValue = 0x%x)\n", pad->vow_cfg.en_bw_ctrl);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2WeightedAirTimeFairnessValue = 0x%x)\n", pad->vow_watf_en);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2BssCheckTimeToken_0_to_16_CtrlValue = 0x%x)\n",
			pVowFeatureCtrl->u2BssCheckTimeToken_0_to_16_CtrlValue);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(u2BssCheckLengthToken_0_to_16_CtrlValue = 0x%x)\n",
			pVowFeatureCtrl->u2BssCheckLengthToken_0_to_16_CtrlValue);

	VOWParam.VOWTagValid[UNI_CMD_VOW_FEATURE_CTRL] = TRUE;
	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(ret = %d), sizeof %zu\n",
			ret, sizeof(EXT_CMD_VOW_FEATURE_CTRL_T));
	return ret;
}

/*
* Unified command UNI_CMD_VOW_FEATURE_CTRL (TAG 0x01) handler
*/
static INT32 UniCmdVowFeatureCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_FEATURE_CTRL_T pUniCmdVowFeatureCtrl = (P_UNI_CMD_VOW_FEATURE_CTRL_T)pHandle;
	P_UNI_CMD_VOW_FEATURE_CTRL_T pVowFeatureCtrlParam = &(pVowParam->VowFeatureCtrl);

	memcpy(pUniCmdVowFeatureCtrl, pVowFeatureCtrlParam, sizeof(UNI_CMD_VOW_FEATURE_CTRL_T));

	/* Fill TLV format */
	pUniCmdVowFeatureCtrl->u2Tag = cpu2le16(UNI_CMD_VOW_FEATURE_CTRL);
	pUniCmdVowFeatureCtrl->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_FEATURE_CTRL_T));

	pUniCmdVowFeatureCtrl->u2IfApplyBss_0_to_16_CtrlFlag = cpu2le16(pVowFeatureCtrlParam->u2IfApplyBss_0_to_16_CtrlFlag);
	pUniCmdVowFeatureCtrl->u2IfApplyBssCheckTimeToken_0_to_16_CtrlFlag = cpu2le16(pVowFeatureCtrlParam->u2IfApplyBssCheckTimeToken_0_to_16_CtrlFlag);
	pUniCmdVowFeatureCtrl->u2IfApplyBssCheckLengthToken_0_to_16_CtrlFlag = cpu2le16(pVowFeatureCtrlParam->u2IfApplyBssCheckLengthToken_0_to_16_CtrlFlag);
	pUniCmdVowFeatureCtrl->u2Bss_0_to_16_CtrlValue = cpu2le16(pVowFeatureCtrlParam->u2Bss_0_to_16_CtrlValue);
	pUniCmdVowFeatureCtrl->u2BssCheckTimeToken_0_to_16_CtrlValue = cpu2le16(pVowFeatureCtrlParam->u2BssCheckTimeToken_0_to_16_CtrlValue);
	pUniCmdVowFeatureCtrl->u2BssCheckLengthToken_0_to_16_CtrlValue = cpu2le16(pVowFeatureCtrlParam->u2BssCheckLengthToken_0_to_16_CtrlValue);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d\n",
		le2cpu16(pUniCmdVowFeatureCtrl->u2Tag), le2cpu16(pUniCmdVowFeatureCtrl->u2Length));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_FEATURE_CTRL_T);
	return Ret;

}

/* TAG 02-06: for group configuration */
INT uni_cmd_vow_set_group(PRTMP_ADAPTER pad, UINT8 group_id, UINT32 subcmd)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T pVowBssgroupCtrl1Group = &(VOWParam.VowBssgroupCtrl1Group);
	P_UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T pVowBssgroupTokenCfg = &(VOWParam.VowBssgroupTokenCfg);
	P_UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T pVowBssgroupCtrlAllGroup = &(VOWParam.VowBssgroupCtrlAllGroup);
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T pVowBssgroupBWGroupQuantum = &(VOWParam.VowBssgroupBWGroupQuantum);
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T pVowBssgroupBWGroupQuantumAll = &(VOWParam.VowBssgroupBWGroupQuantumAll);
	INT32 ret;
	UINT_8 u1BandIdx = 0;

	if (!pad) {
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_ERROR,
				"error! pAd is NULL!\n");
		return NDIS_STATUS_INVALID_DATA;
	}
	u1BandIdx = hc_get_hw_band_idx(pad);
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	pVowBssgroupCtrl1Group->u1BandIdx = u1BandIdx;
	pVowBssgroupCtrlAllGroup->u1BandIdx = u1BandIdx;
	pVowBssgroupTokenCfg->u1BandIdx = u1BandIdx;

	/* TAG 3 */
	pVowBssgroupTokenCfg->u4CfgItemId = subcmd;
	pVowBssgroupTokenCfg->ucBssGroupID = group_id;

	switch (subcmd) {
	/* group configuration */
	case ENUM_BSSGROUP_CTRL_ALL_ITEM_FOR_1_GROUP:
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP] = TRUE;
		pVowBssgroupCtrl1Group->ucBssGroupID = group_id;
		/* DW0 */
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u2MinRateToken = pad->vow_bss_cfg[group_id].min_rate_token;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u2MaxRateToken = pad->vow_bss_cfg[group_id].max_rate_token;
		/* DW1 */
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MinTokenBucketTimeSize = pad->vow_bss_cfg[group_id].min_airtimebucket_size;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MinAirTimeToken = pad->vow_bss_cfg[group_id].min_airtime_token;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MinTokenBucketLengSize = pad->vow_bss_cfg[group_id].min_ratebucket_size;
		/* DW2 */
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MaxTokenBucketTimeSize = pad->vow_bss_cfg[group_id].max_airtimebucket_size;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MaxAirTimeToken = pad->vow_bss_cfg[group_id].max_airtime_token;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MaxTokenBucketLengSize = pad->vow_bss_cfg[group_id].max_ratebucket_size;
		/* DW3 */
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MaxWaitTime = pad->vow_bss_cfg[group_id].max_wait_time;
		pVowBssgroupCtrl1Group->rAllBssGroupMultiField.u4MaxBacklogSize = pad->vow_bss_cfg[group_id].max_backlog_size;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(Group id = 0x%x, min_rate %d, max_rate %d, min_ratio %d, max_ratio %d)\n",
			group_id,
			pad->vow_bss_cfg[group_id].min_rate,
			pad->vow_bss_cfg[group_id].max_rate,
			pad->vow_bss_cfg[group_id].min_airtime_ratio,
			pad->vow_bss_cfg[group_id].max_airtime_ratio);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(min rate token = 0x%x)\n",
				pad->vow_bss_cfg[group_id].min_rate_token);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max rate token = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_rate_token);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(min airtime token = 0x%x)\n",
				pad->vow_bss_cfg[group_id].min_airtime_token);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max airtime token = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_airtime_token);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(min rate bucket = 0x%x)\n",
				pad->vow_bss_cfg[group_id].min_ratebucket_size);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max rate bucket = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_ratebucket_size);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(min airtime bucket = 0x%x)\n",
				pad->vow_bss_cfg[group_id].min_airtimebucket_size);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max airtime bucket = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_airtimebucket_size);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max baclog size = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_backlog_size);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(max wait time = 0x%x)\n",
				pad->vow_bss_cfg[group_id].max_wait_time);
		break;

	case ENUM_BSSGROUP_CTRL_MIN_RATE_TOKEN_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].min_rate_token;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_RATE_TOKEN_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_rate_token;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MIN_TOKEN_BUCKET_TIME_SIZE_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].min_airtimebucket_size;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MIN_AIRTIME_TOKEN_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].min_airtime_token;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MIN_TOKEN_BUCKET_LENG_SIZE_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].min_ratebucket_size;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_TOKEN_BUCKET_TIME_SIZE_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_airtimebucket_size;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_AIRTIME_TOKEN_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_airtime_token;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_TOKEN_BUCKET_LENG_SIZE_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_ratebucket_size;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_WAIT_TIME_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_wait_time;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_MAX_BACKLOG_SIZE_CFG_ITEM:
		pVowBssgroupTokenCfg->u4SingleFieldIDValue = pad->vow_bss_cfg[group_id].max_backlog_size;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_TOKEN_CFG] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(SubCmd %x, Value = 0x%x)\n",
				subcmd, pVowBssgroupTokenCfg->u4SingleFieldIDValue);
		break;

	case ENUM_BSSGROUP_CTRL_ALL_ITEM_FOR_ALL_GROUP: {
		UINT32 i;

		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP] = TRUE;
		for (i = 0; i < VOW_MAX_GROUP_NUM; i++) {
			/* DW0 */
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u2MinRateToken = pad->vow_bss_cfg[i].min_rate_token;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u2MaxRateToken = pad->vow_bss_cfg[i].max_rate_token;
			/* DW1 */
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MinTokenBucketTimeSize = pad->vow_bss_cfg[i].min_airtimebucket_size;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MinAirTimeToken = pad->vow_bss_cfg[i].min_airtime_token;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MinTokenBucketLengSize = pad->vow_bss_cfg[i].min_ratebucket_size;
			/* DW2 */
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MaxTokenBucketTimeSize = pad->vow_bss_cfg[i].max_airtimebucket_size;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MaxAirTimeToken = pad->vow_bss_cfg[i].max_airtime_token;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MaxTokenBucketLengSize = pad->vow_bss_cfg[i].max_ratebucket_size;
			/* DW3 */
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MaxWaitTime = pad->vow_bss_cfg[i].max_wait_time;
			pVowBssgroupCtrlAllGroup->arAllBssGroupMultiField[i].u4MaxBacklogSize = pad->vow_bss_cfg[i].max_backlog_size;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(Group id = 0x%x, min_rate %d, max_rate %d, min_ratio %d, max_ratio %d)\n",
				i,
				pad->vow_bss_cfg[i].min_rate,
				pad->vow_bss_cfg[i].max_rate,
				pad->vow_bss_cfg[i].min_airtime_ratio,
				pad->vow_bss_cfg[i].max_airtime_ratio);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(min rate token = 0x%x)\n",
					pad->vow_bss_cfg[i].min_rate_token);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max rate token = 0x%x)\n",
					pad->vow_bss_cfg[i].max_rate_token);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(min airtime token = 0x%x)\n",
					pad->vow_bss_cfg[i].min_airtime_token);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max airtime token = 0x%x)\n",
					pad->vow_bss_cfg[i].max_airtime_token);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(min rate bucket = 0x%x)\n",
					pad->vow_bss_cfg[i].min_ratebucket_size);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max rate bucket = 0x%x)\n",
					pad->vow_bss_cfg[i].max_ratebucket_size);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(min airtime bucket = 0x%x)\n",
					pad->vow_bss_cfg[i].min_airtimebucket_size);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max airtime bucket = 0x%x)\n",
					pad->vow_bss_cfg[i].max_airtimebucket_size);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max baclog size = 0x%x)\n",
					pad->vow_bss_cfg[i].max_backlog_size);
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(max wait time = 0x%x)\n",
					pad->vow_bss_cfg[i].max_wait_time);
		}
	}
	break;

	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_00:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_01:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_02:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_03:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_04:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_05:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_06:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_07:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_08:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_09:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0A:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0B:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0C:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0D:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0E:
	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_0F:
		pVowBssgroupBWGroupQuantum->ucBssGroupQuantumID = group_id - ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_L_00;
		pVowBssgroupBWGroupQuantum->ucBssGroupQuantumTime = pad->vow_bss_cfg[group_id].dwrr_quantum;
		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM] = TRUE;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(group %d DWRR quantum = 0x%x)\n",
				group_id, pad->vow_bss_cfg[group_id].dwrr_quantum);
		break;

	case ENUM_BSSGROUP_CTRL_BW_GROUP_QUANTUM_ALL: {
		UINT32 i;

		VOWParam.VOWTagValid[UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL] = TRUE;
		for (i = 0; i < VOW_MAX_GROUP_NUM; i++) {
			pVowBssgroupBWGroupQuantumAll->aucBssGroupQuantumTime[i] = pad->vow_bss_cfg[i].dwrr_quantum;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(group %d DWRR quantum = 0x%x)\n",
					i, pad->vow_bss_cfg[i].dwrr_quantum);
		}
	}
	break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(No such command = 0x%x)\n", subcmd);
		break;
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(ret = %d), sizeof %zu\n", ret, sizeof(EXT_CMD_BSS_CTRL_T));
	return ret;
}

/*
* Unified command UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP (TAG 0x02) handler
*/
static INT32 UniCmdVowBssGroupCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T pUniCmdVowBss = (P_UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T)pHandle;
	P_UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T pParam = &(pVowParam->VowBssgroupCtrl1Group);

	memcpy(pUniCmdVowBss, pParam, sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T));
	/* Fill TLV format */
	pUniCmdVowBss->u2Tag = cpu2le16(UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP);
	pUniCmdVowBss->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T));

	pUniCmdVowBss->rAllBssGroupMultiField.u2MinRateToken = cpu2le16(pUniCmdVowBss->rAllBssGroupMultiField.u2MinRateToken);
	pUniCmdVowBss->rAllBssGroupMultiField.u2MaxRateToken = cpu2le16(pUniCmdVowBss->rAllBssGroupMultiField.u2MaxRateToken);
	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucBssGroupID=%d\n",
		le2cpu16(pUniCmdVowBss->u2Tag), le2cpu16(pUniCmdVowBss->u2Length), pUniCmdVowBss->ucBssGroupID);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_BSSGROUP_CTRL_1_GROUP_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_BSSGROUP_TOKEN_CFG (TAG 0x03) handler
*/
static INT32 UniCmdVowBssGroupTokenCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T pUniCmdVowBss = (P_UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T)pHandle;
	P_UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T pParam = &(pVowParam->VowBssgroupTokenCfg);

	memcpy(pUniCmdVowBss, pParam, sizeof(UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T));
	/* Fill TLV format */
	pUniCmdVowBss->u2Tag = cpu2le16(UNI_CMD_VOW_BSSGROUP_TOKEN_CFG);
	pUniCmdVowBss->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T));

	pUniCmdVowBss->u4SingleFieldIDValue = cpu2le32(pUniCmdVowBss->u4SingleFieldIDValue);
	pUniCmdVowBss->u4CfgItemId = cpu2le32(pUniCmdVowBss->u4CfgItemId);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucBssGroupID=%d, u4SingleFieldIDValue=%d, u4CfgItemId=%d\n",
		le2cpu16(pUniCmdVowBss->u2Tag), le2cpu16(pUniCmdVowBss->u2Length), pUniCmdVowBss->ucBssGroupID,
		le2cpu32(pUniCmdVowBss->u4SingleFieldIDValue), le2cpu32(pUniCmdVowBss->u4CfgItemId));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_BSSGROUP_TOKEN_CFG_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP (TAG 0x04) handler
*/
static INT32 UniCmdVowBssGroupCtrlAllGroup(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS, i = 0;
	P_UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T pUniCmdVowBss = (P_UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T)pHandle;
	P_UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T pParam = &(pVowParam->VowBssgroupCtrlAllGroup);

	memcpy(pUniCmdVowBss, pParam, sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T));
	/* Fill TLV format */
	pUniCmdVowBss->u2Tag = cpu2le16(UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP);
	pUniCmdVowBss->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T));

	for (i = 0; i < UNICMD_VOW_BWC_GROUP_NUMBER; i++) {
		pUniCmdVowBss->arAllBssGroupMultiField[i].u2MinRateToken = cpu2le16(pUniCmdVowBss->arAllBssGroupMultiField[i].u2MinRateToken);
		pUniCmdVowBss->arAllBssGroupMultiField[i].u2MaxRateToken = cpu2le16(pUniCmdVowBss->arAllBssGroupMultiField[i].u2MaxRateToken);
	}

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d\n",
		le2cpu16(pUniCmdVowBss->u2Tag), le2cpu16(pUniCmdVowBss->u2Length));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_BSSGROUP_CTRL_ALL_GROUP_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM (TAG 0x05) handler
*/
static INT32 UniCmdVowBssGroupBwGroupQuantum(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T pUniCmdVowBss = (P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T)pHandle;
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T pParam = &(pVowParam->VowBssgroupBWGroupQuantum);

	memcpy(pUniCmdVowBss, pParam, sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T));
	/* Fill TLV format */
	pUniCmdVowBss->u2Tag = cpu2le16(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM);
	pUniCmdVowBss->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucBssGroupQuantumID=%u, ucBssGroupQuantumTime=%u\n",
		le2cpu16(pUniCmdVowBss->u2Tag), le2cpu16(pUniCmdVowBss->u2Length),
		pUniCmdVowBss->ucBssGroupQuantumID, pUniCmdVowBss->ucBssGroupQuantumTime);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_BSSGROUP_BW_GROUP_QUANTUM_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL (TAG 0x06) handler
*/
static INT32 UniCmdVowBssGroupBwGroupQuantumALL(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T pUniCmdVowBss = (P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T)pHandle;
	P_UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T pParam = &(pVowParam->VowBssgroupBWGroupQuantumAll);

	memcpy(pUniCmdVowBss, pParam, sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T));
	/* Fill TLV format */
	pUniCmdVowBss->u2Tag = cpu2le16(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL);
	pUniCmdVowBss->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d\n",
		le2cpu16(pUniCmdVowBss->u2Tag), le2cpu16(pUniCmdVowBss->u2Length));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T);
	return Ret;

}

/* TAG 07-08: for airtime estimator module */
INT uni_cmd_vow_set_at_estimator(PRTMP_ADAPTER pad, UINT32 subcmd)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_AT_PROC_EST_FEATURE_T pVowATProcEstFeature = &(VOWParam.VowATProcEstFeature);
	P_UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T pVowATProcEstMonitorPeriod = &(VOWParam.VowATProcEstMonitorPeriod);
	INT32 ret;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	switch (subcmd) {
	case ENUM_AT_PROC_EST_FEATURE_CTRL:
		pVowATProcEstFeature->fgAtEstimateOnOff = pad->vow_at_est.at_estimator_en;
		VOWParam.VOWTagValid[UNI_CMD_VOW_AT_PROC_EST_FEATURE] = TRUE;
		break;

	case ENUM_AT_PROC_EST_MONITOR_PERIOD_CTRL:
		pVowATProcEstMonitorPeriod->u2AtEstMonitorPeriod = pad->vow_at_est.at_monitor_period;
		VOWParam.VOWTagValid[UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD] = TRUE;
		break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(No such command = 0x%x)\n", subcmd);
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/*
* Unified command UNI_CMD_VOW_AT_PROC_EST_FEATURE (TAG 0x07) handler
*/
static INT32 UniCmdVowATProcEstFeature(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_AT_PROC_EST_FEATURE_T pUniCmdVowATProc = (P_UNI_CMD_VOW_AT_PROC_EST_FEATURE_T)pHandle;
	P_UNI_CMD_VOW_AT_PROC_EST_FEATURE_T pParam = &(pVowParam->VowATProcEstFeature);

	memcpy(pUniCmdVowATProc, pParam, sizeof(UNI_CMD_VOW_AT_PROC_EST_FEATURE_T));
	/* Fill TLV format */
	pUniCmdVowATProc->u2Tag = cpu2le16(UNI_CMD_VOW_AT_PROC_EST_FEATURE);
	pUniCmdVowATProc->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_AT_PROC_EST_FEATURE_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, fgAtEstimateOnOff=%d\n",
		le2cpu16(pUniCmdVowATProc->u2Tag), le2cpu16(pUniCmdVowATProc->u2Length), pUniCmdVowATProc->fgAtEstimateOnOff);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_AT_PROC_EST_FEATURE_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD (TAG 0x08) handler
*/
static INT32 UniCmdVowATProcEstMonitorPeriod(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T pUniCmdVowATProc = (P_UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T)pHandle;
	P_UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T pParam = &(pVowParam->VowATProcEstMonitorPeriod);

	memcpy(pUniCmdVowATProc, pParam, sizeof(UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T));
	/* Fill TLV format */
	pUniCmdVowATProc->u2Tag = cpu2le16(UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD);
	pUniCmdVowATProc->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T));
	pUniCmdVowATProc->u2AtEstMonitorPeriod = cpu2le16(pUniCmdVowATProc->u2AtEstMonitorPeriod);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, u2AtEstMonitorPeriod=%d\n",
		le2cpu16(pUniCmdVowATProc->u2Tag), le2cpu16(pUniCmdVowATProc->u2Length), le2cpu16(pUniCmdVowATProc->u2AtEstMonitorPeriod));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_AT_PROC_EST_MONITOR_PERIOD_T);
	return Ret;

}

/* TAG 09-0A */
INT uni_cmd_vow_set_at_estimator_group(PRTMP_ADAPTER pad, UINT32 subcmd, UINT8 group_id)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T pVowATProcEstGroupRatio = &(VOWParam.VowATProcEstGroupRatio);
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T pVowATProcEstGroupToBandMapping = &(VOWParam.VowATProcEstGroupToBandMapping);
	INT32 ret;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	switch (subcmd) {
	case ENUM_AT_PROC_EST_GROUP_RATIO_CTRL:
		VOWParam.VOWTagValid[UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO] = TRUE;
		pVowATProcEstGroupRatio->u4GroupRatioBitMask |= (1UL << group_id);
		pVowATProcEstGroupRatio->u2GroupMaxRatioValue[group_id] = pad->vow_bss_cfg[group_id].max_airtime_ratio;
		pVowATProcEstGroupRatio->u2GroupMinRatioValue[group_id] = pad->vow_bss_cfg[group_id].min_airtime_ratio;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group %d, val = 0x%x/0x%x)\n",
			group_id,
			pad->vow_bss_cfg[group_id].max_airtime_ratio,
			pad->vow_bss_cfg[group_id].min_airtime_ratio);
		break;

	case ENUM_AT_PROC_EST_GROUP_TO_BAND_MAPPING:
		VOWParam.VOWTagValid[UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING] = TRUE;
		pVowATProcEstGroupToBandMapping->ucGrouptoSelectBand = group_id;
		pVowATProcEstGroupToBandMapping->ucBandSelectedfromGroup = pad->vow_bss_cfg[group_id].band_idx;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(group %d, val = 0x%x)\n",
				 group_id, pad->vow_bss_cfg[group_id].band_idx);
		break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(No such command = 0x%x)\n", subcmd);
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/*
* Unified command UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING (TAG 0x09) handler
*/
static INT32 UniCmdVowATProcEstGroupRatio(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS, i = 0;
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T pUniCmdVowATProc = (P_UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T)pHandle;
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T pParam = &(pVowParam->VowATProcEstGroupRatio);

	memcpy(pUniCmdVowATProc, pParam, sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T));
	/* Fill TLV format */
	pUniCmdVowATProc->u2Tag = cpu2le16(UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO);
	pUniCmdVowATProc->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T));
	pUniCmdVowATProc->u4GroupRatioBitMask = cpu2le16(pUniCmdVowATProc->u4GroupRatioBitMask);
	for (i = 0; i < UNICMD_VOW_BWC_GROUP_NUMBER; i++) {
		pUniCmdVowATProc->u2GroupMaxRatioValue[i] = cpu2le16(pUniCmdVowATProc->u2GroupMaxRatioValue[i]);
		pUniCmdVowATProc->u2GroupMinRatioValue[i] = cpu2le16(pUniCmdVowATProc->u2GroupMinRatioValue[i]);
	}

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, u4GroupRatioBitMask=%d\n",
		le2cpu16(pUniCmdVowATProc->u2Tag), le2cpu16(pUniCmdVowATProc->u2Length), le2cpu32(pUniCmdVowATProc->u4GroupRatioBitMask));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_AT_PROC_EST_GROUP_RATIO_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING (TAG 0x0A) handler
*/
static INT32 UniCmdVowATProcEstGroupToBandMapping(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T pUniCmdVowATProc = (P_UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T)pHandle;
	P_UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T pParam = &(pVowParam->VowATProcEstGroupToBandMapping);

	memcpy(pUniCmdVowATProc, pParam, sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T));
	/* Fill TLV format */
	pUniCmdVowATProc->u2Tag = cpu2le16(UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING);
	pUniCmdVowATProc->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucGrouptoSelectBand=%d, ucBandSelectedfromGroup=%d\n",
		le2cpu16(pUniCmdVowATProc->u2Tag), le2cpu16(pUniCmdVowATProc->u2Length),
		pUniCmdVowATProc->ucGrouptoSelectBand, pUniCmdVowATProc->ucBandSelectedfromGroup);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T);
	return Ret;

}

/* Tag B, D, E, 11 */
INT uni_cmd_vow_set_rx_airtime(PRTMP_ADAPTER pad, UINT8 cmd, UINT32 subcmd)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_RX_AT_AIRTIME_EN_T pVowRxAtAirtimeEn = &(VOWParam.VowRxAtAirtimeEn); /* TAG B */
	P_UNI_CMD_VOW_RX_AT_EARLYEND_EN_T pVowRxAtEarlyendEn = &(VOWParam.VowRxAtEarlyendEn); /* TAG D */
	P_UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T pVowRxAtAirtimeClrEn = &(VOWParam.VowRxAtAirtimeClrEn); /* TAG E */
	P_UNI_CMD_VOW_RX_AT_ED_OFFSET_T pVowRxAtEdOffset = &(VOWParam.VowRxAtEdOffset); /* TAG 11 */
	INT32 ret;
	UINT8 u1BandIdx;

	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	u1BandIdx = hc_get_hw_band_idx(pad);
	pVowRxAtAirtimeEn->u1BandIdx = u1BandIdx;
	pVowRxAtAirtimeClrEn->u1BandIdx = u1BandIdx;
	pVowRxAtEdOffset->u1BandIdx = u1BandIdx;

	switch (cmd) {
	/* RX airtime feature control */
	case ENUM_RX_AT_FEATURE_CTRL:
		switch (subcmd) {
		case ENUM_RX_AT_FEATURE_SUB_TYPE_AIRTIME_EN:
			VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_AIRTIME_EN] = TRUE;
			pVowRxAtAirtimeEn->fgRxAirTimeEn = pad->vow_rx_time_cfg.rx_time_en;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(cmd = 0x%x, subcmd = 0x%x, value = 0x%x)\n",
				cmd, subcmd, pad->vow_rx_time_cfg.rx_time_en);
			break;

		case ENUM_RX_AT_FEATURE_SUB_TYPE_MIBTIME_EN:
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(Not implemented yet = 0x%x)\n", subcmd);
			break;

		case ENUM_RX_AT_FEATURE_SUB_TYPE_EARLYEND_EN:
			VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_EARLYEND_EN] = TRUE;
			pVowRxAtEarlyendEn->fgRxEarlyEndEn = pad->vow_rx_time_cfg.rx_early_end_en;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(cmd = 0x%x, subcmd = 0x%x, value = 0x%x)\n",
				cmd, subcmd, pad->vow_rx_time_cfg.rx_early_end_en);
			break;

		default:
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(No such sub command = 0x%x)\n", subcmd);
		}

		break;

	case ENUM_RX_AT_BITWISE_CTRL:
		switch (subcmd) {
		case ENUM_RX_AT_BITWISE_SUB_TYPE_AIRTIME_CLR: /* clear all RX airtime counters */
			VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN] = TRUE;
			pVowRxAtAirtimeClrEn->fgRxAirTimeClrEn = TRUE;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(cmd = 0x%x, subcmd = 0x%x, value = 0x%x)\n",
				cmd, subcmd, pVowRxAtAirtimeClrEn->fgRxAirTimeClrEn);
			break;

		case ENUM_RX_AT_BITWISE_SUB_TYPE_MIBTIME_CLR:
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(Not implemented yet = 0x%x)\n", subcmd);
			break;

		default:
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(No such sub command = 0x%x)\n", subcmd);
		}

		break;

	case ENUM_RX_AT_TIMER_VALUE_CTRL:
		switch (subcmd) {
		case ENUM_RX_AT_TIME_VALUE_SUB_TYPE_ED_OFFSET_CTRL:
			VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_ED_OFFSET] = TRUE;
			pVowRxAtEdOffset->ucEdOffsetValue = pad->vow_rx_time_cfg.ed_offset;
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(cmd = 0x%x, subcmd =  0x%x, value = 0x%x)\n",
				cmd, subcmd, pad->vow_rx_time_cfg.ed_offset);
			break;

		default:
			MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
					"(No such sub command = 0x%x)\n", subcmd);
		}

		break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(No such command = 0x%x)\n", subcmd);
		break;
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/* Tag 0xF: select RX WMM backoff time for 4 OM */
INT uni_cmd_vow_set_wmm_selection(PRTMP_ADAPTER pad, UINT8 om)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T pVowRxAtStaWmmCtrl = &(VOWParam.VowRxAtStaWmmCtrl); /* TAG F */
	INT32 ret;

	/* init structure to zero */
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	pVowRxAtStaWmmCtrl->u1BandIdx = hc_get_hw_band_idx(pad);

	/* assign cmd and subcmd */
	VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_STA_WMM_CTRL] = TRUE;
	pVowRxAtStaWmmCtrl->ucOwnMacID = om;
	pVowRxAtStaWmmCtrl->fgtoApplyWm00to03MibCfg = pad->vow_rx_time_cfg.wmm_backoff_sel[om];
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"(ucOwnMacID=%d, fgtoApplyWm00to03MibCfg=%d)\n",
		pVowRxAtStaWmmCtrl->ucOwnMacID,
		pVowRxAtStaWmmCtrl->fgtoApplyWm00to03MibCfg);

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/* Tag 0x10: set 16 MBSS  mapping to 4 RX backoff time configurations */
INT uni_cmd_vow_set_mbss2wmm_map(PRTMP_ADAPTER pad, UINT8 bss_idx)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T pVowRxAtMbssWmmCtrl = &(VOWParam.VowRxAtMbssWmmCtrl); /* TAG 10 */
	INT32 ret;

	/* init structure to zero */
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	pVowRxAtMbssWmmCtrl->u1BandIdx = hc_get_hw_band_idx(pad);

	/* assign cmd and subcmd */
	VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL] = TRUE;
	pVowRxAtMbssWmmCtrl->ucMbssGroup = bss_idx;
	pVowRxAtMbssWmmCtrl->ucWmmGroup = pad->vow_rx_time_cfg.bssid2wmm_set[bss_idx];
	MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(bss_idx = 0x%x, Map = 0x%x)\n",
			 bss_idx, pad->vow_rx_time_cfg.bssid2wmm_set[bss_idx]);

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/* Tag 0x13: set backoff time for RX*/
INT uni_cmd_vow_set_backoff_time(PRTMP_ADAPTER pad, UINT8 target)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T pVowRxAtBackoffTimer = &(VOWParam.VowRxAtBackoffTimer); /* TAG 13 */
	INT32 ret;

	/* init structure to zero */
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	/* assign cmd and subcmd */
	VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_BACKOFF_TIMER] = TRUE;
	pVowRxAtBackoffTimer->ucRxATBackoffWmmGroupIdx = target;

	pVowRxAtBackoffTimer->u1BandIdx = hc_get_hw_band_idx(pad);

	switch (target) {
	case ENUM_RX_AT_WMM_GROUP_0:
	case ENUM_RX_AT_WMM_GROUP_1:
	case ENUM_RX_AT_WMM_GROUP_2:
	case ENUM_RX_AT_WMM_GROUP_3:
		pVowRxAtBackoffTimer->u2AC0Backoff =
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_BK];
		pVowRxAtBackoffTimer->u2AC1Backoff =
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_BE];
		pVowRxAtBackoffTimer->u2AC2Backoff =
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_VI];
		pVowRxAtBackoffTimer->u2AC3Backoff =
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_VO];
		pVowRxAtBackoffTimer->ucRxAtBackoffAcQMask =
			(ENUM_RX_AT_AC_Q0_MASK_T | ENUM_RX_AT_AC_Q1_MASK_T | ENUM_RX_AT_AC_Q2_MASK_T | ENUM_RX_AT_AC_Q3_MASK_T);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group = 0x%x, BK = 0x%x, BE = 0x%x, VI = 0x%x, VO = 0x%x)\n",
			target,
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_BK],
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_BE],
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_VI],
			pad->vow_rx_time_cfg.wmm_backoff[target][WMM_AC_VO]);
		break;

	case ENUM_RX_AT_WMM_GROUP_PEPEATER:
		pVowRxAtBackoffTimer->u2AC0Backoff =
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_BK];
		pVowRxAtBackoffTimer->u2AC1Backoff =
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_BE];
		pVowRxAtBackoffTimer->u2AC2Backoff =
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_VI];
		pVowRxAtBackoffTimer->u2AC3Backoff =
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_VO];
		pVowRxAtBackoffTimer->ucRxAtBackoffAcQMask =
			(ENUM_RX_AT_AC_Q0_MASK_T | ENUM_RX_AT_AC_Q1_MASK_T | ENUM_RX_AT_AC_Q2_MASK_T | ENUM_RX_AT_AC_Q3_MASK_T);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group = 0x%x, BK = 0x%x, BE = 0x%x, VI = 0x%x, VO = 0x%x)\n",
			target,
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_BK],
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_BE],
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_VI],
			pad->vow_rx_time_cfg.repeater_wmm_backoff[WMM_AC_VO]);
		break;

	case ENUM_RX_AT_WMM_GROUP_STA:
		pVowRxAtBackoffTimer->u2AC0Backoff =
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_BK];
		pVowRxAtBackoffTimer->u2AC1Backoff =
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_BE];
		pVowRxAtBackoffTimer->u2AC2Backoff =
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_VI];
		pVowRxAtBackoffTimer->u2AC3Backoff =
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_VO];
		pVowRxAtBackoffTimer->ucRxAtBackoffAcQMask =
			(ENUM_RX_AT_AC_Q0_MASK_T | ENUM_RX_AT_AC_Q1_MASK_T | ENUM_RX_AT_AC_Q2_MASK_T | ENUM_RX_AT_AC_Q3_MASK_T);
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group = 0x%x, BK = 0x%x, BE = 0x%x, VI = 0x%x, VO = 0x%x)\n",
			target,
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_BK],
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_BE],
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_VI],
			pad->vow_rx_time_cfg.om_wmm_backoff[WMM_AC_VO]);
		break;

	case ENUM_RX_AT_NON_QOS:
		pVowRxAtBackoffTimer->u2AC0Backoff =
			pad->vow_rx_time_cfg.non_qos_backoff;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group = 0x%x, backoff time = 0x%x)\n",
			target, pad->vow_rx_time_cfg.non_qos_backoff);
		break;

	case ENUM_RX_AT_OBSS:
		pVowRxAtBackoffTimer->u2AC0Backoff =
			pad->vow_rx_time_cfg.obss_backoff;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(group = 0x%x, backoff time = 0x%x)\n",
			target, pad->vow_rx_time_cfg.obss_backoff);
		break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO, "(No such command = 0x%x)\n", target);
		break;
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, TRUE, HOST2N9, NULL);
	return ret;
}

/* TAG 14, 15: set backoff time for RX*/
INT uni_cmd_vow_get_rx_time_counter(PRTMP_ADAPTER pad, UINT8 target, UINT8 band_idx)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	UNI_EVENT_VOW_PARAM_T VOWResult;
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T pVowRxAtReportRxNonwifiTime = &(VOWParam.VowRxAtReportRxNonwifiTime); /* CMD TAG 14 */
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T pVowRxAtReportRxObssTime = &(VOWParam.VowRxAtReportRxObssTime); /* CMD TAG 15 */
	P_UNI_EVENT_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T pEventVowRxAtReportRxNonwifiTime = &(VOWResult.EventVowRxAtReportRxNonwifiTime); /* Event TAG 14 */
	P_UNI_EVENT_VOW_RX_AT_REPORT_RX_OBSS_TIME_T pEventVowRxAtReportRxObssTime = &(VOWResult.EventVowRxAtReportRxObssTime); /* Event TAG 15 */
	INT32 ret;

	/* init structure to zero */
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));
	NdisZeroMemory(&VOWResult, sizeof(UNI_EVENT_VOW_PARAM_T));
	/* assign cmd and subcmd */

	switch (target) {
	case ENUM_RX_AT_REPORT_SUB_TYPE_RX_NONWIFI_TIME:
		VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME] = TRUE;
		pVowRxAtReportRxNonwifiTime->ucRxNonWiFiBandIdx = band_idx;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(target = 0x%x, band_idx = 0x%x)\n",
			target, band_idx);
		break;

	case ENUM_RX_AT_REPORT_SUB_TYPE_RX_OBSS_TIME:
		VOWParam.VOWTagValid[UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME] = TRUE;
		pVowRxAtReportRxObssTime->ucRxObssBandIdx = band_idx;
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
			"(target = 0x%x, band_idx = 0x%x)\n",
			target, band_idx);
		break;

	case ENUM_RX_AT_REPORT_SUB_TYPE_MIB_OBSS_TIME:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(Not implemented yet = 0x%x)\n", target);
		break;

	default:
		MTWF_DBG(pad, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
				"(No such command = 0x%x)\n", target);
	}

	ret = UniCmdVOWUpdate(pad, &VOWParam, FALSE, HOST2N9, &VOWResult);

	if (target == ENUM_RX_AT_REPORT_SUB_TYPE_RX_NONWIFI_TIME)
		return pEventVowRxAtReportRxNonwifiTime->u4RxNonWiFiBandTimer;
	else if (target == ENUM_RX_AT_REPORT_SUB_TYPE_RX_OBSS_TIME)
		return pEventVowRxAtReportRxObssTime->u4RxObssBandTimer;
	else
		return -1;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_AIRTIME_EN (TAG 0x0B) handler
*/
static INT32 UniCmdVowRxATAirtimeEn(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_AIRTIME_EN_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_AIRTIME_EN_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_AIRTIME_EN_T pParam = &(pVowParam->VowRxAtAirtimeEn);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_EN_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_AIRTIME_EN);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_EN_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, fgRxAirTimeEn=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->fgRxAirTimeEn);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_AIRTIME_EN_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_RX_AT_MIBTIME_EN (TAG 0x0C) handler
*/
static INT32 UniCmdVowRxATMibtimeEn(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_MIBTIME_EN_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_MIBTIME_EN_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_MIBTIME_EN_T pParam = &(pVowParam->VowRxAtMibtimeEn);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_MIBTIME_EN_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_MIBTIME_EN);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_MIBTIME_EN_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, fgRxMibTimeEn=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->fgRxMibTimeEn);

	return Ret;

}

/*
* Unified command UNI_CMD_VOW_RX_AT_EARLYEND_EN (TAG 0x0D) handler
*/
static INT32 UniCmdVowRxATEarlyendEn(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_EARLYEND_EN_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_EARLYEND_EN_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_EARLYEND_EN_T pParam = &(pVowParam->VowRxAtEarlyendEn);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_EARLYEND_EN_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_EARLYEND_EN);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_EARLYEND_EN_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, fgRxEarlyEndEn=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->fgRxEarlyEndEn);

	return Ret;

}

/*
* Unified command UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN (TAG 0x0E) handler
*/
static INT32 UniCmdVowRxAtAirtimeClrEn(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T pParam = &(pVowParam->VowRxAtAirtimeClrEn);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, fgRxAirTimeClrEn=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->fgRxAirTimeClrEn);

	return Ret;

}

/*
* Unified command UNI_CMD_VOW_RX_AT_STA_WMM_CTRL (TAG 0x0F) handler
*/
static INT32 UniCmdVowRxAtStaWmmCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T pParam = &(pVowParam->VowRxAtStaWmmCtrl);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_STA_WMM_CTRL);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucOwnMacID=%d, fgtoApplyWm00to03MibCfg=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucOwnMacID, pUniCmdVowRxAt->fgtoApplyWm00to03MibCfg);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_STA_WMM_CTRL_T);
	return Ret;

}

/*
* Unified command UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL (TAG 0x10) handler
*/
static INT32 UniCmdVowRxAtMbssWmmCtrl(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T pParam = &(pVowParam->VowRxAtMbssWmmCtrl);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucMbssGroup=%d, ucWmmGroup=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucMbssGroup, pUniCmdVowRxAt->ucWmmGroup);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_MBSS_WMM_CTRL_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_ED_OFFSET (TAG 0x11) handler
*/
static INT32 UniCmdVowRxAtEdOffset(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_ED_OFFSET_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_ED_OFFSET_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_ED_OFFSET_T pParam = &(pVowParam->VowRxAtEdOffset);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_ED_OFFSET_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_ED_OFFSET);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_ED_OFFSET_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucEdOffsetValue=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucEdOffsetValue);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_ED_OFFSET_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_SW_TIMER (TAG 0x12) handler
*/
static INT32 UniCmdVowRxAtSwTimer(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_SW_TIMER_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_SW_TIMER_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_SW_TIMER_T pParam = &(pVowParam->VowRxAtSwTimer);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_SW_TIMER_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_SW_TIMER);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_SW_TIMER_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucCompensateMode=%d, ucRxBand=%d, ucSwCompensateTimeValue=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucCompensateMode, pUniCmdVowRxAt->ucRxBand, pUniCmdVowRxAt->ucSwCompensateTimeValue);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_SW_TIMER_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_BACKOFF_TIMER (TAG 0x13) handler
*/
static INT32 UniCmdVowRxAtBackoffTimer(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T pParam = &(pVowParam->VowRxAtBackoffTimer);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_BACKOFF_TIMER);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T));

	pUniCmdVowRxAt->u2AC0Backoff = cpu2le16(pUniCmdVowRxAt->u2AC0Backoff);
	pUniCmdVowRxAt->u2AC1Backoff = cpu2le16(pUniCmdVowRxAt->u2AC1Backoff);
	pUniCmdVowRxAt->u2AC2Backoff = cpu2le16(pUniCmdVowRxAt->u2AC2Backoff);
	pUniCmdVowRxAt->u2AC3Backoff = cpu2le16(pUniCmdVowRxAt->u2AC3Backoff);
	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ACBackoff=%d-%d-%d-%d, ucRxATBackoffWmmGroupIdx=%d, ucRxAtBackoffAcQMask=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		le2cpu16(pUniCmdVowRxAt->u2AC0Backoff),
		le2cpu16(pUniCmdVowRxAt->u2AC1Backoff),
		le2cpu16(pUniCmdVowRxAt->u2AC2Backoff),
		le2cpu16(pUniCmdVowRxAt->u2AC3Backoff),
		pUniCmdVowRxAt->ucRxATBackoffWmmGroupIdx, pUniCmdVowRxAt->ucRxAtBackoffAcQMask);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_BACKOFF_TIMER_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME (TAG 0x14) handler
*/
static INT32 UniCmdVowRxAtReportRxNonwifiTime(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T pParam = &(pVowParam->VowRxAtReportRxNonwifiTime);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucRxNonWiFiBandIdx=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucRxNonWiFiBandIdx);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME (TAG 0x15) handler
*/
static INT32 UniCmdVowRxAtReportRxObssTime(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T pParam = &(pVowParam->VowRxAtReportRxObssTime);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucRxObssBandIdx=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucRxObssBandIdx);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_REPORT_RX_OBSS_TIME_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME (TAG 0x16) handler
*/
static INT32 UniCmdVowRxAtReportMibObssTime(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T pParam = &(pVowParam->VowRxAtReportMibObssTime);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucRxMibObssBandIdx=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		pUniCmdVowRxAt->ucRxMibObssBandIdx);

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T);
	return Ret;
}

/*
* Unified command UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME (TAG 0x17) handler
*/
static INT32 UniCmdVowRxAtReportPerStaRxTime(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T pUniCmdVowRxAt = (P_UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T)pHandle;
	P_UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T pParam = &(pVowParam->VowRxAtReportPerStaRxTime);

	memcpy(pUniCmdVowRxAt, pParam, sizeof(UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T));
	/* Fill TLV format */
	pUniCmdVowRxAt->u2Tag = cpu2le16(UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME);
	pUniCmdVowRxAt->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T));
	pUniCmdVowRxAt->u2StaId = cpu2le16(pUniCmdVowRxAt->u2StaId);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, u2StaId=%d\n",
		le2cpu16(pUniCmdVowRxAt->u2Tag), le2cpu16(pUniCmdVowRxAt->u2Length),
		le2cpu16(pUniCmdVowRxAt->u2StaId));

	(*u4RespStructSize) += sizeof(UNI_EVENT_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T);
	return Ret;
}

/* TAG 18 */
INT32 UniCmdSetRedEnable(RTMP_ADAPTER *pAd, UINT8 McuDest, UINT32 en)
{
	UNI_CMD_VOW_PARAM_T VOWParam;
	P_UNI_CMD_VOW_RED_ENABLE_T pVowRedEnable = &(VOWParam.VowRedEnable); /* TAG 0x18 */
	UINT8 UniCmdMcuDest;
	UINT ret;
	/* init structure to zero */
	NdisZeroMemory(&VOWParam, sizeof(UNI_CMD_VOW_PARAM_T));

	pVowRedEnable->ucRedEnable = en;
	UniCmdMcuDest = McuDest==HOST2CR4 ? HOST2CR4 : HOST2CR4N9;
	VOWParam.VOWTagValid[UNI_CMD_VOW_RED_ENABLE] = TRUE;
	ret = UniCmdVOWUpdate(pAd, &VOWParam, TRUE, HOST2N9, NULL);

	return ret;
}

/*
* Unified command UNI_CMD_VOW_RED_ENABLE (TAG 0x18) handler
*/
static INT32 UniCmdVowRedEnable(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_VOW_RED_ENABLE_T pUniCmdVowRed = (P_UNI_CMD_VOW_RED_ENABLE_T)pHandle;
	P_UNI_CMD_VOW_RED_ENABLE_T pParam = &(pVowParam->VowRedEnable);

	memcpy(pUniCmdVowRed, pParam, sizeof(UNI_CMD_VOW_RED_ENABLE_T));
	/* Fill TLV format */
	pUniCmdVowRed->u2Tag = cpu2le16(UNI_CMD_VOW_RED_ENABLE);
	pUniCmdVowRed->u2Length = cpu2le16(sizeof(UNI_CMD_VOW_RED_ENABLE_T));

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucRedEnable=%d\n",
		le2cpu16(pUniCmdVowRed->u2Tag), le2cpu16(pUniCmdVowRed->u2Length), pUniCmdVowRed->ucRedEnable);

	return Ret;
}

VOID UniCmdExtEventRedTxReportHandler(RTMP_ADAPTER *pAd, UINT8 *Data, UINT32 Length)
{
	INT32 i;
	UINT32 sta_num = 0;
	P_UNI_PARSE_EXT_EVENT_RED_TX_RPT_T prTxRptEvt;
	P_UNI_PARSE_RED_TX_RPT_T prTxRpt	= NULL;
	UINT32 *staInUseBitmap;
	PMAC_TABLE_ENTRY pEntry = NULL;
	P_UNI_CMD_VOW_PARAM_T pVOWParam;
	P_UNI_CMD_VOW_RED_TX_RPT_T pVowRedTxRpt; /* TAG 0x18: */
	P_UNI_CMD_RED_TX_RPT_T pUniCmdRedTxRpt;
	UINT8 TxRptCount = 0;
	struct _RTMP_ADAPTER *mac_ad;

	prTxRptEvt = (P_UNI_PARSE_EXT_EVENT_RED_TX_RPT_T) Data;
	staInUseBitmap = &prTxRptEvt->staInUseBitmap[0];
	prTxRpt = (P_UNI_PARSE_RED_TX_RPT_T)(Data + sizeof(UNI_PARSE_EXT_EVENT_RED_TX_RPT_T));

	sta_num = prTxRptEvt->wordlen << 5;

	for (i = 1; i < sta_num; i++) {
		UINT32 th;

		if ((staInUseBitmap[i >> RED_INUSE_BITSHIFT] & (1 << (i & RED_INUSE_BITMASK))) == 0)
			continue;

		TxRptCount++;
		pEntry = entry_get(pAd, i);
		if (pEntry && pEntry->wdev &&  IS_ENTRY_CLIENT(pEntry) && pEntry->Sst == SST_ASSOC) {

			mac_ad = pEntry->pAd;

			th = VERIWAVE_5G_PKT_CNT_TH;
			if (wlan_config_get_ch_band(pEntry->wdev) == CMD_CH_BAND_24G)
				th = VERIWAVE_2G_PKT_CNT_TH;

			if ((prTxRpt->u4TCPCnt > th) || (prTxRpt->u4TCPAckCnt > th))
				mac_ad->txop_ctl.multi_tcp_nums++;

#ifdef VOW_SUPPORT
			if (pAd->vow_cfg.mcli_schedule_en) {
				pEntry->mcliTcpCnt += prTxRpt->u4TCPCnt;
				pEntry->mcliTcpAckCnt += prTxRpt->u4TCPAckCnt;
			}
#endif
		}
		prTxRpt++;
	}

	os_alloc_mem(pAd, (UCHAR **)&pVOWParam, TxRptCount*sizeof(UNI_CMD_RED_TX_RPT_T) + sizeof(UNI_CMD_VOW_PARAM_T));
	if (pVOWParam == NULL) {
		MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_ERROR,
			"allocate memory for pVOWParam failed!\n");
		return;
	}
	pVowRedTxRpt = &(pVOWParam->VowRedTxRpt);
	pUniCmdRedTxRpt = pVowRedTxRpt->arTxRpt;

	pVowRedTxRpt->ucWordlen = prTxRptEvt->wordlen;
	memcpy(&(pVowRedTxRpt->u4StaInUseBitmap), &(prTxRptEvt->staInUseBitmap), sizeof(pVowRedTxRpt->u4StaInUseBitmap));
	for (i = 1; i < sta_num; i++) {
		if ((staInUseBitmap[i >> RED_INUSE_BITSHIFT] & (1 << (i & RED_INUSE_BITMASK))) == 0)
			continue;

		pUniCmdRedTxRpt->u4TCPAckCnt = cpu2le32(prTxRpt->u4TCPAckCnt);
		pUniCmdRedTxRpt->u4TCPCnt = cpu2le32(prTxRpt->u4TCPCnt);

		prTxRpt++;
		pUniCmdRedTxRpt++;
	}
	pVOWParam->VOWTagValid[UNI_CMD_VOW_RED_TX_RPT] = TRUE;
	pVowRedTxRpt->u2Length = TxRptCount*sizeof(UNI_CMD_RED_TX_RPT_T) + sizeof(UNI_CMD_VOW_RED_TX_RPT_T);
	UniCmdVOWUpdate(pAd, pVOWParam, TRUE, HOST2N9, NULL);
	os_free_mem(pVOWParam);
}

/*
* Unified command UNI_CMD_VOW_RED_TX_RPT (TAG 0x19) handler
*/
static INT32 UniCmdVowRedTxRpt(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVowParam,
	VOID *pHandle,
	UINT32 *u4RespStructSize)
{
	INT32 Ret = NDIS_STATUS_SUCCESS, i;
	P_UNI_CMD_VOW_RED_TX_RPT_T pUniCmdVowRed = (P_UNI_CMD_VOW_RED_TX_RPT_T)pHandle;
	P_UNI_CMD_VOW_RED_TX_RPT_T pParam = &(pVowParam->VowRedTxRpt);

	memcpy(pUniCmdVowRed, pParam, sizeof(UNI_CMD_VOW_RED_TX_RPT_T));
	/* Fill TLV format */
	pUniCmdVowRed->u2Tag = cpu2le16(UNI_CMD_VOW_RED_TX_RPT);
	pUniCmdVowRed->u2Length = cpu2le16(pUniCmdVowRed->u2Length);

	for (i = 0; i < 32; i++){
		pUniCmdVowRed->u4StaInUseBitmap[i] = cpu2le32(pUniCmdVowRed->u4StaInUseBitmap[i]);
	}

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"u2Tag=%d, u2Length=%d, ucWordlen=%d\n",
		le2cpu16(pUniCmdVowRed->u2Tag), le2cpu16(pUniCmdVowRed->u2Length), pUniCmdVowRed->ucWordlen);

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdVowTab[] = {
	{
		.u8CmdFeature = UNI_CMD_VOW_DRR_CTRL,
		.u4StructSize = sizeof(UNI_CMD_VOW_DRR_CTRL_T),
		.pfHandler = UniCmdVowDrrCtrl
	},

	{
		.u8CmdFeature = UNI_CMD_VOW_FEATURE_CTRL,
		.u4StructSize = sizeof(UNI_CMD_VOW_FEATURE_CTRL_T),
		.pfHandler = UniCmdVowFeatureCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP,
		.u4StructSize = sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_1_GROUP_T),
		.pfHandler = UniCmdVowBssGroupCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_BSSGROUP_TOKEN_CFG,
		.u4StructSize = sizeof(UNI_CMD_VOW_BSSGROUP_TOKEN_CFG_T),
		.pfHandler = UniCmdVowBssGroupTokenCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP,
		.u4StructSize = sizeof(UNI_CMD_VOW_BSSGROUP_CTRL_ALL_GROUP_T),
		.pfHandler = UniCmdVowBssGroupCtrlAllGroup
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM,
		.u4StructSize = sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_T),
		.pfHandler = UniCmdVowBssGroupBwGroupQuantum
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL,
		.u4StructSize = sizeof(UNI_CMD_VOW_BSSGROUP_BW_GROUP_QUANTUM_ALL_T),
		.pfHandler = UniCmdVowBssGroupBwGroupQuantumALL
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_AT_PROC_EST_FEATURE,
		.u4StructSize = sizeof(UNI_CMD_VOW_AT_PROC_EST_FEATURE_T),
		.pfHandler = UniCmdVowATProcEstFeature
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD,
		.u4StructSize = sizeof(UNI_CMD_VOW_AT_PROC_EST_MONITOR_PERIOD_T),
		.pfHandler = UniCmdVowATProcEstMonitorPeriod
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO,
		.u4StructSize = sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_RATIO_T),
		.pfHandler = UniCmdVowATProcEstGroupRatio
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING,
		.u4StructSize = sizeof(UNI_CMD_VOW_AT_PROC_EST_GROUP_TO_BAND_MAPPING_T),
		.pfHandler = UniCmdVowATProcEstGroupToBandMapping
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_AIRTIME_EN,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_EN_T),
		.pfHandler = UniCmdVowRxATAirtimeEn
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_MIBTIME_EN,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_MIBTIME_EN_T),
		.pfHandler = UniCmdVowRxATMibtimeEn
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_EARLYEND_EN,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_EARLYEND_EN_T),
		.pfHandler = UniCmdVowRxATEarlyendEn
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_AIRTIME_CLR_EN_T),
		.pfHandler = UniCmdVowRxAtAirtimeClrEn
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_STA_WMM_CTRL,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_STA_WMM_CTRL_T),
		.pfHandler = UniCmdVowRxAtStaWmmCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_MBSS_WMM_CTRL_T),
		.pfHandler = UniCmdVowRxAtMbssWmmCtrl
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_ED_OFFSET,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_ED_OFFSET_T),
		.pfHandler = UniCmdVowRxAtEdOffset
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_SW_TIMER,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_SW_TIMER_T),
		.pfHandler = UniCmdVowRxAtSwTimer
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_BACKOFF_TIMER,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_BACKOFF_TIMER_T),
		.pfHandler = UniCmdVowRxAtBackoffTimer
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_NONWIFI_TIME_T),
		.pfHandler = UniCmdVowRxAtReportRxNonwifiTime
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_REPORT_RX_OBSS_TIME_T),
		.pfHandler = UniCmdVowRxAtReportRxObssTime
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_REPORT_MIB_OBSS_TIME_T),
		.pfHandler = UniCmdVowRxAtReportMibObssTime
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME,
		.u4StructSize = sizeof(UNI_CMD_VOW_RX_AT_REPORT_PER_STA_RX_TIME_T),
		.pfHandler = UniCmdVowRxAtReportPerStaRxTime
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RED_ENABLE,
		.u4StructSize = sizeof(UNI_CMD_VOW_RED_ENABLE_T),
		.pfHandler = UniCmdVowRedEnable
	},
	{
		.u8CmdFeature = UNI_CMD_VOW_RED_TX_RPT,
		.u4StructSize = sizeof(UNI_CMD_VOW_RED_TX_RPT_T),
		.pfHandler = UniCmdVowRedTxRpt
	},
};

static UINT32 UniCmdVowExtraAllocDynSizeCheck(RTMP_ADAPTER *pAd, P_UNI_CMD_VOW_PARAM_T pVOWParam)
{
	UINT32 BufSize = 0;

	if (pVOWParam->VOWTagValid[UNI_CMD_VOW_RED_TX_RPT])
		BufSize += pVOWParam->VowRedTxRpt.u2Length-sizeof(UNI_CMD_VOW_RED_TX_RPT_T);

	return BufSize;
}


INT32 UniCmdVOWUpdate(
	struct _RTMP_ADAPTER *pAd,
	P_UNI_CMD_VOW_PARAM_T pVOWParam,
	BOOLEAN isSet,
	UINT8 McuDest,
	VOID *pResult)
{
	struct cmd_msg			*msg = NULL;
	INT32					Ret = NDIS_STATUS_SUCCESS;
	UINT8					i = 0;
	UINT16					u2TLVNumber = 0;
	PUCHAR					pTempBuf = NULL;
	PUCHAR					pNextHeadBuf = NULL;
	UINT32					u4CmdNeedMaxBufSize = 0;
	UINT32					u4RealUseBufSize = 0;
	UINT32					u4SendBufSize = 0;
	UINT32					u4RemainingPayloadSize = 0;
	UINT32					u4ComCmdSize = 0;
	UINT32					u4RespStructSize = 0;
	P_UNI_CMD_VOW_T			pUniCmdVow = NULL;
	RTMP_CHIP_CAP			*cap = hc_get_chip_cap(pAd->hdev_ctrl);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_VOW_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < UNI_CMD_VOW_MAX_NUM; i++) {
		if (pVOWParam->VOWTagValid[i])
			u4CmdNeedMaxBufSize += UniCmdVowTab[i].u4StructSize;
	}
	u4CmdNeedMaxBufSize += UniCmdVowExtraAllocDynSizeCheck(pAd, pVOWParam);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pUniCmdVow = (P_UNI_CMD_VOW_T)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < UNI_CMD_VOW_MAX_NUM; i++) {
		if (pVOWParam->VOWTagValid[i]) {
			Ret = ((PFN_VOW_HANDLE)(UniCmdVowTab[i].pfHandler))(pAd, pVOWParam, pNextHeadBuf, &u4RespStructSize);
			if (Ret == NDIS_STATUS_SUCCESS) {
				pNextHeadBuf += UniCmdVowTab[i].u4StructSize;
				u2TLVNumber++;
			} else {
				MTWF_PRINT("%s: The hanlder of tag (0x%llx) return fail!\n",
					__func__, UniCmdVowTab[i].u8CmdFeature);
			}
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_INFO,
		"Operation=%s, TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d, u4RespStructSize=%d\n",
		(isSet || u4RespStructSize == 0) ? "Set" : "Query",
		u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize, u4RespStructSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN bNeedFrag = FALSE;
		BOOLEAN bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2; /* find first TLV length position */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize); /* fill in total length if need fragement */
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE	attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, McuDest);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_VOW);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pResult);
			if ((!bNeedFrag) || bLastFrag) {
				if (isSet) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
				} else if (u4RespStructSize > 0) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(u4RespStructSize));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventVowHandler);
				} else {
					MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_ERROR,
						"Query with u4RespStructSize is %d\n",
						u4RespStructSize);
					Ret = NDIS_STATUS_FAILURE;
					goto error;
				}
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			call_fw_cmd_notifieriers(WO_CMD_DEV_INFO, pAd, msg->net_pkt);
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_AP, CATAP_VOW, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* CONFIG_AP_SUPPORT */

#ifdef LED_CONTROL_SUPPORT
INT32 UniCmdLedCtrl(
	struct _RTMP_ADAPTER *pAd,
	UINT8 led_index,
	UINT8 tx_over_blink,
	UINT8 reverse_polarity,
	UINT8 band,
	UINT8 blink_mode,
	UINT8 off_time,
	UINT8 on_time,
	UINT8 led_control_mode)
{
	struct cmd_msg *msg = NULL;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_LED_T cmd;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	union UNI_LED_SET_CTRL led_ctrl;
	UINT8 led_act_type = led_control_mode;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	u4ComCmdSize = sizeof(struct UNI_CMD_LED_T);
	os_zero_mem(&cmd, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	switch (led_act_type) {
	case LED_SOLID_ON:
		reverse_polarity = !reverse_polarity;
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(led_ctrl.led_solid_on);
		os_zero_mem(&led_ctrl.led_solid_on, sizeof(led_ctrl.led_solid_on));
		break;
	case LED_SOLID_OFF:
		reverse_polarity = !reverse_polarity;
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(led_ctrl.led_solid_off);
		os_zero_mem(&led_ctrl.led_solid_off, sizeof(led_ctrl.led_solid_off));
		break;
	case LED_TX_BLINKING:
	case LED_GENERAL_FIX_BLINKING_FORMAT:
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(led_ctrl.led_tx_blink);
		os_zero_mem(&led_ctrl.led_tx_blink, sizeof(led_ctrl.led_tx_blink));
		break;
	case LED_BLINKING_500MS_ON_500MS_OFF:
	case LED_BLINKING_250MS_ON_250MS_OFF:
	case LED_BLINKING_170MS_ON_170MS_OFF:
	case LED_BLINKING_500MS_ON_100MS_OFF:
	case LED_BLINKING_500MS_ON_700MS_OFF:
		if (tx_over_blink) {
			u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(led_ctrl.led_tx_blink);
			os_zero_mem(&led_ctrl.led_tx_blink, sizeof(led_ctrl.led_tx_blink));
			led_act_type = LED_TX_BLINKING;
		} else {
			u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(led_ctrl.led_set_pwm);
			os_zero_mem(&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		}
		break;
	default:
		break;
	}

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_LED);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	cmd.ucLedVer = 2;
	cmd.ucLedIdx = led_index;
	cmd.ucReversePol = reverse_polarity;
	cmd.ucBandSelect = band;
	AndesAppendCmdMsg(msg, (char *)&cmd, sizeof(cmd));

	/* Step 4: Fill TLV parameters here */
	switch (led_act_type) {
	case LED_SOLID_ON:
		led_ctrl.led_solid_on.u2Tag = UNI_CMD_LED_SET_SOLID_ON;
		led_ctrl.led_solid_on.u2Length = sizeof(led_ctrl.led_solid_on);
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_solid_on.u2Tag = cpu2le16(led_ctrl.led_solid_on.u2Tag);
		led_ctrl.led_solid_on.u2Length = cpu2le16(led_ctrl.led_solid_on.u2Length);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_solid_on, sizeof(led_ctrl.led_solid_on));
		break;
	case LED_SOLID_OFF:
		led_ctrl.led_solid_off.u2Tag = UNI_CMD_LED_SET_SOLID_OFF;
		led_ctrl.led_solid_off.u2Length = sizeof(led_ctrl.led_solid_off);
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_solid_off.u2Tag = cpu2le16(led_ctrl.led_solid_off.u2Tag);
		led_ctrl.led_solid_off.u2Length = cpu2le16(led_ctrl.led_solid_off.u2Length);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_solid_off, sizeof(led_ctrl.led_solid_off));
		break;
	case LED_TX_BLINKING:
		led_ctrl.led_tx_blink.u2Tag = UNI_CMD_LED_SET_TX_BLINK;
		led_ctrl.led_tx_blink.u2Length = sizeof(led_ctrl.led_tx_blink);
		led_ctrl.led_tx_blink.ucLedCombine = 0;
		led_ctrl.led_tx_blink.ucBlinkMode = blink_mode;
		if (on_time != 0)
			led_ctrl.led_tx_blink.u2TxBlinkOnTime = (on_time * 10);
		else
			led_ctrl.led_tx_blink.u2TxBlinkOnTime = 70; /* 70 ms */

		if (off_time != 0)
			led_ctrl.led_tx_blink.u2TxBlinkOffTime = (off_time * 10);
		else
			led_ctrl.led_tx_blink.u2TxBlinkOffTime = 30; /* 30 ms */
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_tx_blink.u2Tag = cpu2le16(led_ctrl.led_tx_blink.u2Tag);
		led_ctrl.led_tx_blink.u2Length = cpu2le16(led_ctrl.led_tx_blink.u2Length);
		led_ctrl.led_tx_blink.u2TxBlinkOnTime = cpu2le16(led_ctrl.led_tx_blink.u2TxBlinkOnTime);
		led_ctrl.led_tx_blink.u2TxBlinkOffTime = cpu2le16(led_ctrl.led_tx_blink.u2TxBlinkOffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_tx_blink, sizeof(led_ctrl.led_tx_blink));
		break;
	case LED_BLINKING_500MS_ON_500MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S0OnTime = 500;
		led_ctrl.led_set_pwm.u2S0OffTime = 500;
		led_ctrl.led_set_pwm.u4S1TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S1OnTime = 500;
		led_ctrl.led_set_pwm.u2S1OffTime = 500;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_250MS_ON_250MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S0OnTime = 250;
		led_ctrl.led_set_pwm.u2S0OffTime = 250;
		led_ctrl.led_set_pwm.u4S1TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S1OnTime = 250;
		led_ctrl.led_set_pwm.u2S1OffTime = 250;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_170MS_ON_170MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S0OnTime = 170;
		led_ctrl.led_set_pwm.u2S0OffTime = 170;
		led_ctrl.led_set_pwm.u4S1TotalTime = 1000;
		led_ctrl.led_set_pwm.u2S1OnTime = 170;
		led_ctrl.led_set_pwm.u2S1OffTime = 170;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_500MS_ON_100MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 600;
		led_ctrl.led_set_pwm.u2S0OnTime = 500;
		led_ctrl.led_set_pwm.u2S0OffTime = 100;
		led_ctrl.led_set_pwm.u4S1TotalTime = 600;
		led_ctrl.led_set_pwm.u2S1OnTime = 500;
		led_ctrl.led_set_pwm.u2S1OffTime = 100;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_500MS_ON_700MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 1200;
		led_ctrl.led_set_pwm.u2S0OnTime = 500;
		led_ctrl.led_set_pwm.u2S0OffTime = 700;
		led_ctrl.led_set_pwm.u4S1TotalTime = 1200;
		led_ctrl.led_set_pwm.u2S1OnTime = 500;
		led_ctrl.led_set_pwm.u2S1OffTime = 700;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_1000MS_ON_1000MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 2000;
		led_ctrl.led_set_pwm.u2S0OnTime = 1000;
		led_ctrl.led_set_pwm.u2S0OffTime = 1000;
		led_ctrl.led_set_pwm.u4S1TotalTime = 2000;
		led_ctrl.led_set_pwm.u2S1OnTime = 1000;
		led_ctrl.led_set_pwm.u2S1OffTime = 1000;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;
	case LED_BLINKING_2000MS_ON_2000MS_OFF:
		led_ctrl.led_set_pwm.u2Tag = UNI_CMD_LED_SET_PWM;
		led_ctrl.led_set_pwm.u2Length = sizeof(led_ctrl.led_set_pwm);
		led_ctrl.led_set_pwm.ucReplayMode = 0;
		led_ctrl.led_set_pwm.u4S0TotalTime = 4000;
		led_ctrl.led_set_pwm.u2S0OnTime = 2000;
		led_ctrl.led_set_pwm.u2S0OffTime = 2000;
		led_ctrl.led_set_pwm.u4S1TotalTime = 4000;
		led_ctrl.led_set_pwm.u2S1OnTime = 2000;
		led_ctrl.led_set_pwm.u2S1OffTime = 2000;
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_set_pwm.u2Tag = cpu2le16(led_ctrl.led_set_pwm.u2Tag);
		led_ctrl.led_set_pwm.u2Length = cpu2le16(led_ctrl.led_set_pwm.u2Length);
		led_ctrl.led_set_pwm.u4S0TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S0TotalTime);
		led_ctrl.led_set_pwm.u2S0OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OnTime);
		led_ctrl.led_set_pwm.u2S0OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S0OffTime);
		led_ctrl.led_set_pwm.u4S1TotalTime = cpu2le32(led_ctrl.led_set_pwm.u4S1TotalTime);
		led_ctrl.led_set_pwm.u2S1OnTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OnTime);
		led_ctrl.led_set_pwm.u2S1OffTime = cpu2le16(led_ctrl.led_set_pwm.u2S1OffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_set_pwm, sizeof(led_ctrl.led_set_pwm));
		break;

	/*Generic fix blinking format*/
	case LED_GENERAL_FIX_BLINKING_FORMAT:
		led_ctrl.led_tx_blink.u2Tag = UNI_CMD_LED_SET_TX_BLINK;
		led_ctrl.led_tx_blink.u2Length = sizeof(led_ctrl.led_tx_blink);
		led_ctrl.led_tx_blink.ucLedCombine = 0;
		led_ctrl.led_tx_blink.ucBlinkMode = blink_mode;
		led_ctrl.led_tx_blink.u2TxBlinkOnTime = (on_time * 10);
		led_ctrl.led_tx_blink.u2TxBlinkOffTime = (off_time * 10);
#ifdef CFG_BIG_ENDIAN
		led_ctrl.led_tx_blink.u2Tag = cpu2le16(led_ctrl.led_tx_blink.u2Tag);
		led_ctrl.led_tx_blink.u2Length = cpu2le16(led_ctrl.led_tx_blink.u2Length);
		led_ctrl.led_tx_blink.u2TxBlinkOnTime = cpu2le16(led_ctrl.led_tx_blink.u2TxBlinkOnTime);
		led_ctrl.led_tx_blink.u2TxBlinkOffTime = cpu2le16(led_ctrl.led_tx_blink.u2TxBlinkOffTime);
#endif /* CFG_BIG_ENDIAN */
		AndesAppendCmdMsg(msg, (char *)&led_ctrl.led_tx_blink, sizeof(led_ctrl.led_tx_blink));
		break;
	default:
		break;
	}

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdLedGpio(
	struct _RTMP_ADAPTER *pAd,
	UINT8 led_index,
	UINT16 gpio_index,
	UINT8 gpio_ctrl_type)
{
	struct cmd_msg *msg = NULL;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_LED_T cmd;
	struct UNI_CMD_LED_SET_GPIO_T tag;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	u4ComCmdSize = sizeof(struct UNI_CMD_LED_T);
	os_zero_mem(&cmd, u4ComCmdSize);
	os_zero_mem(&tag, sizeof(struct UNI_CMD_LED_SET_GPIO_T));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_LED_SET_GPIO_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_LED);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	cmd.ucLedVer = 2;
	cmd.ucLedIdx = led_index;
	AndesAppendCmdMsg(msg, (char *)&cmd, sizeof(cmd));

	/* Step 4: Fill TLV parameters here */
	tag.u2Tag = UNI_CMD_LED_SET_GPIO;
	tag.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	tag.u2Tag = cpu2le16(tag.u2Tag);
	tag.u2Length = cpu2le16(tag.u2Length);
#endif /* CFG_BIG_ENDIAN */
	tag.ucGpioIdx = (UINT8)gpio_index;
	if (gpio_ctrl_type == FW_LED)
		tag.ucGpioValue = UNI_CMD_LED_MODE_GPIO;
	else
		tag.ucGpioValue = UNI_CMD_LED_MODE_LED;
	AndesAppendCmdMsg(msg, (char *)&tag, sizeof(tag));

	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", ret);
	return ret;
}
#endif /* LED_CONTROL_SUPPORT */

INT32 UniCmdTestmodeRFCtrl(struct _RTMP_ADAPTER *pAd, struct _UNI_CMD_TEST_CTRL_T *p_RFCtrlInfo, VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_TEST_CTRL_T *pRFCtrlValue = (struct _UNI_CMD_TEST_CTRL_T *)pHandle;

	/* Fill TLV format */
	pRFCtrlValue->u2Tag = UNI_CMD_RF_TEST_CTRL;
	pRFCtrlValue->u2Length = sizeof(struct _UNI_CMD_TEST_CTRL_T);

	pRFCtrlValue->ucAction = p_RFCtrlInfo->ucAction;
	pRFCtrlValue->ucIcapLen = p_RFCtrlInfo->ucIcapLen;
	memcpy(pRFCtrlValue->aucReserved, p_RFCtrlInfo->aucReserved, sizeof(pRFCtrlValue->aucReserved));
	pRFCtrlValue->u = p_RFCtrlInfo->u;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdTestCtrlTab[UNI_CMD_RF_TEST_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_RF_TEST_CTRL_FEATURE,
		.u4StructSize = sizeof(struct _UNI_CMD_TEST_CTRL_T),
		.pfHandler = UniCmdTestmodeRFCtrl
	},
};

INT32 UniCmdTestmodeCtrl(struct _RTMP_ADAPTER *pAd,
	struct _UNI_CMD_TEST_CTRL_T *prTestmodeCtrl,
	uint64_t u8TestCtrlFeature,
	struct _UNI_RSP_T *pucTestmodeCtrlRsp)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	uint16_t ucTLVNumber = 0;
	uint8_t *pTempBuf = NULL;
	uint8_t *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 TestmodeRxTabSize = ARRAY_SIZE(UniCmdTestCtrlTab);
	UINT32 u4LastAttrCtrlFlag = 0;
	UINT32 u4MidAttrCtrlFlag = 0;


	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
			"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct _UNI_CMD_TESTMODE_CTRL_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < TestmodeRxTabSize; i++) {
		if (u8TestCtrlFeature & UniCmdTestCtrlTab[i].u8CmdFeature)
			u4CmdNeedMaxBufSize += UniCmdTestCtrlTab[i].u4StructSize;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < TestmodeRxTabSize; i++) {
		switch (u8TestCtrlFeature & UniCmdTestCtrlTab[i].u8CmdFeature) {
		case UNI_CMD_RF_TEST_CTRL_FEATURE:
			if (UniCmdTestCtrlTab[i].pfHandler != NULL) {
				Ret = ((PFN_TESTMODE_RF_CTRL_HANDLE)(UniCmdTestCtrlTab[i].pfHandler))(pAd, prTestmodeCtrl, pNextHeadBuf);
				if (Ret == NDIS_STATUS_SUCCESS) {
					pNextHeadBuf += UniCmdTestCtrlTab[i].u4StructSize;
					ucTLVNumber++;
					if (prTestmodeCtrl->ucIcapAttr == ATTRIBUTE_ICAP_GET) {
						u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY;
						u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP;
					} else {
						u4MidAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY;
						u4LastAttrCtrlFlag = INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP;
					}
				}
			}
			break;

		default:
			Ret = NDIS_STATUS_INVALID_DATA;
			break;
		}

		if ((u8TestCtrlFeature & UniCmdTestCtrlTab[i].u8CmdFeature) && (Ret != NDIS_STATUS_SUCCESS)) {
			MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_ERROR,
				"The handler of feature (0x%llx) return fail!\n", (UniCmdTestCtrlTab[i].u8CmdFeature & u8TestCtrlFeature));
		}
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		uint8_t uSeqNum = AndesGetCmdMsgSeq(pAd);
		uint8_t uFragNum = 0;
		uint8_t uTotalFrag = 0;
		uint8_t bNeedFrag = FALSE;
		uint8_t bLastFrag = FALSE;

		if (u4RealUseBufSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % UNI_CMD_MAX_INBAND_CMD_LEN) == 0) ?
				(u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) : ((u4RealUseBufSize / UNI_CMD_MAX_INBAND_CMD_LEN) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;

		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > UNI_CMD_MAX_INBAND_CMD_LEN) {
				bNeedFrag = TRUE;
				u4SendBufSize = UNI_CMD_MAX_INBAND_CMD_LEN;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
				"pucTestmodeCtrlRsp->u2RspSize = %d\n",
				pucTestmodeCtrlRsp->u2RspSize);

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TESTMODE_CTRL);
			if (prTestmodeCtrl->ucAction == ACTION_GET_ENGINE) {
				SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
				SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr,  pucTestmodeCtrlRsp->pcRspData);
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, pucTestmodeCtrlRsp->u2RspSize);
				SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTestEngineHandleEvent);
			} else if (prTestmodeCtrl->ucAction == ACTION_SET_ENGINE) {
				SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
				SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pucTestmodeCtrlRsp->pcRspData);
				SET_CMD_ATTR_CTRL_FLAGS(attr, u4MidAttrCtrlFlag);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			} else {
				SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 30000);
				SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, pucTestmodeCtrlRsp->pcRspData);
				if (!bNeedFrag || bLastFrag) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, u4LastAttrCtrlFlag);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, pucTestmodeCtrlRsp->u2RspSize);
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventTestCtrlHandleEvent);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, u4MidAttrCtrlFlag);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
					SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				}
			}

			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = AndesSendCmdMsg(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_ATE, DBG_LVL_INFO,
		"(Ret = %d)\n", Ret);

	return Ret;
}

NDIS_STATUS UniCmdMldRec(
	RTMP_ADAPTER * pAd,
	UINT32 mldRecIdx
)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_MLO_T  UniCmdMlo;
	struct UNI_CMD_MLO_CMD_T rCmdMldRec;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	rCmdMldRec.u2Tag = UNI_CMD_MLO_MLD_REC;
	rCmdMldRec.u2Length = sizeof(struct UNI_CMD_MLO_CMD_T);
	rCmdMldRec.u4Value = mldRecIdx;

	u4ComCmdSize = sizeof(UniCmdMlo);
	os_zero_mem(&UniCmdMlo, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLO_CMD_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMlo, (u4ComCmdSize));

	AndesAppendCmdMsg(msg, (char *)&rCmdMldRec, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);

	return ret;
}

NDIS_STATUS UniCmdMloAgcTx(
	RTMP_ADAPTER * pAd,
	struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TX_T *prMloAgcTx
)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_MLO_T  UniCmdMlo;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	prMloAgcTx->u2Tag = UNI_CMD_MLO_MLD_REC_LINK_AGC_TX;
	prMloAgcTx->u2Length = sizeof(struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TX_T);

	u4ComCmdSize = sizeof(UniCmdMlo);
	os_zero_mem(&UniCmdMlo, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TX_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMlo, (u4ComCmdSize));

	AndesAppendCmdMsg(msg, (char *)prMloAgcTx, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);

	return ret;
}

NDIS_STATUS UniCmdMloAgcTrig(
	RTMP_ADAPTER * pAd,
	struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TRIG_T *prMloAgcTrig
)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_MLO_T  UniCmdMlo;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	prMloAgcTrig->u2Tag = UNI_CMD_MLO_MLD_REC_LINK_AGC_TRIG;
	prMloAgcTrig->u2Length = sizeof(struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TRIG_T);

	u4ComCmdSize = sizeof(UniCmdMlo);
	os_zero_mem(&UniCmdMlo, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLO_MLD_REC_LINK_AGC_TRIG_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMlo, (u4ComCmdSize));

	AndesAppendCmdMsg(msg, (char *)prMloAgcTrig, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);

	return ret;
}

#ifdef DOT11_EHT_BE
NDIS_STATUS UniCmdMloConfigOperation(
	struct _RTMP_ADAPTER *pAd, UINT8 ucStrBitmap)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_MLO_T  UniCmdMlo;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct UNI_CMD_MLO_CONFIG_OPERATION_T mlo_config_op;

	os_zero_mem(&mlo_config_op, sizeof(struct UNI_CMD_MLO_CONFIG_OPERATION_T));
	mlo_config_op.u2Tag = UNI_CMD_MLO_CONFIG_OPERATION;
	mlo_config_op.u2Length = sizeof(struct UNI_CMD_MLO_CONFIG_OPERATION_T);
	mlo_config_op.ucCapConfigBitMask = ucStrBitmap;
	mlo_config_op.ucStrBitmap = PD_GET_MLO_STR_BITMAP(pAd->physical_dev);
	mlo_config_op.ucSyncTxEnable = PD_GET_MLO_SYNC_TX_ENABLE(pAd->physical_dev);
	if (PD_CEHCK_MLO_V1_ENABLE(pAd->physical_dev))
		mlo_config_op.ucAadNonceLinkAddr = 1;
	else
		mlo_config_op.ucAadNonceLinkAddr = 0;

	u4ComCmdSize = sizeof(UniCmdMlo);
	os_zero_mem(&UniCmdMlo, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLO_CONFIG_OPERATION_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMlo, (u4ComCmdSize));
	AndesAppendCmdMsg(msg, (char *)&mlo_config_op, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);

	return ret;
}
#endif /* DOT11_EHT_BE */

NDIS_STATUS UniCmdMloOptionCtrl(
	RTMP_ADAPTER * pAd,
	struct UNI_CMD_MLO_OPTION_CTRL_T *prMloOptionCtrl
)
{
	struct cmd_msg *msg;
	struct _CMD_ATTRIBUTE attr = {0};
	struct UNI_CMD_MLO_T  UniCmdMlo;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	prMloOptionCtrl->u2Tag = UNI_CMD_MLO_OPTION_CTRL;
	prMloOptionCtrl->u2Length = sizeof(struct UNI_CMD_MLO_OPTION_CTRL_T);

	u4ComCmdSize = sizeof(UniCmdMlo);
	os_zero_mem(&UniCmdMlo, u4ComCmdSize);

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_MLO_OPTION_CTRL_T);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_MLO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdMlo, (u4ComCmdSize));

	AndesAppendCmdMsg(msg, (char *)prMloOptionCtrl, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

error:
	MTWF_DBG(pAd, DBG_CAT_MLO, CATMLO_CFG, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);

	return ret;
}

#if defined(PRE_CAL_MT7915_SUPPORT) || \
	defined(PRE_CAL_MT7986_SUPPORT) || defined(PRE_CAL_MT7916_SUPPORT) || \
	defined(PRE_CAL_MT7981_SUPPORT) || defined(PRE_CAL_BELLWETHER_SUPPORT) || \
	defined(PRE_CAL_MT7990_SUPPORT) || defined(PRE_CAL_MT7992_SUPPORT) || \
	defined(PRE_CAL_MT7993_SUPPORT)
INT32 UniCmdSetPreCalSetResult(
	RTMP_ADAPTER * pAd,
	UINT16 idx,
	UINT32 length,
	UINT32 u4CalId,
	UINT32 eeprom_ofst
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 u4SendIdx = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct _UNI_CALRES_CMD_HANDLE_TAG_T *prUniParams;
	struct _RTMP_CHIP_CAP *cap = NULL;

	cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct _UNI_CMD_ID_PRE_CAL_RESULT_CONFIG_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prUniParams) + length;

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of _UNI_CALRES_CMD_HANDLE_TAG_T */
	prUniParams = (struct _UNI_CALRES_CMD_HANDLE_TAG_T *) pNextHeadBuf;

	prUniParams->u2Tag = PRECAL_CMD_PRE_CAL_RESULT;
	prUniParams->u2Length = sizeof(*prUniParams) + length;
	prUniParams->u4CalId = u4CalId;
	prUniParams->u4CalResLen = length;
#ifdef CFG_BIG_ENDIAN
	prUniParams->u2Tag = cpu2le16(prUniParams->u2Tag);
	prUniParams->u2Length = cpu2le16(prUniParams->u2Length);
	prUniParams->u4CalResLen = cpu2le32(prUniParams->u4CalResLen);
	prUniParams->u4CalId = cpu2le32(prUniParams->u4CalId);
#endif /* CFG_BIG_ENDIAN */

	if (u4CalId == CAL_ID_GROUP_PRE_CAL)
		os_move_mem(prUniParams->au4CalRes, pAd->PreCalImage + (idx * PRE_CAL_SET_MAX_LENGTH), length);
	else /* CAL_ID_TX_DPD_FLATNESS_PRE_CAL */
		os_move_mem(prUniParams->au4CalRes, pAd->TxDPDImage +  eeprom_ofst + (idx * PRE_CAL_SET_MAX_LENGTH), length);

	if (u4CalId == TX_DPD_FLATNESS_CAL) {
		u4SendIdx = idx % ((cap->prek_ee_info.per_legaycy_ch_cal_size + cap->prek_ee_info.per_ch_cal_OTFG0_size) / PRE_CAL_SET_MAX_LENGTH);
	} else if (u4CalId == TX_DPD_FLATNESS_CAL_A6 || u4CalId == TX_DPD_FLATNESS_CAL_A5) {
		u4SendIdx = idx % ((cap->prek_ee_info.per_legaycy_ch_cal_size + cap->prek_ee_info.per_ch_cal_OTFG0_size) / PRE_CAL_SET_MAX_LENGTH);
	} else if (u4CalId == TX_DPD_FLATNESS_CAL_A5_MEM) {
		u4SendIdx = (idx - (cap->prek_ee_info.dpd_cal_5g_legacy_size / PRE_CAL_SET_MAX_LENGTH))
						% ((cap->prek_ee_info.per_mem_ch_cal_size + cap->prek_ee_info.per_ch_cal_OTFG0_size) / PRE_CAL_SET_MAX_LENGTH);
	} else if (u4CalId == TX_DPD_FLATNESS_CAL_A6_MEM) {
		u4SendIdx = (idx - ((cap->prek_ee_info.dpd_cal_6g_legacy_size)  / PRE_CAL_SET_MAX_LENGTH))
						% ((cap->prek_ee_info.per_mem_ch_cal_size + cap->prek_ee_info.per_ch_cal_OTFG0_size) / PRE_CAL_SET_MAX_LENGTH);
	} else {
		u4SendIdx = idx;
	}
	prUniParams->ucCalResOffset = u4SendIdx;
	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_HANDLE_PRECAL_RESULT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", Ret);
	return Ret;
}
#endif
/* defined(PRE_CAL_MT7915_SUPPORT) ||
*  defined(PRE_CAL_MT7986_SUPPORT) || defined(PRE_CAL_MT7916_SUPPORT) ||
*  defined(PRE_CAL_MT7981_SUPPORT) || defined(PRE_CAL_BELLWETHER_SUPPORT) ||
*  defined(PRE_CAL_MT7990_SUPPORT) || defined(PRE_CAL_MT7992_SUPPORT) ||
*  defined(PRE_CAL_MT7993_SUPPORT)
*/

#ifdef PRE_CFG_SUPPORT
INT32 UniCmdPreCfgSetCmdByRaw(
	struct _RTMP_ADAPTER *pAd,
	UINT8 DestType,
	UINT32 UniCmdId,
	UCHAR *pCmdData,
	UINT32 CmdSize
)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_PRECFG, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	if ((pCmdData == NULL) || (CmdSize == 0)) {
		MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_PRECFG, DBG_LVL_ERROR,
				"Input data is incorrect!!!\n");
		ret = NDIS_STATUS_INVALID_DATA;
		goto error;
	}

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, CmdSize);
	if (!msg) {
		MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_PRECFG, DBG_LVL_ERROR,
				"Out of resource!!!\n");
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, DestType); /* MUST be only to N9 */
	SET_CMD_ATTR_TYPE(attr, UniCmdId);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdPreCfgResultRsp);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);
	AndesAppendCmdMsg(msg, (char *)pCmdData, CmdSize);

	ret = chip_cmd_tx(pAd, msg);
error:
	MTWF_DBG(pAd, DBG_CAT_TEST, CATTEST_PRECFG, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}
#endif /* PRE_CFG_SUPPORT */

INT32 UniCmdStateGetTxRxPhyRate(
	RTMP_ADAPTER * pAd,
	UINT16 u2StateCmdTag,
	UINT8 ucBandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_TLV_T *prStateTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
		"ucBandIdx:%u, u2StateCmdTag:%u\n",
		ucBandIdx, u2StateCmdTag);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = ucBandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TLV_T */
	prStateTagParams = (struct UNI_CMD_STATE_TLV_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = u2StateCmdTag;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStateGetCnInfo(
	RTMP_ADAPTER * pAd,
	UINT8 u1BandIdx,
	UINT16 *u2cninfo
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_TLV_T *prStateTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"u1BandIdx:%u\n", u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = u1BandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TLV_T */
	prStateTagParams = (struct UNI_CMD_STATE_TLV_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_OFDMLQ_CNINFO;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, u2cninfo);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_OFDMLQ_CNINFO_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_cn_info_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

#ifdef TXRX_STAT_SUPPORT
INT32 UniCmdStateAllRateCntGet(
	RTMP_ADAPTER *pAd,
	UINT8 ucBandIdx,
	UINT8 ucDirection
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *prStateTagParams;
	USHORT PhyMode = HcGetRadioPhyModeByBandIdx(pAd);
	struct TXRX_RATE_UNI_CMD_PARAM_T rTxRxRateUniParam, *prTxRxRateUniParam;

	prTxRxRateUniParam = &rTxRxRateUniParam;
	prTxRxRateUniParam->ucBandIdx = ucBandIdx;
	prTxRxRateUniParam->PhyMode = PhyMode;
	prTxRxRateUniParam->eDir = (enum ENUM_DIRECTION_T)ucDirection;
	prTxRxRateUniParam->prTxRxRateReport = &(pAd->TxRxRateReport);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"ucBandIdx:%u, ucDirection:%u\n", ucBandIdx, ucDirection);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = ucBandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TX_TD_CCK_T */
	prStateTagParams = (struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_ALL_RATE_CNT_REPORT;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prStateTagParams->u1Direction = ucDirection;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prTxRxRateUniParam);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);

	if (WMODE_CAP_6G(PhyMode))
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_ALL_TXRX_RATE_CNT_REPORT_6G_T));
	else if (WMODE_CAP_5G(PhyMode))
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_ALL_TXRX_RATE_CNT_REPORT_5G_T));
	else
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_ALL_TXRX_RATE_CNT_REPORT_2G_T));

	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_all_rate_cnt_report);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStateStbcCntGet(
	RTMP_ADAPTER *pAd,
	UINT8 ucBandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *prStateTagParams;
	USHORT PhyMode = HcGetRadioPhyModeByBandIdx(pAd);
	struct TXRX_RATE_UNI_CMD_PARAM_T rTxRxRateUniParam, *prTxRxRateUniParam;

	prTxRxRateUniParam = &rTxRxRateUniParam;
	prTxRxRateUniParam->ucBandIdx = ucBandIdx;
	prTxRxRateUniParam->PhyMode = PhyMode;
	prTxRxRateUniParam->prTxRxRateReport = &(pAd->TxRxRateReport);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"ucBandIdx:%u\n", ucBandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = ucBandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TX_TD_CCK_T */
	prStateTagParams = (struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_STBC_CNT_REPORT;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prTxRxRateUniParam);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_STBC_CNT_REPORT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_stbc_cnt_report);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdStateGiCntGet(
	RTMP_ADAPTER *pAd,
	UINT8 ucBandIdx
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *prStateTagParams;
	USHORT PhyMode = HcGetRadioPhyModeByBandIdx(pAd);
	struct TXRX_RATE_UNI_CMD_PARAM_T rTxRxRateUniParam, *prTxRxRateUniParam;

	prTxRxRateUniParam = &rTxRxRateUniParam;
	prTxRxRateUniParam->ucBandIdx = ucBandIdx;
	prTxRxRateUniParam->PhyMode = PhyMode;
	prTxRxRateUniParam->prTxRxRateReport = &(pAd->TxRxRateReport);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"ucBandIdx:%u\n", ucBandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = ucBandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TX_TD_CCK_T */
	prStateTagParams = (struct UNI_CMD_STATE_ALL_RATE_CNT_REPORT_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_GI_CNT_REPORT;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prTxRxRateUniParam);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_GI_CNT_REPORT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_gi_cnt_report);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);

	return Ret;
}
#endif /* TXRX_STAT_SUPPORT */

#ifdef SPECIAL_11B_OBW_FEATURE
INT32 UniCmdStateSetTxTdCck(
	RTMP_ADAPTER * pAd,
	UINT8 u1Enable
)
{
	struct cmd_msg *msg;
	INT32 Ret = TRUE;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_TX_TD_CCK_T *prStateTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"u1Enable:%u\n", u1Enable);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TX_TD_CCK_T */
	prStateTagParams = (struct UNI_CMD_STATE_TX_TD_CCK_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_TX_TD_CCK;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prStateTagParams->u1Enable = u1Enable;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}
#endif /* SPECIAL_11B_OBW_FEATURE */

INT32 UniCmdStateGetTotalTxCnt(
	RTMP_ADAPTER * pAd,
	UINT8 u1BandIdx,
	UINT32 *prStateResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_TLV_T *prStateTagParams;

	if (prStateResult == NULL) {
		Ret = FALSE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(*prStateParams);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"u1BandIdx:%u\n", u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = u1BandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TLV_T */
	prStateTagParams = (struct UNI_CMD_STATE_TLV_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_TOTAL_TX_CNT;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prStateResult);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_TOTAL_TX_CNT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_total_tx_cnt_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStateGetLastTxRate(
	RTMP_ADAPTER * pAd,
	UINT8 u1BandIdx,
	UINT32 * prStateResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_T *prStateParams;
	struct UNI_CMD_STATE_TLV_T *prStateTagParams;

	if (prStateResult == NULL) {
		Ret = FALSE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(*prStateParams);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"u1BandIdx:%u\n", u1BandIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	prStateParams = (struct UNI_CMD_STATE_T *) pNextHeadBuf;
	prStateParams->u1BandIdx = u1BandIdx;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_TLV_T */
	prStateTagParams = (struct UNI_CMD_STATE_TLV_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_LAST_TX_RATE;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prStateResult);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_STATE_LAST_TX_RATE_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_state_last_tx_rate_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdStateGetRxStat(
	RTMP_ADAPTER * pAd
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_STATE_RX_STAT_T *prStateTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_STATE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"u1Enable:%u\n", pAd->OneSecMibBucket.Enabled);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_STATE_RX_STAT_T */
	prStateTagParams = (struct UNI_CMD_STATE_RX_STAT_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_STATE_RX_STAT;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prStateTagParams->u1Enable = pAd->OneSecMibBucket.Enabled;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_STATE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			 "(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetMultiRssi(
	RTMP_ADAPTER * pAd,
	UINT_8 *RssiPair,
	UINT32 Num
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;
	UINT32 index;
	RSSI_PAIR *pRssiPair;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_RSSI;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prTagParams->u2StaNum = Num;

	pRssiPair = (RSSI_PAIR *)RssiPair;

	for (index = 0; index < Num; index++) {
		MTWF_DBG(pAd, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"wcid: %d\n", pRssiPair[index].u2WlanIdx);

		prTagParams->au2StaList[index] = pRssiPair[index].u2WlanIdx;
#ifdef CFG_BIG_ENDIAN
		prTagParams->au2StaList[index] = cpu2le16(prTagParams->au2StaList[index]);
#endif
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, RssiPair);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_RSSI_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_per_sta_info_multi_rssi_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetRssi(
	RTMP_ADAPTER * pAd,
	UINT16 u2WlanIdx,
	UINT32 *rssi_rpt
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"u2WlanIdx:%u\n", u2WlanIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_RSSI;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prTagParams->u2StaNum = 1;
	prTagParams->au2StaList[0] = u2WlanIdx;
#ifdef CFG_BIG_ENDIAN
	prTagParams->au2StaList[0] = cpu2le16(prTagParams->au2StaList[0]);
#endif

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, rssi_rpt);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_RSSI_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_rssi_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_HW, CATHW_PHY, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetSN(
	RTMP_ADAPTER * pAd,
	UINT16 u2WlanIdx,
	UINT_16 *tid_sn_rpt
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"u2WlanIdx:%u\n", u2WlanIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_TID_SN;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prTagParams->u2StaNum = 1;
	prTagParams->au2StaList[0] = u2WlanIdx;
#ifdef CFG_BIG_ENDIAN
	prTagParams->au2StaList[0] = cpu2le16(prTagParams->au2StaList[0]);
#endif

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, tid_sn_rpt);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_TID_SN_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_tid_sn_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetRxRate(
	RTMP_ADAPTER * pAd,
	UINT16 u2PerStaCmdTag,
	UINT8 ucBandIdx,
	UINT16 u2Wcid,
	UINT32 *prRxRateInfo
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"u2PerStaCmdTag:%u ucBandIdx:%u Wcid:%u\n",
			 u2PerStaCmdTag, ucBandIdx, u2Wcid);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = u2PerStaCmdTag;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prTagParams->u2StaNum = 1;
	prTagParams->au2StaList[0] = u2Wcid;
#ifdef CFG_BIG_ENDIAN
	prTagParams->au2StaList[0] = cpu2le16(prTagParams->au2StaList[0]);
#endif

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prRxRateInfo);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_CONTENTION_RX_PHYRATE_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_contention_rxrate_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdMultiStaGetRxRate(
	RTMP_ADAPTER * pAd,
	UINT16 u2PerStaCmdTag,
	UINT_16 *pu2Wcid,
	UINT32 *RxRatePair,
	UINT32 Num
)
{
	struct cmd_msg *msg;
	INT32 Ret = 0;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_T *prPerStaParams;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;
	UINT32 index = 0;
	UINT_16 *Wcid;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
		"u2PerStaCmdTag:%u Num:%d\n", u2PerStaCmdTag, Num);

	if ((Num == 0) || (Num > MAX_STA_LIST_NUM)) {
		MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR, "error Num:%d\n", Num);
		goto error;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	if (RxRatePair == NULL) {
		prPerStaParams = (struct UNI_CMD_PER_STA_INFO_T *) pNextHeadBuf;
		prPerStaParams->u1Unsolicit = 1;
	}
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;
	prTagParams->u2Tag = u2PerStaCmdTag;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prTagParams->u2StaNum = Num;

	Wcid = (UINT_16 *)pu2Wcid;

	for (index = 0; index < Num; index++) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"wcid: %d\n", Wcid[index]);

		prTagParams->au2StaList[index] = Wcid[index];
#ifdef CFG_BIG_ENDIAN
		prTagParams->au2StaList[index] = cpu2le16(prTagParams->au2StaList[index]);
#endif
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);

	if (RxRatePair) {
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, RxRatePair);
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_CONTENTION_RX_PHYRATE_T) * prTagParams->u2StaNum));
		SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_multi_sta_contention_rxrate_handler);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetPER(
	RTMP_ADAPTER * pAd,
	UINT16 u2WlanIdx,
	UINT8 *u1PER
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"u2WlanIdx:%u\n", u2WlanIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_PER;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prTagParams->u2StaNum = 1;
	prTagParams->au2StaList[0] = u2WlanIdx;
#ifdef CFG_BIG_ENDIAN
	prTagParams->au2StaList[0] = cpu2le16(prTagParams->au2StaList[0]);
#endif

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, u1PER);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_PER_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_per_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetSNR(
	RTMP_ADAPTER * pAd,
	UINT16 u2WlanIdx,
	UINT8 *u1SNR
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_PER_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"u2WlanIdx:%u\n", u2WlanIdx);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_SNR;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */

	prTagParams->u2StaNum = 1;
	prTagParams->au2StaList[0] = u2WlanIdx;
#ifdef CFG_BIG_ENDIAN
	prTagParams->au2StaList[0] = cpu2le16(prTagParams->au2StaList[0]);
#endif

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, u1SNR);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_SNR_T) * prTagParams->u2StaNum));
	SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_snr_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdPerStaGetTxRate(
	RTMP_ADAPTER * pAd,
	UINT_16 *pu2Wcid,
	UINT32 Num,
	BOOLEAN IsMultiRsp,
	UINT32 *prStateResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_T *prPerStaParams;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;
	UINT32 index;
	UINT_16 *Wcid;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
		"Num:%u MultiRsp:%u\n", Num, IsMultiRsp);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(*prPerStaParams);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	if (prStateResult == NULL) {
		prPerStaParams = (struct UNI_CMD_PER_STA_INFO_T *) pNextHeadBuf;
		prPerStaParams->u1Unsolicit = 1;
	}

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_TX_RATE;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prTagParams->u2StaNum = Num;

	Wcid = (UINT_16 *)pu2Wcid;

	for (index = 0; index < Num; index++) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"wcid: %d\n", Wcid[index]);

		prTagParams->au2StaList[index] = Wcid[index];
#ifdef CFG_BIG_ENDIAN
		prTagParams->au2StaList[index] = cpu2le16(prTagParams->au2StaList[index]);
#endif
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);

	if (prStateResult) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prStateResult);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_TX_RATE_T) * prTagParams->u2StaNum));

		if (IsMultiRsp)
			SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_multi_tx_rate_handler);
		else
			SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_txrate_handler);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
		"(ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdPerStaGetTxCnt(
	RTMP_ADAPTER * pAd,
	UINT_16 *pu2Wcid,
	UINT32 Num,
	BOOLEAN IsMultiRsp,
	UINT32 *prStateResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_T *prPerStaParams;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;
	UINT32 index;
	UINT_16 *Wcid;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"Num:%u MultiRsp:%u\n", Num, IsMultiRsp);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(*prPerStaParams);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	if (prStateResult == NULL) {
		prPerStaParams = (struct UNI_CMD_PER_STA_INFO_T *) pNextHeadBuf;
		prPerStaParams->u1Unsolicit = 1;
	}

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_TX_CNT;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prTagParams->u2StaNum = Num;

	Wcid = (UINT_16 *)pu2Wcid;

	for (index = 0; index < Num; index++) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"wcid: %d\n", Wcid[index]);

		prTagParams->au2StaList[index] = Wcid[index];
#ifdef CFG_BIG_ENDIAN
		prTagParams->au2StaList[index] = cpu2le16(prTagParams->au2StaList[index]);
#endif
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);

	if (prStateResult) {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prStateResult);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_TX_CNT_T) * prTagParams->u2StaNum));

		if (IsMultiRsp)
			SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_multi_tx_cnt_handler);
		else
			SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_txcnt_handler);
	} else {
		SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
		SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
		SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
		SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	}

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"(ret = %d)\n", Ret);

	return Ret;
}

INT32 UniCmdPerStaGetPktCnt(
	RTMP_ADAPTER *pAd,
	UINT_16 *pu2Wcid,
	UINT32 Num,
	BOOLEAN IsMultiRsp,
	UINT32 *prStateResult
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_PER_STA_INFO_T *prPerStaParams;
	struct UNI_CMD_PER_STA_INFO_COMMON_T *prTagParams;
	UINT32 index;
	UINT_16 *Wcid;

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"%s: Num:%u MultiRsp:%u\n", __func__, Num, IsMultiRsp);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(*prPerStaParams);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prTagParams);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	if (prStateResult == NULL) {
		Ret = FALSE;
		goto error;
	}

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_PER_STA_INFO_COMMON_T */
	prTagParams = (struct UNI_CMD_PER_STA_INFO_COMMON_T *) pNextHeadBuf;

	prTagParams->u2Tag = UNI_CMD_PER_STA_PKT_CNT;
	prTagParams->u2Length = sizeof(*prTagParams);
#ifdef CFG_BIG_ENDIAN
	prTagParams->u2Tag = cpu2le16(prTagParams->u2Tag);
	prTagParams->u2Length = cpu2le16(prTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prTagParams->u2StaNum = Num;

	Wcid = (UINT_16 *)pu2Wcid;

	for (index = 0; index < Num; index++) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
			"%s: wcid: %d\n", __func__, Wcid[index]);

		prTagParams->au2StaList[index] = Wcid[index];
#ifdef CFG_BIG_ENDIAN
		prTagParams->au2StaList[index] = cpu2le16(prTagParams->au2StaList[index]);
#endif
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_PER_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);

	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, prStateResult);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_PER_STA_INFO_COMMON_T) + (sizeof(struct UNI_EVENT_PER_STA_TX_CNT_T) * prTagParams->u2StaNum));

	if (IsMultiRsp)
		SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_multi_pkt_cnt_handler);
	else
		SET_CMD_ATTR_RSP_HANDLER(attr, uni_event_per_sta_pkt_cnt_handler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_COUNTER_INFO, DBG_LVL_DEBUG,
		"%s:(ret = %d)\n", __func__, Ret);

	return Ret;
}


INT32 UniCmdAllStaInfoGetInfo(
	struct _RTMP_ADAPTER *pAd,
	UINT16 subevent_type
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_ALL_STA_INFO_TLV_T *prCmdTlv;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_ALL_STA_INFO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prCmdTlv);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"subevent_type:%u\n",
			 subevent_type);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_ALL_STA_INFO_TLV_T */
	prCmdTlv = (struct UNI_CMD_ALL_STA_INFO_TLV_T *) pNextHeadBuf;
	prCmdTlv->u2Tag = subevent_type;
	prCmdTlv->u2Length = sizeof(*prCmdTlv);
#ifdef CFG_BIG_ENDIAN
	prCmdTlv->u2Tag = cpu2le16(prCmdTlv->u2Tag);
	prCmdTlv->u2Length = cpu2le16(prCmdTlv->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_ALL_STA_INFO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdTrigAssert(
	RTMP_ADAPTER *pAd,
	UINT8 u1Enable
)
{
	struct cmd_msg *msg;
	INT32 Ret;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	struct UNI_CMD_TRIG_ASSERT_COREDUMP_T *prStateTagParams;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_TRIG_ASSERT_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(*prStateTagParams);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
		"u1Enable:%u\n", u1Enable);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = FALSE;
		goto error;
	}

	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_TRIG_ASSERT_COREDUMP */
	prStateTagParams = (struct UNI_CMD_TRIG_ASSERT_COREDUMP_T *) pNextHeadBuf;

	prStateTagParams->u2Tag = UNI_CMD_TRIG_ASSERT_COREDUMP;
	prStateTagParams->u2Length = sizeof(*prStateTagParams);
#ifdef CFG_BIG_ENDIAN
	prStateTagParams->u2Tag = cpu2le16(prStateTagParams->u2Tag);
	prStateTagParams->u2Length = cpu2le16(prStateTagParams->u2Length);
#endif /* CFG_BIG_ENDIAN */
	prStateTagParams->u1TrigEn = u1Enable;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		Ret = FALSE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_TRIG_ASSERT);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)pTempBuf, u4CmdNeedMaxBufSize);

	Ret = chip_cmd_tx(pAd, msg);

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
		"(ret = %d)\n", Ret);
	return Ret;
}

INT32 uni_cmd_rro_rx_path(
	struct _RTMP_ADAPTER *ad,
	UINT8 rx_path_type)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_SET_PLATFORM_TYPE_T *ring_type;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_SET_PLATFORM_TYPE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);

	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_PLATFORM_TYPE_T */
	ring_type = (struct UNI_CMD_RRO_SET_PLATFORM_TYPE_T *) head;
	ring_type->u2Tag = UNI_CMD_RRO_SET_PLATFORM_TYPE;
	ring_type->u2Length = sizeof(struct UNI_CMD_RRO_SET_PLATFORM_TYPE_T);
	ring_type->ucType = rx_path_type;

#ifdef CFG_BIG_ENDIAN
	ring_type->u2Tag = cpu2le16(ring_type->u2Tag);
	ring_type->u2Length = cpu2le16(ring_type->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_release_rro_setbl(
	struct _RTMP_ADAPTER *ad,
	UINT16 seid)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_DEL_SESSION_T *reinit_session;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_DEL_SESSION_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	reinit_session = (struct UNI_CMD_RRO_DEL_SESSION_T *)head;
	reinit_session->u2Tag = UNI_CMD_RRO_DEL_SESSION;
	reinit_session->u2Length = sizeof(struct UNI_CMD_RRO_DEL_SESSION_T);
	reinit_session->u2Seid = seid;

#ifdef CFG_BIG_ENDIAN
	reinit_session->u2Tag = cpu2le16(reinit_session->u2Tag);
	reinit_session->u2Length = cpu2le16(reinit_session->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}



INT32 uni_cmd_rro_bypass_mode(
	struct _RTMP_ADAPTER *ad,
	UINT8 rro_bypass_type)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_SET_BYPASS_MODE_T *rro_bypass_mode;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_SET_BYPASS_MODE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	rro_bypass_mode = (struct UNI_CMD_RRO_SET_BYPASS_MODE_T *)head;
	rro_bypass_mode->u2Tag = UNI_CMD_RRO_SET_BYPASS_MODE;
	rro_bypass_mode->u2Length = sizeof(struct UNI_CMD_RRO_SET_BYPASS_MODE_T);
	rro_bypass_mode->u1RroBypassType = rro_bypass_type;

#ifdef CFG_BIG_ENDIAN
	rro_bypass_mode->u2Tag = cpu2le16(rro_bypass_mode->u2Tag);
	rro_bypass_mode->u2Length = cpu2le16(rro_bypass_mode->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_rro_tx_free_done_path(
	struct _RTMP_ADAPTER *ad,
	UINT8 tx_free_done_path)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_SET_TX_FREEDONE_PATH_T *tx_free_done_path_cmd;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_SET_TX_FREEDONE_PATH_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	tx_free_done_path_cmd = (struct UNI_CMD_RRO_SET_TX_FREEDONE_PATH_T *)head;
	tx_free_done_path_cmd->u2Tag = UNI_CMD_RRO_SET_TX_FREEDONE_PATH;
	tx_free_done_path_cmd->u2Length = sizeof(struct UNI_CMD_RRO_SET_TX_FREEDONE_PATH_T);
	tx_free_done_path_cmd->ucPath = tx_free_done_path;

#ifdef CFG_BIG_ENDIAN
	tx_free_done_path_cmd->u2Tag = cpu2le16(tx_free_done_path_cmd->u2Tag);
	tx_free_done_path_cmd->u2Length = cpu2le16(tx_free_done_path_cmd->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_rro_flush_timeout(
	struct _RTMP_ADAPTER *ad,
	UINT16 u2StepOneTimeout,
	UINT16 u2FlushAllTimeout)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_SET_FLUSH_TIMEOUT_T *rro_flush_timeout;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_SET_FLUSH_TIMEOUT_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	rro_flush_timeout = (struct UNI_CMD_RRO_SET_FLUSH_TIMEOUT_T *)head;
	rro_flush_timeout->u2Tag = UNI_CMD_RRO_SET_FLUSH_TIMEOUT;
	rro_flush_timeout->u2Tag = cpu2le16(rro_flush_timeout->u2Tag);
	rro_flush_timeout->u2Length = sizeof(struct UNI_CMD_RRO_SET_FLUSH_TIMEOUT_T);
	rro_flush_timeout->u2Length = cpu2le16(rro_flush_timeout->u2Length);
	rro_flush_timeout->u2StepOneTimeout = cpu2le16(u2StepOneTimeout);
	rro_flush_timeout->u2FlushAllTimeout = cpu2le16(u2FlushAllTimeout);

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_rro_rss_map(
	struct _RTMP_ADAPTER *ad,
	UINT32 rss_map0,
	UINT32 rss_map1)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_RRO_SET_RSS_MAP_T *rro_rss_map;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_RRO_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_RRO_SET_RSS_MAP_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	rro_rss_map = (struct UNI_CMD_RRO_SET_RSS_MAP_T *)head;
	rro_rss_map->u2Tag = UNI_CMD_RRO_SET_RSS_MAP;
	rro_rss_map->u2Tag = cpu2le16(rro_rss_map->u2Tag);
	rro_rss_map->u2Length = sizeof(struct UNI_CMD_RRO_SET_RSS_MAP_T);
	rro_rss_map->u2Length = cpu2le16(rro_rss_map->u2Length);
	rro_rss_map->rss_map0 = rss_map0;
	rro_rss_map->rss_map1 = rss_map1;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_RRO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_set_nic_cap_query(
	struct _RTMP_ADAPTER *ad)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY_T *nic_cap_query_cmd;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_ID_CHIP_CONFIG_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY_T */
	nic_cap_query_cmd = (struct UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY_T *)head;
	nic_cap_query_cmd->u2Tag = UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY;
	nic_cap_query_cmd->u2Length = sizeof(struct UNI_CMD_CHIP_CONFIG_NIC_CAPABILITY_T);

#ifdef CFG_BIG_ENDIAN
	nic_cap_query_cmd->u2Tag = cpu2le16(nic_cap_query_cmd->u2Tag);
	nic_cap_query_cmd->u2Length = cpu2le16(nic_cap_query_cmd->u2Length);
#endif /* CFG_BIG_ENDIAN */

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CHIP_CONFIG);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniEventNicCapHandler);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_chip_config_dup_wtbl_range(
	struct _RTMP_ADAPTER *ad,
	UINT16 u2WtblDupBase,
	UINT16 u2WtblDupNumber)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_CHIP_CONFIG_DUP_WTBL_RANGE_T *dup_wtbl_range = NULL;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_ID_CHIP_CONFIG_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_CHIP_CONFIG_DUP_WTBL_RANGE_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	dup_wtbl_range = (struct UNI_CMD_CHIP_CONFIG_DUP_WTBL_RANGE_T *)head;
	dup_wtbl_range->u2Tag = UNI_CMD_CHIP_CONFIG_DUP_WTBL_RANGE;
	dup_wtbl_range->u2Length = sizeof(struct UNI_CMD_CHIP_CONFIG_DUP_WTBL_RANGE_T);
#ifdef CFG_BIG_ENDIAN
	dup_wtbl_range->u2Tag = cpu2le16(dup_wtbl_range->u2Tag);
	dup_wtbl_range->u2Length = cpu2le16(dup_wtbl_range->u2Length);
#endif
	dup_wtbl_range->u2WtblDupBase = u2WtblDupBase;
	dup_wtbl_range->u2WtblDupNumber = u2WtblDupNumber;

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DEVINFO, DBG_LVL_INFO,
		"T=0x%x,L=%d,u2WtblDupBase=%d,u2WtblDupNumber=%d.\n",
		dup_wtbl_range->u2Tag,
		dup_wtbl_range->u2Length,
		dup_wtbl_range->u2WtblDupBase, dup_wtbl_range->u2WtblDupNumber);

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_CHIP_CONFIG);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 uni_cmd_fr_table_add_for_duptx(
	struct _RTMP_ADAPTER *ad)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT16 u2TLVNumber = 0;
	PUCHAR pTempBuf = NULL;
	PUCHAR pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	struct UNI_CMD_FR_TABLE_T *cmd_fr_tab = NULL;
	RTMP_CHIP_CAP *cap = PD_GET_CHIP_CAP_PTR(ad->physical_dev);
	UINT8 band_idx = hc_get_hw_band_idx(ad);

	if (band_idx >= cap->hw_band_num) {
		MTWF_DBG(ad, DBG_CAT_FW, CATFW_FR_TABLE, DBG_LVL_ERROR,
			"invalid band index(=%d)\n", band_idx);
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_FR_TABLE_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	u4CmdNeedMaxBufSize += sizeof(struct UNI_CMD_FR_TABLE_SET_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	cmd_fr_tab = (struct UNI_CMD_FR_TABLE_T *)pNextHeadBuf;

	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	if (chip_set_spe_fr_table(
		ad, band_idx, (FR_TABLE_START_IDX+band_idx*2), pNextHeadBuf) == TRUE) {
		pNextHeadBuf += sizeof(struct UNI_CMD_FR_TABLE_SET_T);
		u2TLVNumber++;
	} else {
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_FR_TABLE, DBG_LVL_DEBUG,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(ad);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
				(u4RealUseBufSize / cap->u4MaxInBandCmdLen)
				: ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(ad, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_FR_TABLE);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
			SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
			SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(ad, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_FR_TABLE, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}

INT32 uni_cmd_fr_table_add(
	struct _RTMP_ADAPTER *ad,
	UINT8 rate_idx)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_FR_TABLE_SET_T *fr_tab_set;

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_FR_TABLE_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_FR_TABLE_SET_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	head = tmp_buf + u4ComCmdSize;

	/* Step 3: Filled in parameters of UNI_CMD_RRO_SET_BYPASS_MODE_T */
	fr_tab_set = (struct UNI_CMD_FR_TABLE_SET_T *)head;
	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_FR_TABLE, DBG_LVL_DEBUG,
		"rate_idx = %d\n",
		rate_idx);
	fr_tab_set->u2Tag = UNI_CMD_FR_TABLE_SET;
	fr_tab_set->u2Length = sizeof(struct UNI_CMD_FR_TABLE_SET_T);
	fr_tab_set->u2Tag = cpu2le16(fr_tab_set->u2Tag);
	fr_tab_set->u2Length = cpu2le16(fr_tab_set->u2Length);
	fr_tab_set->ucTabIdx = rate_idx;
	fr_tab_set->ucFrAntIdx = 0;
	fr_tab_set->ucFrSpeIdxSel = 0;
	fr_tab_set->ucFrSpeIdx = BAND0_SPE_IDX;/* band0/1/2 same spe_idx */

	switch (rate_idx) {
	/* Bit:|  MODE |         RATE          |
	*      | 9 - 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	*          0   | 0   0   0   1 |  Rate | - CCK/Short Preamble
	*          0   | 0   0   0   0 |  Rate | - CCK/Long Preamble
	*          1   | 0   0 |     Rate      | - OFDM
	*/
	case UNI_CMD_FR_TABLE_CCK_11M_IDX: /* CCK 11M */
		fr_tab_set->u2FixedRate = 0x0003;
		fr_tab_set->ucFrSpeIdxSel = 1;
		fr_tab_set->ucFrSpeIdx = 0;
		break;

	case UNI_CMD_FR_TABLE_CCK_SPE_2M_IDX: /* CCK 2M */
		fr_tab_set->u2FixedRate = 0x0001;
		break;

	case UNI_CMD_FR_TABLE_CCK_SPE_5_5M_IDX: /* CCK 5.5M */
		fr_tab_set->u2FixedRate = 0x0002;
		break;

	case UNI_CMD_FR_TABLE_CCK_SPE_11M_IDX: /* CCK 11M */
		fr_tab_set->u2FixedRate = 0x0003;
		break;

	case UNI_CMD_FR_TABLE_CCKS_SPE_2M_IDX: /* Short CCK 2M */
		fr_tab_set->u2FixedRate = 0x0005;
		break;

	case UNI_CMD_FR_TABLE_CCKS_SPE_5_5M_IDX: /* Short CCK 5.5M */
		fr_tab_set->u2FixedRate = 0x0006;
		break;

	case UNI_CMD_FR_TABLE_CCKS_SPE_11M_IDX: /* Short CCK 11M */
		fr_tab_set->u2FixedRate = 0x0007;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_9M_IDX: /* OFDM 9M */
		fr_tab_set->u2FixedRate = 0x004F;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_12M_IDX: /* OFDM 12M */
		fr_tab_set->u2FixedRate = 0x004A;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_18M_IDX: /* OFDM 18M */
		fr_tab_set->u2FixedRate = 0x004E;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_24M_IDX: /* OFDM 24M */
		fr_tab_set->u2FixedRate = 0x0049;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_36M_IDX: /* OFDM 36M */
		fr_tab_set->u2FixedRate = 0x004D;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_48_5M_IDX: /* OFDM 48.5M */
		fr_tab_set->u2FixedRate = 0x0048;
		break;

	case UNI_CMD_FR_TABLE_OFDM_SPE_54M_IDX: /* OFDM 54M */
		fr_tab_set->u2FixedRate = 0x004C;
		break;

	case UNI_CMD_FR_TABLE_VHT_1SS_MCS7_IDX: /* VHT 1SS MCS7 */
		fr_tab_set->u2FixedRate = 0x0107;
		break;

	case UNI_CMD_FR_TABLE_HE_SPE_MCS0_IDX: /* HE 4SS MCS0 for 6G Beacon */
		fr_tab_set->u2FixedRate = 0x0200;
		break;

	default:/* No FR IDX */
		goto error;
	}

	fr_tab_set->ucFrGI = 1;
	fr_tab_set->ucFrHeLtf = 1;
	fr_tab_set->fgFrLDPC = 0;
	fr_tab_set->fgFrTBF = 0;
	fr_tab_set->fgFrDynBw = 0;

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_FR_TABLE);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_FR_TABLE, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}


INT32 UniCmdSetLpi(
	struct _RTMP_ADAPTER *pAd,
	UINT8 BandIdx,
	UINT8 ucLpiEnable,
	UINT8 ucPSDLimit)
{
	INT32 ret = NDIS_STATUS_SUCCESS;
	UNI_CMD_BAND_CFG_PARAM_T BandCfgParam;

	os_zero_mem(&BandCfgParam, sizeof(BandCfgParam));
	BandCfgParam.ucDbdcIdx = BandIdx;
	BandCfgParam.BandCfgLpiCtrl.ucLpiEnable = ucLpiEnable;
	BandCfgParam.BandCfgLpiCtrl.ucPSDLimit = ucPSDLimit;
	BandCfgParam.BandCfgTagValid[UNI_CMD_BAND_CONFIG_LPI_CTRL] = TRUE;

	ret = UniCmdBandConfig(pAd, &BandCfgParam);
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG,
			"(bandidx:%d, Ret = %d)\n", BandIdx, ret);
	return ret;
}

static INT32 UniCmdRASandBoxCtrl(IN PRTMP_ADAPTER pAd, IN RTMP_STRING * arg, VOID *pHandle)
{
		UINT8 fgStatus = TRUE;
		INT32 Ret = NDIS_STATUS_SUCCESS;
		struct UNI_CMD_RA_SANDBOX *prRaSandBox = (struct UNI_CMD_RA_SANDBOX *)pHandle;
		INT32 i4Recv = 0;
		UINT32 ret;
		UINT_8	u1UsrIdx = 0;
		UINT_8	u1WlanId = 0;
		BOOLEAN fgSdboxEn = FALSE;
		UINT_8	u1NcDim = 0;
		UINT_8	u1TblIdx = 0;
		UINT_8	u1UpDnRateInd = 0;
		INT_8	i1Cn1 = 0;
		INT_8	i1Cn2 = 0;

		struct _RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

		cap = hc_get_chip_cap(pAd->hdev_ctrl);

		/* Fill TLV format */
		prRaSandBox->u2Tag = cpu2le16(UNI_CMD_RA_SANDBOX_CTRL);
		prRaSandBox->u2Length = cpu2le16(sizeof(struct UNI_CMD_RA_SANDBOX));

		if (arg) {
			do {
				i4Recv = sscanf(arg, "%hhd:%hhd:%hhd:%hhd:%hhd:%hhd:%hhd:%hhd",
							&(u1UsrIdx), &(u1WlanId), &(fgSdboxEn), &(u1NcDim),
							&(u1TblIdx), &(u1UpDnRateInd), &(i1Cn1), &(i1Cn2));

				MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
					"UsrIdx = %d, WlanId = %d, fgSdboxEn = %d, u1NcDim = %d\n",
					u1UsrIdx, u1WlanId, fgSdboxEn, u1NcDim);

				MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
					"u1TblIdx = %d, u1UpDnRateInd = %d, i1Cn1 = %d, i1Cn2 = %d\n",
					u1TblIdx, u1UpDnRateInd, i1Cn1, i1Cn2);

				if (i4Recv != 8) {
					MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
						"Format Error!\n");
					fgStatus = FALSE;
					break;
				}

				RTMP_SEM_EVENT_WAIT(&pAd->AutoRateLock, ret);

				prRaSandBox->u1UsrIdx = u1UsrIdx;
				prRaSandBox->u1WlanId = u1WlanId;
				prRaSandBox->fgSdboxEn = fgSdboxEn;
				prRaSandBox->u1NcDim = u1NcDim;
				prRaSandBox->u1TblIdx = u1TblIdx;
				prRaSandBox->u1UpDnRateInd = u1UpDnRateInd;
				prRaSandBox->i1Cn1 = i1Cn1;
				prRaSandBox->i1Cn2 = i1Cn2;

				RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
			} while (0);
		}

		if (fgStatus == FALSE)
			Ret = NDIS_STATUS_FAILURE;

		return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdSandBoxTab[UNI_CMD_SANDBOX_CMD_MAX_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_RA_SANDBOX_CTRL,
		.u4StructSize = sizeof(struct UNI_CMD_RA_SANDBOX),
		.pfHandler = UniCmdRASandBoxCtrl
	},
};

INT32 UniCmdSandBoxCtrl(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg, UINT32 u4EnableFeature)
{
	struct cmd_msg *msg = NULL;
	INT32 Ret = NDIS_STATUS_SUCCESS;
	UINT32 i = 0;
	UINT16 ucTLVNumber = 0;
	UINT8 *pTempBuf = NULL;
	UINT8 *pNextHeadBuf = NULL;
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4RealUseBufSize = 0;
	UINT32 u4SendBufSize = 0;
	UINT32 u4RemainingPayloadSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT32 SANDBOXTabSize = ARRAY_SIZE(UniCmdSandBoxTab);
	struct UNI_CMD_SANDBOX *pCmdSandBoxUpdate = NULL;
	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_SANDBOX);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < SANDBOXTabSize; i++) {
		if (UniCmdSandBoxTab[i].u8CmdFeature == u4EnableFeature) {
			u4CmdNeedMaxBufSize += UniCmdSandBoxTab[i].u4StructSize;
			break;
		}
	}

	if (i >= SANDBOXTabSize) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
				"Not support for SANDBOX feature input! (0x%x)\n", u4EnableFeature);
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdSandBoxUpdate = (struct UNI_CMD_SANDBOX *)pNextHeadBuf;
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Fill params of  supported feature */
	if (UniCmdSandBoxTab[i].pfHandler != NULL) {
		Ret = ((PFN_SANDBOX_HANDLE)(UniCmdSandBoxTab[i].pfHandler))(pAd, arg, pNextHeadBuf);
		if (Ret == NDIS_STATUS_SUCCESS) {
			pNextHeadBuf += UniCmdSandBoxTab[i].u4StructSize;
			ucTLVNumber++;
		} else
			goto error;
	}

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_ERROR,
		"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
		ucTLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		UINT8 bNeedFrag = FALSE;
		UINT8 bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SANDBOX_CTRL);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
				SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);
			} else {
				SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}
error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_DEBUG, "(Ret = %d)\n", Ret);
	return Ret;
}

INT32 UniCmdRASandBoxCtrlProc(struct _RTMP_ADAPTER *pAd, IN RTMP_STRING * arg)
{
	INT32 Ret = NDIS_STATUS_FAILURE;
	UINT32 u4CmdFeature = UNI_CMD_RA_SANDBOX_CTRL;

	if (arg != NULL)
		Ret = UniCmdSandBoxCtrl(pAd, arg, u4CmdFeature);

	return Ret;
}

#ifdef FTM_SUPPORT
static INT32 UniCmdLocGetCapable(
	struct _RTMP_ADAPTER *pAd,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	P_UNI_CMD_LOC_TAG_GET_CAPA_T pFTMGetCap = (P_UNI_CMD_LOC_TAG_GET_CAPA_T)pHandle;

	pFTMGetCap->u2Tag = UNI_CMD_LOC_TAG_GET_CAPA;
	pFTMGetCap->u2Length = sizeof(UNI_CMD_LOC_TAG_GET_CAPA_T);
#ifdef CFG_BIG_ENDIAN
	pFTMGetCap->u2Tag = cpu2le16(pFTMGetCap->u2Tag);
	pFTMGetCap->u2Length = cpu2le16(pFTMGetCap->u2Length);
#endif /* CFG_BIG_ENDIAN */

	return Ret;
}

static INT LocGetChannelWidth(
	struct wifi_dev *wdev,
	UINT_8 preamble)
{
	USHORT wmode = wdev->PhyMode;
	UCHAR bw = wlan_operate_get_bw(wdev);
	int chWidth;

	// mapping
	switch (bw) {
	case BW_20:
		chWidth = WIFI_CHAN_WIDTH_20;
		break;
	case BW_40:
		chWidth = WIFI_CHAN_WIDTH_40;
		break;
	case BW_80:
		chWidth = WIFI_CHAN_WIDTH_80;
		break;
	case BW_160:
		chWidth = WIFI_CHAN_WIDTH_160;
		break;
	case BW_10:
		return WIFI_CHAN_WIDTH_10;
	case BW_5:
		return WIFI_CHAN_WIDTH_5;
	case BW_8080:
		chWidth = WIFI_CHAN_WIDTH_80P80;
		break;
	default:
		chWidth = WIFI_CHAN_WIDTH_INVALID;
		break;
	}

	if (wmode == WMODE_INVALID)
		return WIFI_CHAN_WIDTH_INVALID;
#ifdef DOT11_EHT_BE
	else if (WMODE_CAP_BE(wmode))
		return chWidth;
#endif /* DOT11_EHT_BE */
#ifdef DOT11_HE_AX
	else if (WMODE_CAP_AX(wmode)) {
		if (preamble & LOC_PREAMBLE_EHT)
			return WIFI_CHAN_WIDTH_INVALID;
		return chWidth;
	}
#endif /* DOT11_HE_AX */
#ifdef DOT11_VHT_AC
	else if (WMODE_CAP_AC(wmode)) {
		if (preamble & (LOC_PREAMBLE_EHT|LOC_PREAMBLE_HE))
			return WIFI_CHAN_WIDTH_INVALID;
		return chWidth;
	}
#endif /* DOT11_VHT_AC */
#ifdef DOT11_N_SUPPORT
	else if (WMODE_CAP_N(wmode)) {
		if (preamble & (LOC_PREAMBLE_EHT|LOC_PREAMBLE_HE|LOC_PREAMBLE_VHT))
			return WIFI_CHAN_WIDTH_INVALID;
		return chWidth;
	}
#endif
	else if (wmode & (WMODE_A|WMODE_B|WMODE_G)) {
		if (preamble & (LOC_PREAMBLE_EHT|LOC_PREAMBLE_HE|LOC_PREAMBLE_VHT|LOC_PREAMBLE_HT))
			return WIFI_CHAN_WIDTH_INVALID;
		return chWidth;
	}

	return WIFI_CHAN_WIDTH_INVALID;
}

static INT32 UniCmdLocRangeReqMC(
	struct _RTMP_ADAPTER *pAd,
	UINT_8  ucSeqNum,
	UINT_8  fgEnable,
	UINT_8  ucConfigNum,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_T *pFTMRangeReq = (struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_T *)pHandle;

	struct _WIFI_CHANNEL_INFO_T wChannel;

	struct wifi_dev *wdev;
	UINT8 ind = 0, num = 0;
	UINT8 *pAddr;
	struct _FTM_PEER_INFO *pPeerInfo;
	void *pPeerInfoArray;
	struct _BSS_INFO_ARGUMENT_T *bssinfo;
	struct freq_oper *chan_oper;
	UINT8 band_idx;

	band_idx = hc_get_hw_band_idx(pAd);
	wdev = uni_cmd_wdev_band_by_ad(pAd);
	if (!wdev)
		return -EINVAL;
	pPeerInfoArray = &wdev->FtmCtrl.iSTA_pinfo;

	num = wdev->FtmCtrl.LastAssignedISTA;

	bssinfo = &wdev->bss_info_argument;
	chan_oper = &bssinfo->chan_oper;

	pFTMRangeReq->u2Tag = UNI_CMD_LOC_TAG_RANGE_REQ_MC;
	pFTMRangeReq->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_T);
#ifdef CFG_BIG_ENDIAN
	pFTMRangeReq->u2Tag = cpu2le16(pFTMRangeReq->u2Tag);
	pFTMRangeReq->u2Length = cpu2le16(pFTMRangeReq->u2Length);
#endif /* CFG_BIG_ENDIAN */

	pFTMRangeReq->ucSeqNum = ucSeqNum;
	pFTMRangeReq->fgEnable = fgEnable;
	pFTMRangeReq->ucConfigNum = ucConfigNum;
	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"fgEnable = %hhu\n", fgEnable);

	for (ind = 0; ind < ucConfigNum; ind++) {
		pPeerInfo = (struct _FTM_PEER_INFO *)pPeerInfoArray + (UINT8)(ind+num);
		pAddr = pPeerInfo->Responder;
		NdisCopyMemory(pFTMRangeReq->arLocConfigs[ind].aucAddr, pAddr, MAC_ADDR_LEN);
		pFTMRangeReq->arLocConfigs[ind].eType = LOC_TYPE_2_SIDED_11MC;
		wChannel.width = 0;
		wChannel.i4center_freq = 0;
		wChannel.center_freq0 = 0;
		wChannel.center_freq1 = 0;
		NdisCopyMemory(&pFTMRangeReq->arLocConfigs[ind].rChannel, &wChannel, sizeof(struct _WIFI_CHANNEL_INFO_T));
		pFTMRangeReq->arLocConfigs[ind].u2BurstPeriod = pPeerInfo->burst_period;
		pFTMRangeReq->arLocConfigs[ind].u2BurstExponent = pPeerInfo->num_burst_exponent;
		pFTMRangeReq->arLocConfigs[ind].u2PreferencePartialTsfTimer = pPeerInfo->partial_tsf;
		pFTMRangeReq->arLocConfigs[ind].ucNumFramesPerBurst = pPeerInfo->ftms_per_burst;
		pFTMRangeReq->arLocConfigs[ind].ucLciRequest = 0;
		pFTMRangeReq->arLocConfigs[ind].ucLcrRequest = 0;
		pFTMRangeReq->arLocConfigs[ind].ucBurstDuration = pPeerInfo->burst_duration;
		pFTMRangeReq->arLocConfigs[ind].ePreamble = pPeerInfo->preamble; // VHT, HE, ...
		pFTMRangeReq->arLocConfigs[ind].eBw = pPeerInfo->bandwidth; // 40, 80, 160
		pFTMRangeReq->arLocConfigs[ind].eBand = band_idx; // 2, 5G
		pFTMRangeReq->arLocConfigs[ind].ucPrimaryChannel = chan_oper->prim_ch;
		pFTMRangeReq->arLocConfigs[ind].ucS1 = chan_oper->cen_ch_1;
		pFTMRangeReq->arLocConfigs[ind].ucS2 = chan_oper->cen_ch_2;
		pFTMRangeReq->arLocConfigs[ind].ucChannelWidth = LocGetChannelWidth(wdev, pPeerInfo->preamble);
		pFTMRangeReq->arLocConfigs[ind].ucBssIndex = bssinfo->ucBssIndex;
		pFTMRangeReq->arLocConfigs[ind].ucASAP = pPeerInfo->asap;
		pFTMRangeReq->arLocConfigs[ind].ucFtmMinDeltaTime = pPeerInfo->min_delta_ftm;

		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ePreamble = %hhu, eBw = %hhu\n",
				pFTMRangeReq->arLocConfigs[ind].ePreamble, pFTMRangeReq->arLocConfigs[ind].eBw);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucBssIndex = %d\n", bssinfo->ucBssIndex);
	}

	return Ret;
}

static INT32 UniCmdLocRangeReqResp(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	UINT_8  fgEnable,
	UINT_8  ucConfigNum,
	VOID *pHandle,
	PFTM_PEER_ENTRY pEntry)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_RANGE_REQ_RSP_T *pLocRangeResp = (struct _UNI_CMD_LOC_TAG_RANGE_REQ_RSP_T *)pHandle;

	struct _LOC_CONFIG_T locConfig;
	struct _LOC_INFORMATION_LCI_T locInfoLCI;
	struct _LOC_INFORMATION_LCR_T locInfoLCR;

	struct _WIFI_CHANNEL_INFO_T wChannel;
	UINT8 ind = 0;
	UINT8 *pAddr;
	struct _FTM_PEER_INFO *pPeerInfo;
	void *pPeerInfoArray;
	struct _BSS_INFO_ARGUMENT_T *bssinfo;
	struct freq_oper *chan_oper;
	UINT8 band_idx;

	band_idx = hc_get_hw_band_idx(pAd);

	NdisZeroMemory(&locConfig, sizeof(struct _LOC_CONFIG_T));
	NdisZeroMemory(&locInfoLCI, sizeof(struct _LOC_INFORMATION_LCI_T));
	NdisZeroMemory(&locInfoLCR, sizeof(struct _LOC_INFORMATION_LCR_T));

	if (!wdev)
		return -EINVAL;
	pPeerInfoArray = &wdev->FtmCtrl.rSTA_pinfo;

	bssinfo = &wdev->bss_info_argument;
	chan_oper = &bssinfo->chan_oper;

	pLocRangeResp->u2Tag = UNI_CMD_LOC_TAG_RANGE_REQ_RSP;
	pLocRangeResp->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_RSP_T);
#ifdef CFG_BIG_ENDIAN
	pLocRangeResp->u2Tag = cpu2le16(pLocRangeResp->u2Tag);
	pLocRangeResp->u2Length = cpu2le16(pLocRangeResp->u2Length);
#endif /* CFG_BIG_ENDIAN */

	pLocRangeResp->ucSeqNum = 0;
	pLocRangeResp->fgEnable = fgEnable;
	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"pLocRangeResp->fgEnable = %hhu\n", pLocRangeResp->fgEnable);

	pLocRangeResp->ucConfigNum = ucConfigNum;
	for (ind = 0; ind < ucConfigNum; ind++) {
		pPeerInfo = (struct _FTM_PEER_INFO *)&pEntry->VerdictPeerInfo;
		pAddr = pEntry->Addr;
		NdisCopyMemory(locConfig.aucAddr, pAddr, MAC_ADDR_LEN);
		locConfig.eType = LOC_TYPE_2_SIDED_11MC;
		wChannel.width = 0;
		wChannel.i4center_freq = 0;
		wChannel.center_freq0 = 0;
		wChannel.center_freq1 = 0;
		NdisCopyMemory(&locConfig.rChannel, &wChannel, sizeof(struct _WIFI_CHANNEL_INFO_T));
		locConfig.u2BurstPeriod = pPeerInfo->burst_period;
		locConfig.u2BurstExponent = pPeerInfo->num_burst_exponent;
		locConfig.ucNumFramesPerBurst = pPeerInfo->ftms_per_burst;
		locConfig.u2PreferencePartialTsfTimer = pPeerInfo->partial_tsf;
		locConfig.ucLciRequest = 0;
		locConfig.ucLcrRequest = 0;
		locConfig.ucBurstDuration = pPeerInfo->burst_duration;
		locConfig.ePreamble = pPeerInfo->preamble; // VHT, HE, ...
		locConfig.eBw = pPeerInfo->bandwidth; // 40, 80, 160
		locConfig.eBand = band_idx; // 2, 5G
		locConfig.ucPrimaryChannel = chan_oper->prim_ch;
		locConfig.ucS1 = chan_oper->cen_ch_1;
		locConfig.ucS2 = chan_oper->cen_ch_2;
		locConfig.ucChannelWidth = LocGetChannelWidth(wdev, pPeerInfo->preamble);
		locConfig.ucBssIndex = bssinfo->ucBssIndex;
		locConfig.ucASAP = pPeerInfo->asap;
		locConfig.ucFtmMinDeltaTime = pPeerInfo->min_delta_ftm;

		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
			"target=%02x:%02x:%02x:%02x:%02x:%02x\n",
			pAddr[0], pAddr[1], pAddr[2], pAddr[3], pAddr[4], pAddr[5]);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"u2BurstPeriod = %d\n", locConfig.u2BurstPeriod);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"u2NumBurst = %d\n", pPeerInfo->num_burst_exponent);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucNumFramesPerBurst = %d\n", locConfig.ucNumFramesPerBurst);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"partial_tsf = %hhu\n", pPeerInfo->partial_tsf);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"burst_duration = %d\n", pPeerInfo->burst_duration);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ePreamble = %d\n", locConfig.ePreamble);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"eBw = %d\n", locConfig.eBw);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucBssIndex = %d\n", locConfig.ucBssIndex);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucChannelWidth = %d\n", locConfig.ucChannelWidth);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucASAP = %d\n", locConfig.ucASAP);
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"ucFtmMinDeltaTime = %d\n", locConfig.ucFtmMinDeltaTime);

		NdisCopyMemory(&pLocRangeResp->arLocRspConfigs[ind].rLOCConfig, &locConfig, sizeof(struct _LOC_CONFIG_T));
		NdisCopyMemory(&pLocRangeResp->arLocRspConfigs[ind].rLocLciInfo, &locInfoLCI, sizeof(struct _LOC_INFORMATION_LCI_T));
		NdisCopyMemory(&pLocRangeResp->arLocRspConfigs[ind].rLocLcrInfo, &locInfoLCR, sizeof(struct _LOC_INFORMATION_LCR_T));
	}

	return Ret;
}

static INT32 UniCmdLocRspEnable(
	struct _RTMP_ADAPTER *pAd,
	UINT_8 fgEnable,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_RSP_ENABLE_T *pFTMEnable = (struct _UNI_CMD_LOC_TAG_RSP_ENABLE_T *)pHandle;
	UINT8 band_idx;

	band_idx = hc_get_hw_band_idx(pAd);

	pFTMEnable->u2Tag = UNI_CMD_LOC_TAG_RSP_ENABLE;
	pFTMEnable->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_RSP_ENABLE_T);
#ifdef CFG_BIG_ENDIAN
	pFTMEnable->u2Tag = cpu2le16(pFTMEnable->u2Tag);
	pFTMEnable->u2Length = cpu2le16(pFTMEnable->u2Length);
#endif /* CFG_BIG_ENDIAN */
	pFTMEnable->fgEnable = fgEnable;
	pFTMEnable->ucBandIdx = band_idx;

	return Ret;
}

static INT32 UniCmdLocDebug(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_DEBUG_T *pFTMDebug = (struct _UNI_CMD_LOC_TAG_DEBUG_T *)pHandle;
	UINT8 ind = 0;
	void *pPeerInfoArray;
	struct _FTM_PEER_INFO *pPeerInfo;

	if (!wdev)
		return -EINVAL;

	pPeerInfoArray = &wdev->FtmCtrl.rSTA_pinfo;
	pPeerInfo = (struct _FTM_PEER_INFO *)pPeerInfoArray;

	pFTMDebug->u2Tag = UNI_CMD_LOC_TAG_DEBUG;
	pFTMDebug->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_DEBUG_T);
#ifdef CFG_BIG_ENDIAN
	pFTMDebug->u2Tag = cpu2le16(pFTMDebug->u2Tag);
	pFTMDebug->u2Length = cpu2le16(pFTMDebug->u2Length);
#endif /* CFG_BIG_ENDIAN */

	for (ind = 0; ind < CFG_LOC_DBG_NUM; ind++)
		pFTMDebug->u4Debug[ind] = pPeerInfo->debug[ind];

	return Ret;
}

static INT32 UniCmdLocRangeReqMCBurst(
	struct _RTMP_ADAPTER *pAd,
	struct wifi_dev *wdev,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST_T *pLocMCBurst = (struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST_T *)pHandle;
	struct _WIFI_CHANNEL_INFO_T wChannel;

	void *pPeerInfoArray;
	struct _FTM_PEER_INFO *pPeerInfo;
	UINT8 peerNum = 0;
	struct _BSS_INFO_ARGUMENT_T *bssinfo;
	UINT8 *pAddr;

	if (!wdev)
		return -EINVAL;

	pPeerInfoArray = &wdev->FtmCtrl.iSTA_pinfo;
	peerNum = wdev->FtmCtrl.LastAssignedISTA;
	pPeerInfo = (struct _FTM_PEER_INFO *)pPeerInfoArray + peerNum;

	bssinfo = &wdev->bss_info_argument;

	pLocMCBurst->u2Tag = UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST;
	pLocMCBurst->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST_T);
#ifdef CFG_BIG_ENDIAN
	pLocMCBurst->u2Tag = cpu2le16(pLocMCBurst->u2Tag);
	pLocMCBurst->u2Length = cpu2le16(pLocMCBurst->u2Length);
#endif /* CFG_BIG_ENDIAN */


	pAddr = pPeerInfo->Responder;
	NdisCopyMemory(pLocMCBurst->aucAddr, pAddr, MAC_ADDR_LEN);

	pLocMCBurst->eType = LOC_TYPE_2_SIDED_11MC;
	pLocMCBurst->ucBssIndex = bssinfo->ucBssIndex;
	wChannel.width = 0;
	wChannel.i4center_freq = 0;
	wChannel.center_freq0 = 0;
	wChannel.center_freq1 = 0;
	NdisCopyMemory(&pLocMCBurst->rChannel, &wChannel, sizeof(struct _WIFI_CHANNEL_INFO_T));

	MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
			"ucBssIndex = %d\n", bssinfo->ucBssIndex);

	return Ret;
}

static INT32 UniCmdLocTOAECal(
	struct _RTMP_ADAPTER *pAd,
	VOID *pHandle)
{
	INT32 Ret = NDIS_STATUS_SUCCESS;
	struct _UNI_CMD_LOC_TAG_TOAE_CAL_CFG_T *pTOAECalCfg = (struct _UNI_CMD_LOC_TAG_TOAE_CAL_CFG_T *)pHandle;

	struct wifi_dev *wdev;
	struct ftm_toae_cfg toae_cfg;

	wdev = uni_cmd_wdev_band_by_ad(pAd);
	if (!wdev)
		return -EINVAL;

	toae_cfg = wdev->FtmCtrl.toae_cfg;

	pTOAECalCfg->u2Tag = UNI_CMD_LOC_TAG_TOAE_CAL_CFG;
	pTOAECalCfg->u2Length = sizeof(struct _UNI_CMD_LOC_TAG_TOAE_CAL_CFG_T);
#ifdef CFG_BIG_ENDIAN
	pTOAECalCfg->u2Tag = cpu2le16(pTOAECalCfg->u2Tag);
	pTOAECalCfg->u2Length = cpu2le16(pTOAECalCfg->u2Length);
#endif /* CFG_BIG_ENDIAN */

	pTOAECalCfg->fgBiasTuning = toae_cfg.fgBiasTuning;
	pTOAECalCfg->u1AntIdx = toae_cfg.u1AntIdx;
	pTOAECalCfg->u1SpeIdxFtm = toae_cfg.u1SpeIdxFtm;
	pTOAECalCfg->u1SpeIdxFtmAck = toae_cfg.u1SpeIdxFtmAck;
	pTOAECalCfg->u2ChainSel = toae_cfg.u2ChainSel;

	return Ret;
}

static UNI_CMD_TAG_HANDLE_T UniCmdLocTab[UNI_CMD_LOC_TAG_NUM] = {
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_GET_CAPA,
		.u4StructSize = sizeof(UNI_CMD_LOC_TAG_GET_CAPA_T),
		.pfHandler = UniCmdLocGetCapable
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_RANGE_REQ_MC,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_T),
		.pfHandler = UniCmdLocRangeReqMC
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_RANGE_REQ_RSP,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_RSP_T),
		.pfHandler = UniCmdLocRangeReqResp
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_RSP_ENABLE,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_RSP_ENABLE_T),
		.pfHandler = UniCmdLocRspEnable
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_DEBUG,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_DEBUG_T),
		.pfHandler = UniCmdLocDebug
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST_T),
		.pfHandler = UniCmdLocRangeReqMCBurst
	},
	{
		.u8CmdFeature = UNI_CMD_LOC_TAG_TOAE_CAL_CFG,
		.u4StructSize = sizeof(struct _UNI_CMD_LOC_TAG_TOAE_CAL_CFG_T),
		.pfHandler = UniCmdLocTOAECal
	},
};

INT32 UniCmdFTM(struct _RTMP_ADAPTER *pAd, struct wifi_dev *wdev, UINT32 u4Action, UINT32 u4SetValue, UINT8 ucDbdcIdx, PFTM_PEER_ENTRY pEntry)
{
	struct cmd_msg				*msg = NULL;
	INT32						Ret = NDIS_STATUS_SUCCESS;
	UINT8						i = 0;
	UINT16						u2TLVNumber = 0;
	PUCHAR						pTempBuf = NULL;
	PUCHAR						pNextHeadBuf = NULL;
	UINT32						u4CmdNeedMaxBufSize = 0;
	UINT32						u4RealUseBufSize = 0;
	UINT32						u4SendBufSize = 0;
	UINT32						u4RemainingPayloadSize = 0;
	UINT32						u4ComCmdSize = 0;
	UINT64						u8CmdFeature = (UINT64)u4Action;
	UINT32						u4LocTabSize = ARRAY_SIZE(UniCmdLocTab);
	P_UNI_CMD_ID_LOCATION_T		pCmdLoc = NULL;
	RTMP_CHIP_CAP				*cap = hc_get_chip_cap(pAd->hdev_ctrl);
	BOOLEAN						bQueryOnly = FALSE;

	ftm_set_last_wdev(wdev);

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		Ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(UNI_CMD_ID_LOCATION_T);
	u4CmdNeedMaxBufSize += u4ComCmdSize;
	for (i = 0; i < u4LocTabSize; i++) {
		if (UniCmdLocTab[i].u8CmdFeature == u8CmdFeature) {
			u4CmdNeedMaxBufSize += UniCmdLocTab[i].u4StructSize;
			break;
		}
	}

	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_INFO,
				"Tag: %llu, u4CmdNeedMaxBufSize = %u\n", u8CmdFeature, u4CmdNeedMaxBufSize);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(pAd, (UCHAR **)&pTempBuf, u4CmdNeedMaxBufSize);
	if (!pTempBuf) {
		Ret = NDIS_STATUS_RESOURCES;
		goto error;
	}
	os_zero_mem(pTempBuf, u4CmdNeedMaxBufSize);
	pNextHeadBuf = pTempBuf;

	/* Step 3: Fill common parameters here */
	pCmdLoc = (P_UNI_CMD_ID_LOCATION_T)pNextHeadBuf;
	/* Nothing to do */
	pNextHeadBuf += u4ComCmdSize;

	/* Step 4: Traverse all support features */
	for (i = 0; i < u4LocTabSize; i++) {
		if (UniCmdLocTab[i].u8CmdFeature == u8CmdFeature) {
			switch (u8CmdFeature) {
			case UNI_CMD_LOC_TAG_GET_CAPA:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					Ret = ((PFN_LOC_TAG_GET_CAPA_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_RANGE_REQ_MC:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					BOOLEAN fgEnable = u4SetValue;

					Ret = ((PFN_LOC_TAG_RANGE_REQ_MC_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, 0, fgEnable, 1, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_RANGE_REQ_RSP:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					BOOLEAN fgEnable = u4SetValue;

					Ret = ((PFN_LOC_TAG_RANGE_REQ_RSP_HANDLE)(UniCmdLocTab[u8CmdFeature].pfHandler))(pAd, wdev, fgEnable, 1, pNextHeadBuf, pEntry);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[u8CmdFeature].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_RSP_ENABLE:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					BOOLEAN fgEnable = u4SetValue;

					Ret = ((PFN_LOC_TAG_RSP_ENABLE_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, fgEnable, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_DEBUG:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					Ret = ((PFN_LOC_TAG_DEDUG_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, wdev, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_RANGE_REQ_MC_BURST:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					Ret = ((PFN_LOC_TAG_DEDUG_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, wdev, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			case UNI_CMD_LOC_TAG_TOAE_CAL_CFG:
				if (UniCmdLocTab[i].pfHandler != NULL) {
					Ret = ((PFN_LOC_TAG_TOAE_CAL_CFG_HANDLE)(UniCmdLocTab[i].pfHandler))(pAd, pNextHeadBuf);
					if (Ret == NDIS_STATUS_SUCCESS) {
						pNextHeadBuf += UniCmdLocTab[i].u4StructSize;
						u2TLVNumber++;
					}
				}
				break;

			default:
				Ret = NDIS_STATUS_SUCCESS;
				MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_ERROR,
					"The hanlder of tag (0x%08x) not support!\n", u4Action);
				break;
			}
		}
	}

	if (Ret != NDIS_STATUS_SUCCESS)
		MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
				"The hanlder of tag (0x%llx) return fail!\n", u8CmdFeature);

	if (u4Action == UNI_CMD_LOC_TAG_GET_CAPA)
		bQueryOnly = TRUE;

	/* Step 5: Calculate real buffer size */
	u4RealUseBufSize = (pNextHeadBuf - pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
			"TLV Num = %d, CmdNeedMaxBufSize = %d, u4RealUseBufSize = %d\n",
			u2TLVNumber, u4CmdNeedMaxBufSize, u4RealUseBufSize);

	/* Step 6: Send data packet and wrap fragement process if need */
	{
		UINT8 uSeqNum = AndesGetCmdMsgSeq(pAd);
		UINT8 uFragNum = 0;
		UINT8 uTotalFrag = 0;
		BOOLEAN	bNeedFrag = FALSE;
		BOOLEAN	bLastFrag = FALSE;

		if (u4RealUseBufSize > cap->u4MaxInBandCmdLen) {
			/* find first TLV length position */
			pNextHeadBuf = pTempBuf + u4ComCmdSize + 2;
			/* fill in total length if need fragement */
			*pNextHeadBuf = (u4RealUseBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
			*pNextHeadBuf = cpu2le16(*pNextHeadBuf);
#endif /* CFG_BIG_ENDIAN */

			/* Calculate total fragment number */
			uTotalFrag = ((u4RealUseBufSize % cap->u4MaxInBandCmdLen) == 0) ?
						  (u4RealUseBufSize / cap->u4MaxInBandCmdLen) : ((u4RealUseBufSize / cap->u4MaxInBandCmdLen) + 1);
		}

		u4RemainingPayloadSize = u4RealUseBufSize;
		pNextHeadBuf = pTempBuf;
		do {
			struct _CMD_ATTRIBUTE attr = {0};

			if (u4RemainingPayloadSize > cap->u4MaxInBandCmdLen) {
				bNeedFrag = TRUE;
				u4SendBufSize = cap->u4MaxInBandCmdLen;
				uFragNum++;
			} else {
				u4SendBufSize = u4RemainingPayloadSize;
				if (bNeedFrag) {
					uFragNum++;
					bLastFrag = TRUE;
				}
			}

			/* Allocate buffer */
			msg = AndesAllocUniCmdMsg(pAd, u4SendBufSize);
			if (!msg) {
				Ret = NDIS_STATUS_RESOURCES;
				goto error;
			}

			SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
			SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_LOCATION);
			SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
			SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
			if (!bNeedFrag || bLastFrag) {
				if (bQueryOnly) {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, UniEventLocHandler);
				} else {
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
					SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
					SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				}
			} else {
				if (bQueryOnly)
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_QUERY_AND_WAIT_RETRY_RSP);
				else
					SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
				SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
				SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
			}
			AndesInitCmdMsg(msg, attr);

			/* Follow fragment rule if need */
			msg->total_frag = uTotalFrag;
			msg->frag_num = uFragNum;
			msg->seq = uSeqNum;

			/* Append this feature */
			AndesAppendCmdMsg(msg, (char *)pNextHeadBuf, u4SendBufSize);
			pNextHeadBuf += u4SendBufSize;

			/* Send out CMD */
			Ret = chip_cmd_tx(pAd, msg);

			/* Process next remaining payload */
			u4RemainingPayloadSize -= u4SendBufSize;
		} while (u4RemainingPayloadSize > 0);
	}

error:
	if (pTempBuf)
		os_free_mem(pTempBuf);

	MTWF_DBG(NULL, DBG_CAT_PROTO, CATPROTO_FTM, DBG_LVL_DEBUG,
			"(Ret = %d)\n", Ret);
	return Ret;
}
#endif /* FTM_SUPPORT */

INT32 uni_cmd_epcs_ctrl(struct _RTMP_ADAPTER *ad, UINT32 u4Cmd, UINT8 *cmdData)
{
	struct cmd_msg *msg;
	INT32 ret = NDIS_STATUS_SUCCESS;
	struct _CMD_ATTRIBUTE attr = {0};
	UINT32 u4CmdNeedMaxBufSize = 0;
	UINT32 u4ComCmdSize = 0;
	UINT8 *tmp_buf = NULL;
	UINT8 *head = NULL;
	struct UNI_CMD_EPCS_T *epcs_cmd;
	struct UNI_CMD_EPCS_CTRL_T *epcs_ctrl;
	struct EPCS_CMD_ENABLE_STA_T         *epcs_enable;
	struct EPCS_CMD_QUERY_STA_T          *epcs_query;

	if (!cmdData) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	/* Step 1: Count maximum buffer size from per TLV */
	u4ComCmdSize = sizeof(struct UNI_CMD_EPCS_T);
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(struct UNI_CMD_EPCS_CTRL_T);

	/* Step 2: Allocate tempotary memory space for use later */
	os_alloc_mem(ad, (UCHAR **)&tmp_buf, u4CmdNeedMaxBufSize);
	if (!tmp_buf) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}
	os_zero_mem(tmp_buf, u4CmdNeedMaxBufSize);
	epcs_cmd = (struct UNI_CMD_EPCS_T *)tmp_buf;
	head = &epcs_cmd->aucTlvBuffer[0];

	/* Step 3: Filled in parameters of UNI_CMD_EPCS_CTRL_T */
	epcs_ctrl = (struct UNI_CMD_EPCS_CTRL_T *)head;
	epcs_ctrl->u2Tag = UNI_CMD_EPCS_CTRL;
	epcs_ctrl->u2Tag = cpu2le16(epcs_ctrl->u2Tag);
	epcs_ctrl->u2Length = sizeof(struct UNI_CMD_EPCS_CTRL_T);
	epcs_ctrl->u2Length = cpu2le16(epcs_ctrl->u2Length);
	epcs_ctrl->u4Cmd = u4Cmd;

	MTWF_DBG(ad, DBG_CAT_TX, CATTX_DABS_QOS, DBG_LVL_ERROR,
			"%s(%d)Cmd=%u\n", __func__, __LINE__, u4Cmd);

	switch (u4Cmd) {
	case EPCS_ENABLE_STA:
		epcs_enable = (struct EPCS_CMD_ENABLE_STA_T *)&epcs_ctrl->au4CmdParam[0];
		memcpy(epcs_enable, cmdData, sizeof(struct EPCS_CMD_ENABLE_STA_T));
		break;
	case EPCS_QUERY_STA:
		epcs_query = (struct EPCS_CMD_QUERY_STA_T *)&epcs_ctrl->au4CmdParam[0];
		memcpy(epcs_query, cmdData, sizeof(struct EPCS_CMD_QUERY_STA_T));
		break;
	default:
		break;
	}

	/* Step 4: Send data packet */
	msg = AndesAllocUniCmdMsg(ad, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2N9);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_EPCS);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_WAIT_RETRY_RSP);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, sizeof(struct UNI_EVENT_CMD_RESULT_T));
	SET_CMD_ATTR_RSP_HANDLER(attr, UniCmdResultRsp);

	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(ad);

	/* Append this feature */
	AndesAppendCmdMsg(msg, (char *)tmp_buf, u4CmdNeedMaxBufSize);

	ret = chip_cmd_tx(ad, msg);

error:
	if (tmp_buf)
		os_free_mem(tmp_buf);

	MTWF_DBG(ad, DBG_CAT_FW, CATFW_DBGINFO, DBG_LVL_INFO,
			"(ret = %d)\n", ret);
	return ret;
}

INT32 UniCmdGetSdo(
	IN struct _RTMP_ADAPTER *pAd,
	IN UINT32 arg0,
	IN UINT32 arg1,
	IN UINT32 arg2,
	struct _CR4_QUERY_STRUC *cr4_query_list)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SDO_T UniCmdSDO = {0};
	struct _UNI_CMD_SDO_QUERY_OP_T cmd_get_sdo = {0};
	struct _CR4_QUERY_STRUC *cr4_query = (struct _CR4_QUERY_STRUC *)cr4_query_list;
	UINT32 u4ComCmdSize = 0, u4CmdNeedMaxBufSize = 0, u4CmdMultiQuerySize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdSDO);
	os_zero_mem(&UniCmdSDO, u4ComCmdSize);
	os_zero_mem(&cmd_get_sdo, sizeof(cmd_get_sdo));
	/* Multiple query */
	if (cr4_query)
		u4CmdMultiQuerySize = arg1 * sizeof(*(cr4_query->list));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_get_sdo) + u4CmdMultiQuerySize;

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SDO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdSDO, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_get_sdo.u2Tag = UNI_CMD_SDO_QUERY_OP;
	cmd_get_sdo.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_get_sdo.u2Tag	= cpu2le16(cmd_get_sdo.u2Tag);
	cmd_get_sdo.u2Length = cpu2le16(cmd_get_sdo.u2Length);
#endif /* CFG_BIG_ENDIAN */
	cmd_get_sdo.u4SdoQueryOptionArg0 = cpu2le32(arg0);
	cmd_get_sdo.u4SdoQueryOptionArg1 = cpu2le32(arg1);
	cmd_get_sdo.u4SdoQueryOptionArg2 = cpu2le32(arg2);

	AndesAppendCmdMsg(msg, (char *)&cmd_get_sdo, sizeof(cmd_get_sdo));
	if (u4CmdMultiQuerySize)
		AndesAppendCmdMsg(msg, (char *)cr4_query->list, u4CmdMultiQuerySize);

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetSdo(
	IN struct _RTMP_ADAPTER *pAd,
	IN UINT32 arg0,
	IN UINT32 arg1,
	IN UINT32 arg2,
	IN UINT32 u4ExtSize,
	IN PUINT8 pExtData)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SDO_T UniCmdSDO = {0};
	struct _UNI_CMD_SDO_SET_OP_T cmd_set_sdo = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdSDO);
	os_zero_mem(&UniCmdSDO, u4ComCmdSize);
	os_zero_mem(&cmd_set_sdo, sizeof(cmd_set_sdo));

	/* Step 1: Count maximum buffer size from per TLV */
	if (u4ExtSize != 0 && pExtData != NULL)
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_sdo) + u4ExtSize;
	else
		u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_sdo);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SDO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdSDO, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_set_sdo.u2Tag = UNI_CMD_SDO_SET_OP;
	cmd_set_sdo.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
#ifdef CFG_BIG_ENDIAN
	cmd_set_sdo.u2Tag	= cpu2le16(cmd_set_sdo.u2Tag);
	cmd_set_sdo.u2Length = cpu2le16(cmd_set_sdo.u2Length);
#endif /* CFG_BIG_ENDIAN */
	cmd_set_sdo.u4SdoSetArg0 = cpu2le32(arg0);
	cmd_set_sdo.u4SdoSetArg1 = cpu2le32(arg1);
	cmd_set_sdo.u4SdoSetArg2 = cpu2le32(arg2);
	AndesAppendCmdMsg(msg, (char *)&cmd_set_sdo, sizeof(cmd_set_sdo));

	if (u4ExtSize != 0 && pExtData != NULL)
		AndesAppendCmdMsg(msg, (char *)pExtData, u4ExtSize);

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

INT32 UniCmdSetSdoAutoBA(
	IN struct _RTMP_ADAPTER *pAd,
	IN BOOLEAN Enable,
	IN UINT32 Timeout)
{
	struct cmd_msg *msg = NULL;
	struct _CMD_ATTRIBUTE attr = {0};
	struct _UNI_CMD_SDO_T UniCmdSDO = {0};
	struct _UNI_CMD_SDO_AUTO_BA_T cmd_set_sdo_auto_ba = {0};
	UINT32 u4ComCmdSize = 0;
	UINT32 u4CmdNeedMaxBufSize = 0;
	INT32 ret = NDIS_STATUS_SUCCESS;

	if (UniCmdCheckInitReady(pAd) == FALSE) {
		MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_ERROR,
				"System isn't ready for in-band command now!!!\n");
		ret = NDIS_STATUS_FAILURE;
		goto error;
	}

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
				"dispath CMD start\n");

	u4ComCmdSize = sizeof(UniCmdSDO);
	os_zero_mem(&UniCmdSDO, u4ComCmdSize);
	os_zero_mem(&cmd_set_sdo_auto_ba, sizeof(cmd_set_sdo_auto_ba));

	/* Step 1: Count maximum buffer size from per TLV */
	u4CmdNeedMaxBufSize = u4ComCmdSize + sizeof(cmd_set_sdo_auto_ba);

	/* Step 2: Allocate memory space */
	msg = AndesAllocUniCmdMsg(pAd, u4CmdNeedMaxBufSize);
	if (!msg) {
		ret = NDIS_STATUS_RESOURCES;
		goto error;
	}

	SET_CMD_ATTR_MCU_DEST(attr, HOST2CR4);
	SET_CMD_ATTR_TYPE(attr, UNI_CMD_ID_SDO);
	SET_CMD_ATTR_RSP_WAIT_MS_TIME(attr, 0);
	SET_CMD_ATTR_RSP_WB_BUF_IN_CALBK(attr, NULL);
	SET_CMD_ATTR_CTRL_FLAGS(attr, INIT_LEN_VAR_UNI_CMD_SET_AND_RETRY);
	SET_CMD_ATTR_RSP_EXPECT_SIZE(attr, 0);
	SET_CMD_ATTR_RSP_HANDLER(attr, NULL);
	AndesInitCmdMsg(msg, attr);
	msg->seq = AndesGetCmdMsgSeq(pAd);

	/* Step 3: Fill and append common parameters here */
	/* Nothing to do */
	AndesAppendCmdMsg(msg, (char *)&UniCmdSDO, u4ComCmdSize);

	/* Step 4: Fill and append TLV parameters here */
	cmd_set_sdo_auto_ba.u2Tag = UNI_CMD_SDO_AUTO_BA;
	cmd_set_sdo_auto_ba.u2Length = (u4CmdNeedMaxBufSize - u4ComCmdSize);
	cmd_set_sdo_auto_ba.ucAutoBaEnable = Enable;
	cmd_set_sdo_auto_ba.ucTarget = 0;
	cmd_set_sdo_auto_ba.u4Timeout = Timeout;
#ifdef CFG_BIG_ENDIAN
	cmd_set_sdo_auto_ba.u2Tag	= cpu2le16(cmd_set_sdo_auto_ba.u2Tag);
	cmd_set_sdo_auto_ba.u2Length = cpu2le16(cmd_set_sdo_auto_ba.u2Length);
	cmd_set_sdo_auto_ba.u4Timeout = cpu2le32(cmd_set_sdo_auto_ba.u4Timeout);
#endif /* CFG_BIG_ENDIAN */
	AndesAppendCmdMsg(msg, (char *)&cmd_set_sdo_auto_ba, (u4CmdNeedMaxBufSize - u4ComCmdSize));

	/* Step 5: Send out cmd */
	ret = chip_cmd_tx(pAd, msg);

	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_INFO,
			 "dispath CMD complete\n");
error:
	MTWF_DBG(pAd, DBG_CAT_FW, CATFW_SDO, DBG_LVL_DEBUG,
			"(ret = %d)\n", ret);
	return ret;

}

#endif /* WIFI_UNIFIED_COMMAND */
